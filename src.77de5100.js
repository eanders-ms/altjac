// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"../node_modules/parcel-bundler/src/builtins/bundle-url.js":[function(require,module,exports) {
var bundleURL = null;

function getBundleURLCached() {
  if (!bundleURL) {
    bundleURL = getBundleURL();
  }

  return bundleURL;
}

function getBundleURL() {
  // Attempt to find the URL of the current script and use that as the base URL
  try {
    throw new Error();
  } catch (err) {
    var matches = ('' + err.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\/\/[^)\n]+/g);

    if (matches) {
      return getBaseURL(matches[0]);
    }
  }

  return '/';
}

function getBaseURL(url) {
  return ('' + url).replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\/\/.+)?\/[^/]+(?:\?.*)?$/, '$1') + '/';
}

exports.getBundleURL = getBundleURLCached;
exports.getBaseURL = getBaseURL;
},{}],"../node_modules/parcel-bundler/src/builtins/css-loader.js":[function(require,module,exports) {
var bundle = require('./bundle-url');

function updateLink(link) {
  var newLink = link.cloneNode();

  newLink.onload = function () {
    link.remove();
  };

  newLink.href = link.href.split('?')[0] + '?' + Date.now();
  link.parentNode.insertBefore(newLink, link.nextSibling);
}

var cssTimeout = null;

function reloadCSS() {
  if (cssTimeout) {
    return;
  }

  cssTimeout = setTimeout(function () {
    var links = document.querySelectorAll('link[rel="stylesheet"]');

    for (var i = 0; i < links.length; i++) {
      if (bundle.getBaseURL(links[i].href) === bundle.getBundleURL()) {
        updateLink(links[i]);
      }
    }

    cssTimeout = null;
  }, 50);
}

module.exports = reloadCSS;
},{"./bundle-url":"../node_modules/parcel-bundler/src/builtins/bundle-url.js"}],"../node_modules/milligram/dist/milligram.css":[function(require,module,exports) {

        var reloadCSS = require('_css_loader');
        module.hot.dispose(reloadCSS);
        module.hot.accept(reloadCSS);
      
},{"_css_loader":"../node_modules/parcel-bundler/src/builtins/css-loader.js"}],"../node_modules/parcel-bundler/src/builtins/_empty.js":[function(require,module,exports) {

},{}],"../node_modules/process/browser.js":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};
},{}],"../node_modules/path-browserify/index.js":[function(require,module,exports) {
var process = require("process");
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

},{"process":"../node_modules/process/browser.js"}],"../node_modules/file-uri-to-path/index.js":[function(require,module,exports) {

/**
 * Module dependencies.
 */

var sep = require('path').sep || '/';

/**
 * Module exports.
 */

module.exports = fileUriToPath;

/**
 * File URI to Path function.
 *
 * @param {String} uri
 * @return {String} path
 * @api public
 */

function fileUriToPath (uri) {
  if ('string' != typeof uri ||
      uri.length <= 7 ||
      'file://' != uri.substring(0, 7)) {
    throw new TypeError('must pass in a file:// URI to convert to a file path');
  }

  var rest = decodeURI(uri.substring(7));
  var firstSlash = rest.indexOf('/');
  var host = rest.substring(0, firstSlash);
  var path = rest.substring(firstSlash + 1);

  // 2.  Scheme Definition
  // As a special case, <host> can be the string "localhost" or the empty
  // string; this is interpreted as "the machine from which the URL is
  // being interpreted".
  if ('localhost' == host) host = '';

  if (host) {
    host = sep + sep + host;
  }

  // 3.2  Drives, drive letters, mount points, file system root
  // Drive letters are mapped into the top of a file URI in various ways,
  // depending on the implementation; some applications substitute
  // vertical bar ("|") for the colon after the drive letter, yielding
  // "file:///c|/tmp/test.txt".  In some cases, the colon is left
  // unchanged, as in "file:///c:/tmp/test.txt".  In other cases, the
  // colon is simply omitted, as in "file:///c/tmp/test.txt".
  path = path.replace(/^(.+)\|/, '$1:');

  // for Windows, we need to invert the path separators from what a URI uses
  if (sep == '\\') {
    path = path.replace(/\//g, '\\');
  }

  if (/^.+\:/.test(path)) {
    // has Windows drive at beginning of path
  } else {
    // unix path…
    path = sep + path;
  }

  return host + path;
}

},{"path":"../node_modules/path-browserify/index.js"}],"../node_modules/bindings/bindings.js":[function(require,module,exports) {
var process = require("process");
var __filename = "C:\\code\\eanders-ms\\altjac\\node_modules\\bindings\\bindings.js";
/**
 * Module dependencies.
 */
var fs = require('fs'),
    path = require('path'),
    fileURLToPath = require('file-uri-to-path'),
    join = path.join,
    dirname = path.dirname,
    exists = fs.accessSync && function (path) {
  try {
    fs.accessSync(path);
  } catch (e) {
    return false;
  }

  return true;
} || fs.existsSync || path.existsSync,
    defaults = {
  arrow: undefined || ' → ',
  compiled: undefined || 'compiled',
  platform: process.platform,
  arch: process.arch,
  nodePreGyp: 'node-v' + process.versions.modules + '-' + process.platform + '-' + process.arch,
  version: process.versions.node,
  bindings: 'bindings.node',
  try: [// node-gyp's linked version in the "build" dir
  ['module_root', 'build', 'bindings'], // node-waf and gyp_addon (a.k.a node-gyp)
  ['module_root', 'build', 'Debug', 'bindings'], ['module_root', 'build', 'Release', 'bindings'], // Debug files, for development (legacy behavior, remove for node v0.9)
  ['module_root', 'out', 'Debug', 'bindings'], ['module_root', 'Debug', 'bindings'], // Release files, but manually compiled (legacy behavior, remove for node v0.9)
  ['module_root', 'out', 'Release', 'bindings'], ['module_root', 'Release', 'bindings'], // Legacy from node-waf, node <= 0.4.x
  ['module_root', 'build', 'default', 'bindings'], // Production "Release" buildtype binary (meh...)
  ['module_root', 'compiled', 'version', 'platform', 'arch', 'bindings'], // node-qbs builds
  ['module_root', 'addon-build', 'release', 'install-root', 'bindings'], ['module_root', 'addon-build', 'debug', 'install-root', 'bindings'], ['module_root', 'addon-build', 'default', 'install-root', 'bindings'], // node-pre-gyp path ./lib/binding/{node_abi}-{platform}-{arch}
  ['module_root', 'lib', 'binding', 'nodePreGyp', 'bindings']]
};
/**
 * The main `bindings()` function loads the compiled bindings for a given module.
 * It uses V8's Error API to determine the parent filename that this function is
 * being invoked from, which is then used to find the root directory.
 */


function bindings(opts) {
  // Argument surgery
  if (typeof opts == 'string') {
    opts = {
      bindings: opts
    };
  } else if (!opts) {
    opts = {};
  } // maps `defaults` onto `opts` object


  Object.keys(defaults).map(function (i) {
    if (!(i in opts)) opts[i] = defaults[i];
  }); // Get the module root

  if (!opts.module_root) {
    opts.module_root = exports.getRoot(exports.getFileName());
  } // Ensure the given bindings name ends with .node


  if (path.extname(opts.bindings) != '.node') {
    opts.bindings += '.node';
  } // https://github.com/webpack/webpack/issues/4175#issuecomment-342931035


  var requireFunc = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require;
  var tries = [],
      i = 0,
      l = opts.try.length,
      n,
      b,
      err;

  for (; i < l; i++) {
    n = join.apply(null, opts.try[i].map(function (p) {
      return opts[p] || p;
    }));
    tries.push(n);

    try {
      b = opts.path ? requireFunc.resolve(n) : requireFunc(n);

      if (!opts.path) {
        b.path = n;
      }

      return b;
    } catch (e) {
      if (e.code !== 'MODULE_NOT_FOUND' && e.code !== 'QUALIFIED_PATH_RESOLUTION_FAILED' && !/not find/i.test(e.message)) {
        throw e;
      }
    }
  }

  err = new Error('Could not locate the bindings file. Tried:\n' + tries.map(function (a) {
    return opts.arrow + a;
  }).join('\n'));
  err.tries = tries;
  throw err;
}

module.exports = exports = bindings;
/**
 * Gets the filename of the JavaScript file that invokes this function.
 * Used to help find the root directory of a module.
 * Optionally accepts an filename argument to skip when searching for the invoking filename
 */

exports.getFileName = function getFileName(calling_file) {
  var origPST = Error.prepareStackTrace,
      origSTL = Error.stackTraceLimit,
      dummy = {},
      fileName;
  Error.stackTraceLimit = 10;

  Error.prepareStackTrace = function (e, st) {
    for (var i = 0, l = st.length; i < l; i++) {
      fileName = st[i].getFileName();

      if (fileName !== __filename) {
        if (calling_file) {
          if (fileName !== calling_file) {
            return;
          }
        } else {
          return;
        }
      }
    }
  }; // run the 'prepareStackTrace' function above


  Error.captureStackTrace(dummy);
  dummy.stack; // cleanup

  Error.prepareStackTrace = origPST;
  Error.stackTraceLimit = origSTL; // handle filename that starts with "file://"

  var fileSchema = 'file://';

  if (fileName.indexOf(fileSchema) === 0) {
    fileName = fileURLToPath(fileName);
  }

  return fileName;
};
/**
 * Gets the root directory of a module, given an arbitrary filename
 * somewhere in the module tree. The "root directory" is the directory
 * containing the `package.json` file.
 *
 *   In:  /home/nate/node-native-module/lib/index.js
 *   Out: /home/nate/node-native-module
 */


exports.getRoot = function getRoot(file) {
  var dir = dirname(file),
      prev;

  while (true) {
    if (dir === '.') {
      // Avoids an infinite loop in rare cases, like the REPL
      dir = process.cwd();
    }

    if (exists(join(dir, 'package.json')) || exists(join(dir, 'node_modules'))) {
      // Found the 'package.json' file or 'node_modules' dir; we're done
      return dir;
    }

    if (prev === dir) {
      // Got to the top
      throw new Error('Could not find module root given file: "' + file + '". Do you have a `package.json` file? ');
    } // Try the parent dir next


    prev = dir;
    dir = join(dir, '..');
  }
};
},{"fs":"../node_modules/parcel-bundler/src/builtins/_empty.js","path":"../node_modules/path-browserify/index.js","file-uri-to-path":"../node_modules/file-uri-to-path/index.js","process":"../node_modules/process/browser.js"}],"../node_modules/events/events.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;

if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}

module.exports = EventEmitter;
module.exports.once = once; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function () {
    return defaultMaxListeners;
  },
  set: function (arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }

    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.


EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }

  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];

  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);

  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

  if (doError) {
    var er;
    if (args.length > 0) er = args[0];

    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    } // At least give some kind of context to the user


    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];
  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  checkListener(listener);
  events = target._events;

  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object

      events = target._events;
    }

    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    } // Check for listener leak


    m = _getMaxListeners(target);

    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true; // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax

      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}; // Emits a 'removeListener' event if and only if the listener was removed.


EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  checkListener(listener);
  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this; // not listening for removeListener, no need to emit

  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }

    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;

    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;

function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);

  for (var i = 0; i < n; ++i) copy[i] = arr[i];

  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];

  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);

  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }

  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }

      resolve([].slice.call(arguments));
    }

    ;
    eventTargetAgnosticAddListener(emitter, name, resolver, {
      once: true
    });

    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, {
        once: true
      });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }

      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
},{}],"../node_modules/util/support/isBufferBrowser.js":[function(require,module,exports) {
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],"../node_modules/util/node_modules/inherits/inherits_browser.js":[function(require,module,exports) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],"../node_modules/util/util.js":[function(require,module,exports) {
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
  var keys = Object.keys(obj);
  var descriptors = {};

  for (var i = 0; i < keys.length; i++) {
    descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
  }

  return descriptors;
};

var formatRegExp = /%[sdj%]/g;

exports.format = function (f) {
  if (!isString(f)) {
    var objects = [];

    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }

    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function (x) {
    if (x === '%%') return '%';
    if (i >= len) return x;

    switch (x) {
      case '%s':
        return String(args[i++]);

      case '%d':
        return Number(args[i++]);

      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }

      default:
        return x;
    }
  });

  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }

  return str;
}; // Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.


exports.deprecate = function (fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  } // Allow for deprecating things in the process of starting up.


  if (typeof process === 'undefined') {
    return function () {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;

  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }

      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
};

var debugs = {};
var debugEnviron;

exports.debuglog = function (set) {
  if (isUndefined(debugEnviron)) debugEnviron = undefined || '';
  set = set.toUpperCase();

  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;

      debugs[set] = function () {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function () {};
    }
  }

  return debugs[set];
};
/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */

/* legacy: obj, showHidden, depth, colors*/


function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  }; // legacy...

  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];

  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  } // set default options


  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}

exports.inspect = inspect; // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics

inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
}; // Don't use 'blue' not visible on cmd.exe

inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};

function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}

function stylizeNoColor(str, styleType) {
  return str;
}

function arrayToHash(array) {
  var hash = {};
  array.forEach(function (val, idx) {
    hash[val] = true;
  });
  return hash;
}

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
  value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);

    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }

    return ret;
  } // Primitive types cannot have properties


  var primitive = formatPrimitive(ctx, value);

  if (primitive) {
    return primitive;
  } // Look up the keys of the object.


  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  } // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx


  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  } // Some type of object without properties can be shortcutted.


  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }

    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }

    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }

    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '',
      array = false,
      braces = ['{', '}']; // Make Array say that they are Array

  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  } // Make functions say that they are functions


  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  } // Make RegExps say that they are RegExps


  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  } // Make dates with properties first say the date


  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  } // Make error with message first say the error


  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);
  var output;

  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}

function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }

  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is "object", so special case here.

  if (isNull(value)) return ctx.stylize('null', 'null');
}

function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];

  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }

  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key]
  };

  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }

  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }

  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }

      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function (line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }

  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }

    name = JSON.stringify('' + key);

    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}

function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function (prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
} // NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.


function isArray(ar) {
  return Array.isArray(ar);
}

exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}

exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}

exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}

exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}

exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}

exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}

exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}

exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}

exports.isDate = isDate;

function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}

exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}

exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}

exports.isPrimitive = isPrimitive;
exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 26 Feb 16:19:34

function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
} // log is just a thin wrapper to console.log that prepends a timestamp


exports.log = function () {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};
/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */


exports.inherits = require('inherits');

exports._extend = function (origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;
  var keys = Object.keys(add);
  var i = keys.length;

  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }

  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];

    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }

    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });
    var args = [];

    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
};

exports.promisify.custom = kCustomPromisifiedSymbol;

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }

  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  } // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.


  function callbackified() {
    var args = [];

    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();

    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }

    var self = this;

    var cb = function () {
      return maybeCb.apply(self, arguments);
    }; // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)


    original.apply(this, args).then(function (ret) {
      process.nextTick(cb, null, ret);
    }, function (rej) {
      process.nextTick(callbackifyOnRejected, rej, cb);
    });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
  return callbackified;
}

exports.callbackify = callbackify;
},{"./support/isBuffer":"../node_modules/util/support/isBufferBrowser.js","inherits":"../node_modules/util/node_modules/inherits/inherits_browser.js","process":"../node_modules/process/browser.js"}],"../node_modules/base64-js/index.js":[function(require,module,exports) {
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],"../node_modules/ieee754/index.js":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"../node_modules/isarray/index.js":[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"../node_modules/buffer/index.js":[function(require,module,exports) {

var global = arguments[3];
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":"../node_modules/base64-js/index.js","ieee754":"../node_modules/ieee754/index.js","isarray":"../node_modules/isarray/index.js","buffer":"../node_modules/buffer/index.js"}],"../node_modules/usb/usb.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
var process = require("process");
var usb = exports = module.exports = require('bindings')('usb_bindings');

var events = require('events');

var util = require('util');

var isBuffer = function (obj) {
  return obj && obj instanceof Uint8Array;
};

if (usb.INIT_ERROR) {
  console.warn("Failed to initialize libusb.");

  usb.Device = function () {
    throw new Error("Device cannot be instantiated directly.");
  };

  usb.Transfer = function () {
    throw new Error("Transfer cannot be instantiated directly.");
  };

  usb.setDebugLevel = function () {};

  usb.getDeviceList = function () {
    return [];
  };

  usb._enableHotplugEvents = function () {};

  usb._disableHotplugEvents = function () {};
}

Object.keys(events.EventEmitter.prototype).forEach(function (key) {
  exports[key] = events.EventEmitter.prototype[key];
}); // convenience method for finding a device by vendor and product id

exports.findByIds = function (vid, pid) {
  var devices = usb.getDeviceList();

  for (var i = 0; i < devices.length; i++) {
    var deviceDesc = devices[i].deviceDescriptor;

    if (deviceDesc.idVendor == vid && deviceDesc.idProduct == pid) {
      return devices[i];
    }
  }
};

usb.Device.prototype.timeout = 1000;

usb.Device.prototype.open = function (defaultConfig) {
  this.__open();

  if (defaultConfig === false) return;
  this.interfaces = [];
  var len = this.configDescriptor ? this.configDescriptor.interfaces.length : 0;

  for (var i = 0; i < len; i++) {
    this.interfaces[i] = new Interface(this, i);
  }
};

usb.Device.prototype.close = function () {
  this.__close();

  this.interfaces = null;
};

Object.defineProperty(usb.Device.prototype, "configDescriptor", {
  get: function () {
    try {
      return this._configDescriptor || (this._configDescriptor = this.__getConfigDescriptor());
    } catch (e) {
      // Check descriptor exists
      if (e.errno == usb.LIBUSB_ERROR_NOT_FOUND) return null;
      throw e;
    }
  }
});
Object.defineProperty(usb.Device.prototype, "allConfigDescriptors", {
  get: function () {
    try {
      return this._allConfigDescriptors || (this._allConfigDescriptors = this.__getAllConfigDescriptors());
    } catch (e) {
      // Check descriptors exist
      if (e.errno == usb.LIBUSB_ERROR_NOT_FOUND) return [];
      throw e;
    }
  }
});
Object.defineProperty(usb.Device.prototype, "parent", {
  get: function () {
    return this._parent || (this._parent = this.__getParent());
  }
});

usb.Device.prototype.interface = function (addr) {
  if (!this.interfaces) {
    throw new Error("Device must be open before searching for interfaces");
  }

  addr = addr || 0;

  for (var i = 0; i < this.interfaces.length; i++) {
    if (this.interfaces[i].interfaceNumber == addr) {
      return this.interfaces[i];
    }
  }
};

var SETUP_SIZE = usb.LIBUSB_CONTROL_SETUP_SIZE;

usb.Device.prototype.controlTransfer = function (bmRequestType, bRequest, wValue, wIndex, data_or_length, callback) {
  var self = this;
  var isIn = !!(bmRequestType & usb.LIBUSB_ENDPOINT_IN);
  var wLength;

  if (isIn) {
    if (!(data_or_length >= 0)) {
      throw new TypeError("Expected size number for IN transfer (based on bmRequestType)");
    }

    wLength = data_or_length;
  } else {
    if (!isBuffer(data_or_length)) {
      throw new TypeError("Expected buffer for OUT transfer (based on bmRequestType)");
    }

    wLength = data_or_length.length;
  } // Buffer for the setup packet
  // http://libusbx.sourceforge.net/api-1.0/structlibusb__control__setup.html


  var buf = Buffer.alloc(wLength + SETUP_SIZE);
  buf.writeUInt8(bmRequestType, 0);
  buf.writeUInt8(bRequest, 1);
  buf.writeUInt16LE(wValue, 2);
  buf.writeUInt16LE(wIndex, 4);
  buf.writeUInt16LE(wLength, 6);

  if (!isIn) {
    buf.set(data_or_length, SETUP_SIZE);
  }

  var transfer = new usb.Transfer(this, 0, usb.LIBUSB_TRANSFER_TYPE_CONTROL, this.timeout, function (error, buf, actual) {
    if (callback) {
      if (isIn) {
        callback.call(self, error, buf.slice(SETUP_SIZE, SETUP_SIZE + actual));
      } else {
        callback.call(self, error);
      }
    }
  });

  try {
    transfer.submit(buf);
  } catch (e) {
    if (callback) {
      process.nextTick(function () {
        callback.call(self, e);
      });
    }
  }

  return this;
};

usb.Device.prototype.getStringDescriptor = function (desc_index, callback) {
  var langid = 0x0409;
  var length = 255;
  this.controlTransfer(usb.LIBUSB_ENDPOINT_IN, usb.LIBUSB_REQUEST_GET_DESCRIPTOR, usb.LIBUSB_DT_STRING << 8 | desc_index, langid, length, function (error, buf) {
    if (error) return callback(error);
    callback(undefined, buf.toString('utf16le', 2));
  });
};

usb.Device.prototype.getBosDescriptor = function (callback) {
  if (this._bosDescriptor) {
    // Cached descriptor
    return callback(undefined, this._bosDescriptor);
  }

  if (this.deviceDescriptor.bcdUSB < 0x201) {
    // BOS is only supported from USB 2.0.1
    return callback(undefined, null);
  }

  this.controlTransfer(usb.LIBUSB_ENDPOINT_IN, usb.LIBUSB_REQUEST_GET_DESCRIPTOR, usb.LIBUSB_DT_BOS << 8, 0, usb.LIBUSB_DT_BOS_SIZE, function (error, buffer) {
    if (error) {
      // Check BOS descriptor exists
      if (error.errno == usb.LIBUSB_TRANSFER_STALL) return callback(undefined, null);
      return callback(error, null);
    }

    var totalLength = buffer.readUInt16LE(2);
    this.controlTransfer(usb.LIBUSB_ENDPOINT_IN, usb.LIBUSB_REQUEST_GET_DESCRIPTOR, usb.LIBUSB_DT_BOS << 8, 0, totalLength, function (error, buffer) {
      if (error) {
        // Check BOS descriptor exists
        if (error.errno == usb.LIBUSB_TRANSFER_STALL) return callback(undefined, null);
        return callback(error, null);
      }

      var descriptor = {
        bLength: buffer.readUInt8(0),
        bDescriptorType: buffer.readUInt8(1),
        wTotalLength: buffer.readUInt16LE(2),
        bNumDeviceCaps: buffer.readUInt8(4),
        capabilities: []
      };
      var i = usb.LIBUSB_DT_BOS_SIZE;

      while (i < descriptor.wTotalLength) {
        var capability = {
          bLength: buffer.readUInt8(i + 0),
          bDescriptorType: buffer.readUInt8(i + 1),
          bDevCapabilityType: buffer.readUInt8(i + 2)
        };
        capability.dev_capability_data = buffer.slice(i + 3, i + capability.bLength);
        descriptor.capabilities.push(capability);
        i += capability.bLength;
      } // Cache descriptor


      this._bosDescriptor = descriptor;
      callback(undefined, this._bosDescriptor);
    });
  });
};

usb.Device.prototype.getCapabilities = function (callback) {
  var capabilities = [];
  var self = this;
  this.getBosDescriptor(function (error, descriptor) {
    if (error) return callback(error, null);
    var len = descriptor ? descriptor.capabilities.length : 0;

    for (var i = 0; i < len; i++) {
      capabilities.push(new Capability(self, i));
    }

    callback(undefined, capabilities);
  });
};

usb.Device.prototype.setConfiguration = function (desired, cb) {
  var self = this;

  this.__setConfiguration(desired, function (err) {
    if (!err) {
      this.interfaces = [];
      var len = this.configDescriptor ? this.configDescriptor.interfaces.length : 0;

      for (var i = 0; i < len; i++) {
        this.interfaces[i] = new Interface(this, i);
      }
    }

    cb.call(self, err);
  });
};

function Interface(device, id) {
  this.device = device;
  this.id = id;
  this.altSetting = 0;

  this.__refresh();
}

Interface.prototype.__refresh = function () {
  this.descriptor = this.device.configDescriptor.interfaces[this.id][this.altSetting];
  this.interfaceNumber = this.descriptor.bInterfaceNumber;
  this.endpoints = [];
  var len = this.descriptor.endpoints.length;

  for (var i = 0; i < len; i++) {
    var desc = this.descriptor.endpoints[i];
    var c = desc.bEndpointAddress & usb.LIBUSB_ENDPOINT_IN ? InEndpoint : OutEndpoint;
    this.endpoints[i] = new c(this.device, desc);
  }
};

Interface.prototype.claim = function () {
  this.device.__claimInterface(this.id);
};

Interface.prototype.release = function (closeEndpoints, cb) {
  var self = this;

  if (typeof closeEndpoints == 'function') {
    cb = closeEndpoints;
    closeEndpoints = null;
  }

  if (!closeEndpoints || this.endpoints.length == 0) {
    next();
  } else {
    var n = self.endpoints.length;
    self.endpoints.forEach(function (ep, i) {
      if (ep.pollActive) {
        ep.once('end', function () {
          if (--n == 0) next();
        });
        ep.stopPoll();
      } else {
        if (--n == 0) next();
      }
    });
  }

  function next() {
    self.device.__releaseInterface(self.id, function (err) {
      if (!err) {
        self.altSetting = 0;

        self.__refresh();
      }

      cb.call(self, err);
    });
  }
};

Interface.prototype.isKernelDriverActive = function () {
  return this.device.__isKernelDriverActive(this.id);
};

Interface.prototype.detachKernelDriver = function () {
  return this.device.__detachKernelDriver(this.id);
};

Interface.prototype.attachKernelDriver = function () {
  return this.device.__attachKernelDriver(this.id);
};

Interface.prototype.setAltSetting = function (altSetting, cb) {
  var self = this;

  this.device.__setInterface(this.id, altSetting, function (err) {
    if (!err) {
      self.altSetting = altSetting;

      self.__refresh();
    }

    cb.call(self, err);
  });
};

Interface.prototype.endpoint = function (addr) {
  for (var i = 0; i < this.endpoints.length; i++) {
    if (this.endpoints[i].address == addr) {
      return this.endpoints[i];
    }
  }
};

function Capability(device, id) {
  this.device = device;
  this.id = id;
  this.descriptor = this.device._bosDescriptor.capabilities[this.id];
  this.type = this.descriptor.bDevCapabilityType;
  this.data = this.descriptor.dev_capability_data;
}

function Endpoint(device, descriptor) {
  this.device = device;
  this.descriptor = descriptor;
  this.address = descriptor.bEndpointAddress;
  this.transferType = descriptor.bmAttributes & 0x03;
}

util.inherits(Endpoint, events.EventEmitter);
Endpoint.prototype.timeout = 0;

Endpoint.prototype.clearHalt = function (callback) {
  return this.device.__clearHalt(this.address, callback);
};

Endpoint.prototype.makeTransfer = function (timeout, callback) {
  return new usb.Transfer(this.device, this.address, this.transferType, timeout, callback);
};

Endpoint.prototype.startPoll = function (nTransfers, transferSize, callback) {
  if (this.pollTransfers) {
    throw new Error("Polling already active");
  }

  nTransfers = nTransfers || 3;
  this.pollTransferSize = transferSize || this.descriptor.wMaxPacketSize;
  this.pollActive = true;
  this.pollPending = 0;
  var transfers = [];

  for (var i = 0; i < nTransfers; i++) {
    transfers[i] = this.makeTransfer(0, callback);
  }

  return transfers;
};

Endpoint.prototype.stopPoll = function (cb) {
  if (!this.pollTransfers) {
    throw new Error('Polling is not active.');
  }

  for (var i = 0; i < this.pollTransfers.length; i++) {
    try {
      this.pollTransfers[i].cancel();
    } catch (err) {
      this.emit('error', err);
    }
  }

  this.pollActive = false;
  if (cb) this.once('end', cb);
};

function InEndpoint(device, descriptor) {
  Endpoint.call(this, device, descriptor);
}

exports.InEndpoint = InEndpoint;
util.inherits(InEndpoint, Endpoint);
InEndpoint.prototype.direction = "in";

InEndpoint.prototype.transfer = function (length, cb) {
  var self = this;
  var buffer = Buffer.alloc(length);

  function callback(error, buf, actual) {
    cb.call(self, error, buffer.slice(0, actual));
  }

  try {
    this.makeTransfer(this.timeout, callback).submit(buffer);
  } catch (e) {
    process.nextTick(function () {
      cb.call(self, e);
    });
  }

  return this;
};

InEndpoint.prototype.startPoll = function (nTransfers, transferSize) {
  var self = this;
  this.pollTransfers = InEndpoint.super_.prototype.startPoll.call(this, nTransfers, transferSize, transferDone);

  function transferDone(error, buf, actual) {
    if (!error) {
      self.emit("data", buf.slice(0, actual));
    } else if (error.errno != usb.LIBUSB_TRANSFER_CANCELLED) {
      self.emit("error", error);
      self.stopPoll();
    }

    if (self.pollActive) {
      startTransfer(this);
    } else {
      self.pollPending--;

      if (self.pollPending == 0) {
        delete self.pollTransfers;
        self.emit('end');
      }
    }
  }

  function startTransfer(t) {
    try {
      t.submit(Buffer.alloc(self.pollTransferSize), transferDone);
    } catch (e) {
      self.emit("error", e);
      self.stopPoll();
    }
  }

  this.pollTransfers.forEach(startTransfer);
  self.pollPending = this.pollTransfers.length;
};

function OutEndpoint(device, descriptor) {
  Endpoint.call(this, device, descriptor);
}

exports.OutEndpoint = OutEndpoint;
util.inherits(OutEndpoint, Endpoint);
OutEndpoint.prototype.direction = "out";

OutEndpoint.prototype.transfer = function (buffer, cb) {
  var self = this;

  if (!buffer) {
    buffer = Buffer.alloc(0);
  } else if (!isBuffer(buffer)) {
    buffer = Buffer.from(buffer);
  }

  function callback(error, buf, actual) {
    if (cb) cb.call(self, error);
  }

  try {
    this.makeTransfer(this.timeout, callback).submit(buffer);
  } catch (e) {
    process.nextTick(function () {
      callback(e);
    });
  }

  return this;
};

OutEndpoint.prototype.transferWithZLP = function (buf, cb) {
  if (buf.length % this.descriptor.wMaxPacketSize == 0) {
    this.transfer(buf);
    this.transfer(Buffer.alloc(0), cb);
  } else {
    this.transfer(buf, cb);
  }
};

var hotplugListeners = 0;
exports.on('newListener', function (name) {
  if (name !== 'attach' && name !== 'detach') return;

  if (++hotplugListeners === 1) {
    usb._enableHotplugEvents();
  }
});
exports.on('removeListener', function (name) {
  if (name !== 'attach' && name !== 'detach') return;

  if (--hotplugListeners === 0) {
    usb._disableHotplugEvents();
  }
});
},{"bindings":"../node_modules/bindings/bindings.js","events":"../node_modules/events/events.js","util":"../node_modules/util/util.js","buffer":"../node_modules/buffer/index.js","process":"../node_modules/process/browser.js"}],"../node_modules/webusb/dist/webusb.esm.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.usb = exports.adapter = exports.USBAdapter = exports.USB = void 0;

var _usb = require("usb");

function m() {}

function E() {
  E.init.call(this);
}

function g(e) {
  return void 0 === e._maxListeners ? E.defaultMaxListeners : e._maxListeners;
}

function b(e, t, r) {
  if (t) e.call(r);else for (var n = e.length, i = N(e, n), s = 0; s < n; ++s) i[s].call(r);
}

function w(e, t, r, n) {
  if (t) e.call(r, n);else for (var i = e.length, s = N(e, i), o = 0; o < i; ++o) s[o].call(r, n);
}

function _(e, t, r, n, i) {
  if (t) e.call(r, n, i);else for (var s = e.length, o = N(e, s), c = 0; c < s; ++c) o[c].call(r, n, i);
}

function I(e, t, r, n, i, s) {
  if (t) e.call(r, n, i, s);else for (var o = e.length, c = N(e, o), a = 0; a < o; ++a) c[a].call(r, n, i, s);
}

function D(e, t, r, n) {
  if (t) e.apply(r, n);else for (var i = e.length, s = N(e, i), o = 0; o < i; ++o) s[o].apply(r, n);
}

function T(e, t, r, n) {
  var i, s, o, c;
  if ("function" != typeof r) throw new TypeError('"listener" argument must be a function');

  if ((s = e._events) ? (s.newListener && (e.emit("newListener", t, r.listener ? r.listener : r), s = e._events), o = s[t]) : (s = e._events = new m(), e._eventsCount = 0), o) {
    if ("function" == typeof o ? o = s[t] = n ? [r, o] : [o, r] : n ? o.unshift(r) : o.push(r), !o.warned && (i = g(e)) && i > 0 && o.length > i) {
      o.warned = !0;
      var a = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + t + " listeners added. Use emitter.setMaxListeners() to increase limit");
      a.name = "MaxListenersExceededWarning", a.emitter = e, a.type = t, a.count = o.length, c = a, "function" == typeof console.warn ? console.warn(c) : console.log(c);
    }
  } else o = s[t] = r, ++e._eventsCount;

  return e;
}

function C(e, t, r) {
  var n = !1;

  function i() {
    e.removeListener(t, i), n || (n = !0, r.apply(e, arguments));
  }

  return i.listener = r, i;
}

function S(e) {
  var t = this._events;

  if (t) {
    var r = t[e];
    if ("function" == typeof r) return 1;
    if (r) return r.length;
  }

  return 0;
}

function N(e, t) {
  for (var r = new Array(t); t--;) r[t] = e[t];

  return r;
}

m.prototype = Object.create(null), E.EventEmitter = E, E.usingDomains = !1, E.prototype.domain = void 0, E.prototype._events = void 0, E.prototype._maxListeners = void 0, E.defaultMaxListeners = 10, E.init = function () {
  this.domain = null, E.usingDomains && (void 0).active && (void 0).Domain, this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = new m(), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, E.prototype.setMaxListeners = function (e) {
  if ("number" != typeof e || e < 0 || isNaN(e)) throw new TypeError('"n" argument must be a positive number');
  return this._maxListeners = e, this;
}, E.prototype.getMaxListeners = function () {
  return g(this);
}, E.prototype.emit = function (e) {
  var t,
      r,
      n,
      i,
      s,
      o,
      c,
      a = "error" === e;
  if (o = this._events) a = a && null == o.error;else if (!a) return !1;

  if (c = this.domain, a) {
    if (t = arguments[1], !c) {
      if (t instanceof Error) throw t;
      var u = new Error('Uncaught, unspecified "error" event. (' + t + ")");
      throw u.context = t, u;
    }

    return t || (t = new Error('Uncaught, unspecified "error" event')), t.domainEmitter = this, t.domain = c, t.domainThrown = !1, c.emit("error", t), !1;
  }

  if (!(r = o[e])) return !1;
  var l = "function" == typeof r;

  switch (n = arguments.length) {
    case 1:
      b(r, l, this);
      break;

    case 2:
      w(r, l, this, arguments[1]);
      break;

    case 3:
      _(r, l, this, arguments[1], arguments[2]);

      break;

    case 4:
      I(r, l, this, arguments[1], arguments[2], arguments[3]);
      break;

    default:
      for (i = new Array(n - 1), s = 1; s < n; s++) i[s - 1] = arguments[s];

      D(r, l, this, i);
  }

  return !0;
}, E.prototype.addListener = function (e, t) {
  return T(this, e, t, !1);
}, E.prototype.on = E.prototype.addListener, E.prototype.prependListener = function (e, t) {
  return T(this, e, t, !0);
}, E.prototype.once = function (e, t) {
  if ("function" != typeof t) throw new TypeError('"listener" argument must be a function');
  return this.on(e, C(this, e, t)), this;
}, E.prototype.prependOnceListener = function (e, t) {
  if ("function" != typeof t) throw new TypeError('"listener" argument must be a function');
  return this.prependListener(e, C(this, e, t)), this;
}, E.prototype.removeListener = function (e, t) {
  var r, n, i, s, o;
  if ("function" != typeof t) throw new TypeError('"listener" argument must be a function');
  if (!(n = this._events)) return this;
  if (!(r = n[e])) return this;
  if (r === t || r.listener && r.listener === t) 0 == --this._eventsCount ? this._events = new m() : (delete n[e], n.removeListener && this.emit("removeListener", e, r.listener || t));else if ("function" != typeof r) {
    for (i = -1, s = r.length; s-- > 0;) if (r[s] === t || r[s].listener && r[s].listener === t) {
      o = r[s].listener, i = s;
      break;
    }

    if (i < 0) return this;

    if (1 === r.length) {
      if (r[0] = void 0, 0 == --this._eventsCount) return this._events = new m(), this;
      delete n[e];
    } else !function (e, t) {
      for (var r = t, n = r + 1, i = e.length; n < i; r += 1, n += 1) e[r] = e[n];

      e.pop();
    }(r, i);

    n.removeListener && this.emit("removeListener", e, o || t);
  }
  return this;
}, E.prototype.removeAllListeners = function (e) {
  var t, r;
  if (!(r = this._events)) return this;
  if (!r.removeListener) return 0 === arguments.length ? (this._events = new m(), this._eventsCount = 0) : r[e] && (0 == --this._eventsCount ? this._events = new m() : delete r[e]), this;

  if (0 === arguments.length) {
    for (var n, i = Object.keys(r), s = 0; s < i.length; ++s) "removeListener" !== (n = i[s]) && this.removeAllListeners(n);

    return this.removeAllListeners("removeListener"), this._events = new m(), this._eventsCount = 0, this;
  }

  if ("function" == typeof (t = r[e])) this.removeListener(e, t);else if (t) do {
    this.removeListener(e, t[t.length - 1]);
  } while (t[0]);
  return this;
}, E.prototype.listeners = function (e) {
  var t,
      r = this._events;
  return r && (t = r[e]) ? "function" == typeof t ? [t.listener || t] : function (e) {
    for (var t = new Array(e.length), r = 0; r < t.length; ++r) t[r] = e[r].listener || e[r];

    return t;
  }(t) : [];
}, E.listenerCount = function (e, t) {
  return "function" == typeof e.listenerCount ? e.listenerCount(t) : S.call(e, t);
}, E.prototype.listenerCount = S, E.prototype.eventNames = function () {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

class y extends E {
  constructor() {
    super(...arguments), this.isEventListenerObject = e => void 0 !== e.handleEvent;
  }

  addEventListener(e, t) {
    if (t) {
      const r = this.isEventListenerObject(t) ? t.handleEvent : t;
      super.addListener(e, r);
    }
  }

  removeEventListener(e, t) {
    if (t) {
      const r = this.isEventListenerObject(t) ? t.handleEvent : t;
      super.removeListener(e, r);
    }
  }

  dispatchEvent(e) {
    return super.emit(e.type, e);
  }

}

class P {
  constructor(e) {
    this.configurationValue = null, this.configurationName = null, this.interfaces = [], this.configurationValue = e.configurationValue, this.configurationName = e.configurationName, this.interfaces = e.interfaces;
  }

}

class L {
  constructor(e) {
    this.interfaceNumber = null, this.alternates = [], this._claimed = !1, this._currentAlternate = 0, this._handle = null, this.interfaceNumber = e.interfaceNumber, this.alternates = e.alternates, this._handle = e._handle;
  }

  get claimed() {
    return this._claimed;
  }

  get alternate() {
    return this.alternates.find(e => e.alternateSetting === this._currentAlternate);
  }

  selectAlternateInterface(e) {
    return k.selectAlternateInterface(this._handle, this.interfaceNumber, e).then(() => {
      this._currentAlternate = e;
    });
  }

  claimInterface() {
    return k.claimInterface(this._handle, this.interfaceNumber).then(() => {
      this._claimed = !0;
    });
  }

  releaseInterface() {
    return k.releaseInterface(this._handle, this.interfaceNumber).then(() => {
      this._claimed = !1;
    });
  }

  reset() {
    this._currentAlternate = 0;
  }

}

class V {
  constructor(e) {
    this.alternateSetting = null, this.interfaceClass = null, this.interfaceSubclass = null, this.interfaceProtocol = null, this.interfaceName = null, this.endpoints = [], this.alternateSetting = e.alternateSetting, this.interfaceClass = e.interfaceClass, this.interfaceSubclass = e.interfaceSubclass, this.interfaceProtocol = e.interfaceProtocol, this.interfaceName = e.interfaceName, this.endpoints = e.endpoints;
  }

}

class O {
  constructor(e) {
    this.endpointNumber = null, this.direction = null, this.type = null, this.packetSize = null, this.endpointNumber = e.endpointNumber, this.direction = e.direction, this.type = e.type, this.packetSize = e.packetSize;
  }

}

class U {
  constructor(e) {
    this.manufacturerName = null, this.productName = null, this.serialNumber = null, this._configurations = [], this._currentConfiguration = null, this.url = null, this._maxPacketSize = 0, this._handle = null, this.usbVersionMajor = e.usbVersionMajor, this.usbVersionMinor = e.usbVersionMinor, this.usbVersionSubminor = e.usbVersionSubminor, this.deviceClass = e.deviceClass, this.deviceSubclass = e.deviceSubclass, this.deviceProtocol = e.deviceProtocol, this.vendorId = e.vendorId, this.productId = e.productId, this.deviceVersionMajor = e.deviceVersionMajor, this.deviceVersionMinor = e.deviceVersionMinor, this.deviceVersionSubminor = e.deviceVersionSubminor, this.manufacturerName = e.manufacturerName, this.productName = e.productName, this.serialNumber = e.serialNumber, this._configurations = e.configurations, this.url = e.url, this._maxPacketSize = e._maxPacketSize, this._handle = e._handle, this._currentConfiguration = e._currentConfiguration;
  }

  get configurations() {
    return this._configurations;
  }

  get configuration() {
    return this.configurations.find(e => e.configurationValue === this._currentConfiguration);
  }

  get connected() {
    return k.getConnected(this._handle);
  }

  get opened() {
    return k.getOpened(this._handle);
  }

  getEndpoint(e, t) {
    let r = null,
        n = null;
    return this.configuration.interfaces.some(i => (r = i.alternate.endpoints.find(r => r.endpointNumber === t && r.direction === e), r && (n = i), r)), {
      endpoint: r,
      iface: n
    };
  }

  setupInvalid(t) {
    if ("interface" === t.recipient) {
      const e = 255 & t.index,
            r = this.configuration.interfaces.find(t => t.interfaceNumber === e);
      if (!r) return "interface not found";
      if (!r.claimed) return "invalid state";
    } else if ("endpoint" === t.recipient) {
      const r = 15 & t.index,
            n = t.index & _usb.LIBUSB_ENDPOINT_IN ? "in" : "out",
            i = this.getEndpoint(n, r);
      if (!i.endpoint) return "endpoint not found";
      if (!i.iface.claimed) return "invalid state";
    }
  }

  open() {
    return new Promise((e, t) => this.connected ? this.opened ? e() : void k.open(this._handle).then(e).catch(e => {
      t(new Error(`open error: ${e}`));
    }) : t(new Error("open error: device not found")));
  }

  close() {
    return new Promise((e, t) => {
      if (!this.connected) return t(new Error("close error: device not found"));
      if (!this.opened) return e();
      const r = this.configuration.interfaces.map(e => this.releaseInterface(e.interfaceNumber));
      Promise.all(r).catch(e => {}).then(() => k.close(this._handle)).then(e).catch(e => {
        t(new Error(`close error: ${e}`));
      });
    });
  }

  selectConfiguration(e) {
    return new Promise((t, r) => {
      if (e === this._currentConfiguration) return t();
      if (!this.connected) return r(new Error("selectConfiguration error: device not found"));
      return this.configurations.find(t => t.configurationValue === e) ? this.opened ? void k.selectConfiguration(this._handle, e).then(() => {
        this._currentConfiguration = e, this.configuration.interfaces.forEach(e => e.reset()), t();
      }).catch(e => {
        r(new Error(`selectConfiguration error: ${e}`));
      }) : r(new Error("selectConfiguration error: invalid state")) : r(new Error("selectConfiguration error: configuration not found"));
    });
  }

  claimInterface(e) {
    return new Promise((t, r) => {
      if (!this.connected) return r(new Error("claimInterface error: device not found"));
      const n = this.configuration.interfaces.find(t => t.interfaceNumber === e);
      return n ? this.opened ? n.claimed ? t() : void n.claimInterface().then(t).catch(e => {
        r(new Error(`claimInterface error: ${e}`));
      }) : r(new Error("claimInterface error: invalid state")) : r(new Error("claimInterface error: interface not found"));
    });
  }

  releaseInterface(e) {
    return new Promise((t, r) => {
      if (!this.connected) return r(new Error("releaseInterface error: device not found"));
      const n = this.configuration.interfaces.find(t => t.interfaceNumber === e);
      return n ? this.opened ? n.claimed ? void n.releaseInterface().then(t).catch(e => {
        r(new Error(`releaseInterface error: ${e}`));
      }) : t() : r(new Error("releaseInterface error: invalid state")) : r(new Error("releaseInterface error: interface not found"));
    });
  }

  selectAlternateInterface(e, t) {
    return new Promise((r, n) => {
      if (!this.connected) return n(new Error("selectAlternateInterface error: device not found"));
      const i = this.configuration.interfaces.find(t => t.interfaceNumber === e);
      return i ? this.opened && i.claimed ? void i.selectAlternateInterface(t).then(r).catch(e => {
        n(new Error(`selectAlternateInterface error: ${e}`));
      }) : n(new Error("selectAlternateInterface error: invalid state")) : n(new Error("selectAlternateInterface error: interface not found"));
    });
  }

  controlTransferIn(e, t) {
    return new Promise((r, n) => {
      if (!this.connected) return n(new Error("controlTransferIn error: device not found"));
      if (!this.opened) return n(new Error("controlTransferIn error: invalid state"));
      const i = this.setupInvalid(e);
      if (i) return n(new Error(`controlTransferIn error: ${i}`));
      k.controlTransferIn(this._handle, e, t).then(r).catch(e => {
        n(new Error(`controlTransferIn error: ${e}`));
      });
    });
  }

  controlTransferOut(e, t) {
    return new Promise((r, n) => {
      if (!this.connected) return n(new Error("controlTransferOut error: device not found"));
      if (!this.opened) return n(new Error("controlTransferOut error: invalid state"));
      const i = this.setupInvalid(e);
      if (i) return n(new Error(`controlTransferOut error: ${i}`));
      k.controlTransferOut(this._handle, e, t).then(r).catch(e => {
        n(new Error(`controlTransferOut error: ${e}`));
      });
    });
  }

  clearHalt(e, t) {
    return new Promise((r, n) => {
      if (!this.connected) return n(new Error("clearHalt error: device not found"));
      const i = this.getEndpoint(e, t);
      return i.endpoint ? this.opened && i.iface.claimed ? void k.clearHalt(this._handle, e, t).then(r).catch(e => {
        n(new Error(`clearHalt error: ${e}`));
      }) : n(new Error("clearHalt error: invalid state")) : n(new Error("clearHalt error: endpoint not found"));
    });
  }

  transferIn(e, t) {
    return new Promise((r, n) => {
      if (!this.connected) return n(new Error("transferIn error: device not found"));
      const i = this.getEndpoint("in", e);
      return i.endpoint ? "interrupt" !== i.endpoint.type && "bulk" !== i.endpoint.type ? n(new Error("transferIn error: invalid access")) : this.opened && i.iface.claimed ? void k.transferIn(this._handle, e, t).then(r).catch(e => {
        n(new Error(`transferIn error: ${e}`));
      }) : n(new Error("transferIn error: invalid state")) : n(new Error("transferIn error: endpoint not found"));
    });
  }

  transferOut(e, t) {
    return new Promise((r, n) => {
      if (!this.connected) return n(new Error("transferOut error: device not found"));
      const i = this.getEndpoint("out", e);
      return i.endpoint ? "interrupt" !== i.endpoint.type && "bulk" !== i.endpoint.type ? n(new Error("transferOut error: invalid access")) : this.opened && i.iface.claimed ? void k.transferOut(this._handle, e, t).then(r).catch(e => {
        n(new Error(`transferOut error: ${e}`));
      }) : n(new Error("transferOut error: invalid state")) : n(new Error("transferOut error: endpoint not found"));
    });
  }

  isochronousTransferIn(e, t) {
    return new Promise((r, n) => {
      if (!this.connected) return n(new Error("isochronousTransferIn error: device not found"));
      const i = this.getEndpoint("in", e);
      return i.endpoint ? "isochronous" !== i.endpoint.type ? n(new Error("isochronousTransferIn error: invalid access")) : this.opened && i.iface.claimed ? void k.isochronousTransferIn(this._handle, e, t).then(r).catch(e => {
        n(new Error(`isochronousTransferIn error: ${e}`));
      }) : n(new Error("isochronousTransferIn error: invalid state")) : n(new Error("isochronousTransferIn error: endpoint not found"));
    });
  }

  isochronousTransferOut(e, t, r) {
    return new Promise((n, i) => {
      if (!this.connected) return i(new Error("isochronousTransferOut error: device not found"));
      const s = this.getEndpoint("out", e);
      return s.endpoint ? "isochronous" !== s.endpoint.type ? i(new Error("isochronousTransferOut error: invalid access")) : this.opened && s.iface.claimed ? void k.isochronousTransferOut(this._handle, e, t, r).then(n).catch(e => {
        i(new Error(`isochronousTransferOut error: ${e}`));
      }) : i(new Error("isochronousTransferOut error: invalid state")) : i(new Error("isochronousTransferOut error: endpoint not found"));
    });
  }

  reset() {
    return new Promise((e, t) => this.connected ? this.opened ? void k.reset(this._handle).then(e).catch(e => {
      t(new Error(`reset error: ${e}`));
    }) : t(new Error("reset error: invalid state")) : t(new Error("reset error: device not found")));
  }

}

const A = 200,
      B = 10,
      x = {
  WEB_UUID: "3408b638-09a9-47a0-8bfd-a0768815b665",
  LIBUSB_DT_BOS: 15,
  LIBUSB_DT_BOS_SIZE: 5,
  LIBUSB_TRANSFER_TYPE_MASK: 3,
  USB_VERSION: 513,
  CAPABILITY_VERSION: 256,
  URL_REQUEST_TYPE: 192,
  URL_REQUEST_INDEX: 2,
  CLEAR_FEATURE: 1,
  ENDPOINT_HALT: 0
};

class $ extends E {
  constructor() {
    super(), this.devices = {};

    const e = e => {
      this.loadDevice(e, B).then(e => {
        if (e) {
          const t = this.getDeviceHandle(e);
          this.devicetoUSBDevice(t).then(e => {
            e && this.emit($.EVENT_DEVICE_CONNECT, e);
          });
        }
      });
    },
          n = e => {
      const t = this.getDeviceHandle(e);
      t && this.devices[t] && (delete this.devices[t], this.emit($.EVENT_DEVICE_DISCONNECT, t));
    };

    this.on("newListener", r => {
      0 === this.listenerCount(r) && (r === $.EVENT_DEVICE_CONNECT ? (0, _usb.on)("attach", e) : r === $.EVENT_DEVICE_DISCONNECT && (0, _usb.on)("detach", n));
    }), this.on("removeListener", t => {
      0 === this.listenerCount(t) && (t === $.EVENT_DEVICE_CONNECT ? (0, _usb.removeListener)("attach", e) : t === $.EVENT_DEVICE_DISCONNECT && (0, _usb.removeListener)("detach", n));
    });
  }

  getDeviceHandle(e) {
    return null === e.busNumber || null === e.deviceAddress ? null : `${e.busNumber}.${e.deviceAddress}`;
  }

  serialPromises(e, t) {
    return t.reduce(function (t, r) {
      return t.then(t => e.call(this, r).then(e => (e && t.push(e), t)));
    }.bind(this), Promise.resolve([]));
  }

  serialDevicePromises(e, t, r) {
    return r.reduce(function (r, n) {
      return r.then(r => e.call(this, t, n).then(e => (r.push(e), r)));
    }.bind(this), Promise.resolve([]));
  }

  delay(e = A) {
    return new Promise((t, r) => {
      setTimeout(t, e);
    });
  }

  retryPromise(e, t = 0, r = A) {
    return new Promise((n, i) => {
      e().then(n).catch(s => 0 === t ? i(s) : this.delay(r).then(() => this.retryPromise(e, --t, r)).then(n).catch(e => i(e)));
    });
  }

  loadDevices(e) {
    this.devices = {};
    let t = (0, _usb.getDeviceList)();
    return e && (t = this.preFilterDevices(t, e)), this.serialPromises(this.loadDevice, t);
  }

  preFilterDevices(e, t) {
    return e.filter(e => t.some(t => (!t.vendorId || t.vendorId === e.deviceDescriptor.idVendor) && (!t.productId || t.productId === e.deviceDescriptor.idProduct)));
  }

  loadDevice(e, t = 0) {
    try {
      e.configDescriptor, e.allConfigDescriptors, e.deviceDescriptor;
    } catch (e) {
      return Promise.resolve(null);
    }

    return this.getCapabilities(e, t).then(e => this.getWebCapability(e)).then(t => this.getWebUrl(e, t).then(t => {
      const r = this.getDeviceHandle(e);
      return this.devices[r] = {
        device: e,
        url: t
      }, e;
    }));
  }

  getCapabilities(e, t) {
    return new Promise((r, n) => {
      this.openDevice(e, t).then(() => {
        e.getCapabilities((t, n) => {
          try {
            e.close();
          } catch (e) {}

          if (t) return r([]);
          r(n);
        });
      }).catch(e => {
        r([]);
      });
    });
  }

  getWebCapability(e) {
    return e.filter(e => 5 === e.type).find(e => {
      const t = this.decodeUUID(e.data.slice(1, 17)),
            r = e.data.readUInt16LE(17);
      return t === x.WEB_UUID && r === x.CAPABILITY_VERSION;
    });
  }

  decodeUUID(e) {
    const t = `00000000${e.readUInt32LE(0).toString(16)}`.slice(-8),
          r = `0000${e.readUInt16LE(4).toString(16)}`.slice(-4),
          n = `0000${e.readUInt16LE(6).toString(16)}`.slice(-4),
          i = [];

    for (let t = 8; t < 10; t++) i.push(`00${e.readUInt8(t).toString(16)}`.slice(-2));

    const s = [];

    for (let t = 10; t < 16; t++) s.push(`00${e.readUInt8(t).toString(16)}`.slice(-2));

    return `${t}-${r}-${n}-${i.join("")}-${s.join("")}`;
  }

  getWebUrl(e, t, r = !0) {
    return new Promise((n, i) => {
      if (!t || !t.data || t.data.byteLength < 20) return n(null);
      const s = t.data.readUInt8(19),
            o = t.data.readUInt8(20);
      this.openDevice(e).then(() => {
        e.controlTransfer(x.URL_REQUEST_TYPE, s, o, x.URL_REQUEST_INDEX, 64, (t, s) => {
          if (e.close(), t) return r ? n(null) : i(t);
          let o = s.toString("utf8", 3);
          const c = s.readUInt8(2);
          0 === c && (o = "http://" + o), 1 === c && (o = "https://" + o), n(o);
        });
      }).catch(e => {
        n("");
      });
    });
  }

  devicetoUSBDevice(e) {
    return new Promise((t, r) => {
      const n = this.devices[e].device,
            i = this.devices[e].url;
      let s = null,
          o = null,
          c = null;

      try {
        o = n.configDescriptor, s = n.allConfigDescriptors, c = n.deviceDescriptor;
      } catch (e) {
        return t(null);
      }

      return s ? this.serialDevicePromises(this.configToUSBConfiguration, n, s).then(e => {
        if (!c) return t(new U({
          _handle: this.getDeviceHandle(n),
          url: i,
          configurations: e
        }));
        const r = this.decodeVersion(c.bcdDevice),
              s = this.decodeVersion(c.bcdUSB);
        let a = null,
            u = null;
        return this.getStringDescriptor(n, c.iManufacturer).then(e => (a = e, this.getStringDescriptor(n, c.iProduct))).then(e => (u = e, this.getStringDescriptor(n, c.iSerialNumber))).then(l => {
          const d = {
            _handle: this.getDeviceHandle(n),
            _maxPacketSize: c.bMaxPacketSize0,
            url: i,
            deviceClass: c.bDeviceClass,
            deviceSubclass: c.bDeviceSubClass,
            deviceProtocol: c.bDeviceProtocol,
            productId: c.idProduct,
            vendorId: c.idVendor,
            deviceVersionMajor: r.major,
            deviceVersionMinor: r.minor,
            deviceVersionSubminor: r.sub,
            usbVersionMajor: s.major,
            usbVersionMinor: s.minor,
            usbVersionSubminor: s.sub,
            manufacturerName: a,
            productName: u,
            serialNumber: l,
            configurations: e,
            _currentConfiguration: o.bConfigurationValue
          };
          return t(new U(d));
        });
      }).catch(e => {
        t(null);
      }) : t(null);
    });
  }

  decodeVersion(e) {
    const t = `0000${e.toString(16)}`.slice(-4);
    return {
      major: parseInt(t.substr(0, 2), null),
      minor: parseInt(t.substr(2, 1), null),
      sub: parseInt(t.substr(3, 1), null)
    };
  }

  getStringDescriptor(e, t) {
    return new Promise(r => {
      this.openDevice(e).then(() => {
        e.getStringDescriptor(t, (t, n) => {
          e.close(), r(t ? "" : n.toString());
        });
      }).catch(e => {
        r("");
      });
    });
  }

  bufferToDataView(e) {
    const t = new Uint8Array(e).buffer;
    return new DataView(t);
  }

  bufferSourceToBuffer(e) {
    const t = ArrayBuffer.isView(e) ? e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength) : e;
    return Buffer.from(t);
  }

  getEndpoint(t, r, n) {
    let s = null;
    const o = n | ("in" === r ? _usb.LIBUSB_ENDPOINT_IN : _usb.LIBUSB_ENDPOINT_OUT);
    return t.interfaces.some(e => {
      const t = e.endpoint(o);
      return !!t && (s = t, !0);
    }), s;
  }

  getInEndpoint(e, t) {
    const r = this.getEndpoint(e, "in", t);
    if (r && "in" === r.direction) return r;
  }

  getOutEndpoint(e, t) {
    const r = this.getEndpoint(e, "out", t);
    if (r && "out" === r.direction) return r;
  }

  endpointToUSBEndpoint(t) {
    const r = t.bEndpointAddress & _usb.LIBUSB_ENDPOINT_IN ? "in" : "out";
    return new O({
      endpointNumber: t.bEndpointAddress ^ ("in" === r ? _usb.LIBUSB_ENDPOINT_IN : _usb.LIBUSB_ENDPOINT_OUT),
      direction: r,
      type: (t.bmAttributes & x.LIBUSB_TRANSFER_TYPE_MASK) === _usb.LIBUSB_TRANSFER_TYPE_BULK ? "bulk" : (t.bmAttributes & x.LIBUSB_TRANSFER_TYPE_MASK) === _usb.LIBUSB_TRANSFER_TYPE_INTERRUPT ? "interrupt" : "isochronous",
      packetSize: t.wMaxPacketSize
    });
  }

  interfaceToUSBAlternateInterface(e, t) {
    return this.getStringDescriptor(e, t.iInterface).then(e => new V({
      alternateSetting: t.bAlternateSetting,
      interfaceClass: t.bInterfaceClass,
      interfaceSubclass: t.bInterfaceSubClass,
      interfaceProtocol: t.bInterfaceProtocol,
      interfaceName: e,
      endpoints: t.endpoints.map(this.endpointToUSBEndpoint)
    }));
  }

  interfacesToUSBInterface(e, t) {
    return this.serialDevicePromises(this.interfaceToUSBAlternateInterface, e, t).then(r => new L({
      _handle: this.getDeviceHandle(e),
      interfaceNumber: t[0].bInterfaceNumber,
      alternates: r
    }));
  }

  configToUSBConfiguration(e, t) {
    return this.getStringDescriptor(e, t.iConfiguration).then(r => {
      const n = t.interfaces || [];
      return this.serialDevicePromises(this.interfacesToUSBInterface, e, n).then(e => new P({
        configurationValue: t.bConfigurationValue,
        configurationName: r,
        interfaces: e
      }));
    });
  }

  getDevice(e) {
    return this.devices[e] ? this.devices[e].device : null;
  }

  controlTransferParamsToType(e, t) {
    return ("device" === e.recipient ? _usb.LIBUSB_RECIPIENT_DEVICE : "interface" === e.recipient ? _usb.LIBUSB_RECIPIENT_INTERFACE : "endpoint" === e.recipient ? _usb.LIBUSB_RECIPIENT_ENDPOINT : _usb.LIBUSB_RECIPIENT_OTHER) | ("standard" === e.requestType ? _usb.LIBUSB_REQUEST_TYPE_STANDARD : "class" === e.requestType ? _usb.LIBUSB_REQUEST_TYPE_CLASS : _usb.LIBUSB_REQUEST_TYPE_VENDOR) | t;
  }

  openDevice(e, t = 0) {
    return this.retryPromise(() => new Promise((t, r) => {
      try {
        e.open();
      } catch (e) {
        return r(e);
      }

      t();
    }), t);
  }

  getConnected(e) {
    return null !== this.getDevice(e);
  }

  getOpened(e) {
    const t = this.getDevice(e);
    return !!t && null !== t.interfaces;
  }

  listUSBDevices(e) {
    return this.loadDevices(e).then(() => this.serialPromises(this.devicetoUSBDevice, Object.keys(this.devices)));
  }

  open(e) {
    const t = this.getDevice(e);
    return this.openDevice(t);
  }

  close(e) {
    return new Promise((t, r) => {
      this.getDevice(e).close(), t();
    });
  }

  selectConfiguration(e, t) {
    return new Promise((r, n) => {
      this.getDevice(e).setConfiguration(t, e => {
        if (e) return n(e);
        r();
      });
    });
  }

  claimInterface(e, t) {
    return new Promise((r, n) => {
      this.getDevice(e).interface(t).claim(), r();
    });
  }

  releaseInterface(e, t) {
    return new Promise((r, n) => {
      this.getDevice(e).interface(t).release(!0, e => {
        if (e) return n(e);
        r();
      });
    });
  }

  selectAlternateInterface(e, t, r) {
    return new Promise((n, i) => {
      this.getDevice(e).interface(t).setAltSetting(r, e => {
        if (e) return i(e);
        n();
      });
    });
  }

  controlTransferIn(t, r, n) {
    return new Promise((i, s) => {
      const o = this.getDevice(t),
            c = this.controlTransferParamsToType(r, _usb.LIBUSB_ENDPOINT_IN);
      o.controlTransfer(c, r.request, r.value, r.index, n, (e, t) => {
        if (e) return e.errno === _usb.LIBUSB_TRANSFER_STALL ? i({
          status: "stall"
        }) : e.errno === _usb.LIBUSB_TRANSFER_OVERFLOW ? i({
          status: "babble"
        }) : s(e);
        i({
          data: this.bufferToDataView(t),
          status: "ok"
        });
      });
    });
  }

  controlTransferOut(e, t, r) {
    return new Promise((n, s) => {
      const o = this.getDevice(e),
            c = this.controlTransferParamsToType(t, _usb.LIBUSB_ENDPOINT_OUT),
            a = r ? this.bufferSourceToBuffer(r) : new Buffer(0);
      o.controlTransfer(c, t.request, t.value, t.index, a, e => {
        if (e) return e.errno === _usb.LIBUSB_TRANSFER_STALL ? n({
          bytesWritten: 0,
          status: "stall"
        }) : s(e);
        n({
          bytesWritten: a.byteLength,
          status: "ok"
        });
      });
    });
  }

  clearHalt(t, r, n) {
    return new Promise((s, o) => {
      const c = this.getDevice(t),
            a = n | ("in" === r ? _usb.LIBUSB_ENDPOINT_IN : _usb.LIBUSB_ENDPOINT_OUT);
      c.controlTransfer(_usb.LIBUSB_RECIPIENT_ENDPOINT, x.CLEAR_FEATURE, x.ENDPOINT_HALT, a, 0, e => {
        if (e) return o(e);
        s();
      });
    });
  }

  transferIn(e, t, r) {
    return new Promise((n, i) => {
      const s = this.getDevice(e);
      this.getInEndpoint(s, t).transfer(r, (e, t) => {
        if (e) return e.errno === _usb.LIBUSB_TRANSFER_STALL ? n({
          status: "stall"
        }) : e.errno === _usb.LIBUSB_TRANSFER_OVERFLOW ? n({
          status: "babble"
        }) : i(e);
        n({
          data: this.bufferToDataView(t),
          status: "ok"
        });
      });
    });
  }

  transferOut(e, t, r) {
    return new Promise((n, i) => {
      const s = this.getDevice(e),
            o = this.getOutEndpoint(s, t),
            c = this.bufferSourceToBuffer(r);
      o.transfer(c, e => {
        if (e) return e.errno === _usb.LIBUSB_TRANSFER_STALL ? n({
          bytesWritten: 0,
          status: "stall"
        }) : i(e);
        n({
          bytesWritten: c.byteLength,
          status: "ok"
        });
      });
    });
  }

  isochronousTransferIn(e, t, r) {
    return new Promise((e, t) => {
      t("isochronousTransferIn error: method not implemented");
    });
  }

  isochronousTransferOut(e, t, r, n) {
    return new Promise((e, t) => {
      t("isochronousTransferOut error: method not implemented");
    });
  }

  reset(e) {
    return new Promise((t, r) => {
      this.getDevice(e).reset(e => {
        if (e) return r(e);
        t();
      });
    });
  }

}

exports.USBAdapter = $;
$.EVENT_DEVICE_CONNECT = "connect", $.EVENT_DEVICE_DISCONNECT = "disconnect";
const k = new $();
exports.adapter = k;

class M {
  constructor() {
    this.bubbles = !1, this.cancelable = !1, this.cancelBubble = !1, this.composed = !1, this.defaultPrevented = !1, this.eventPhase = 0, this.isTrusted = !0, this.returnValue = !0;
  }

  composedPath() {
    return [];
  }

  initEvent(e, t, r) {
    this.type = e, this.bubbles = t, this.cancelable = r;
  }

  preventDefault() {
    this.defaultPrevented = !0;
  }

  stopImmediatePropagation() {}

  stopPropagation() {}

}

class R extends M {
  constructor(e, t, r) {
    super(), this.initEvent(t, r.bubbles, r.cancelable), this.target = e, this.device = r.device;
  }

}

class j extends y {
  constructor(e) {
    super(), this.allowedDevices = [], e = e || {}, this.devicesFound = e.devicesFound;

    const t = e => {
      if (this.replaceAllowedDevice(e)) {
        const t = new R(this, "connect", {
          device: e
        });
        this.dispatchEvent(t), this.onconnect && this.onconnect(t);
      }
    },
          r = e => {
      const t = this.allowedDevices.find(t => t._handle === e);

      if (t) {
        const e = new R(this, "disconnect", {
          device: t
        });
        this.dispatchEvent(e), this.ondisconnect && this.ondisconnect(e);
      }
    };

    this.on("newListener", e => {
      0 === this.listenerCount(e) && ("connect" === e ? k.addListener($.EVENT_DEVICE_CONNECT, t) : "disconnect" === e && k.addListener($.EVENT_DEVICE_DISCONNECT, r));
    }), this.on("removeListener", e => {
      0 === this.listenerCount(e) && ("connect" === e ? k.removeListener($.EVENT_DEVICE_CONNECT, t) : "disconnect" === e && k.removeListener($.EVENT_DEVICE_DISCONNECT, r));
    });
  }

  set onconnect(e) {
    this._onconnect && this.removeEventListener("connect", this._onconnect), this._onconnect = e, this.addEventListener("connect", this._onconnect);
  }

  set ondisconnect(e) {
    this._ondisconnect && this.removeEventListener("disconnect", this._ondisconnect), this._ondisconnect = e, this.addEventListener("disconnect", this._ondisconnect);
  }

  replaceAllowedDevice(e) {
    for (const t in this.allowedDevices) if (this.isSameDevice(e, this.allowedDevices[t])) return this.allowedDevices[t] = e, !0;

    return !1;
  }

  isSameDevice(e, t) {
    return e.productId === t.productId && e.vendorId === t.vendorId && e.serialNumber === t.serialNumber;
  }

  filterDevice(e, t) {
    return e.filters.some(e => {
      if (e.vendorId && e.vendorId !== t.vendorId) return !1;
      if (e.productId && e.productId !== t.productId) return !1;

      if (e.classCode) {
        if (t.configuration.interfaces.some(t => (!e.classCode || e.classCode === t.alternate.interfaceClass) && (!e.subclassCode || e.subclassCode === t.alternate.interfaceSubclass) && (!e.protocolCode || e.protocolCode === t.alternate.interfaceProtocol))) return !0;
      }

      return (!e.classCode || e.classCode === t.deviceClass) && (!e.subclassCode || e.subclassCode === t.deviceSubclass) && (!e.protocolCode || e.protocolCode === t.deviceProtocol) && (!e.serialNumber || e.serialNumber === t.serialNumber);
    });
  }

  getDevices() {
    const e = this.allowedDevices.map(e => ({
      vendorId: e.vendorId || void 0,
      productId: e.productId || void 0,
      classCode: e.deviceClass || void 0,
      subclassCode: e.deviceSubclass || void 0,
      protocolCode: e.deviceProtocol || void 0,
      serialNumber: e.serialNumber || void 0
    }));
    return k.listUSBDevices(e).then(e => {
      return e.filter(e => {
        if (!e.connected) return !1;

        for (const t in this.allowedDevices) if (this.isSameDevice(e, this.allowedDevices[t])) return !0;

        return !1;
      });
    });
  }

  requestDevice(e) {
    return new Promise((t, r) => {
      if (!e) return r(new TypeError("requestDevice error: 1 argument required, but only 0 present"));
      if (e.constructor !== {}.constructor) return r(new TypeError("requestDevice error: parameter 1 (options) is not an object"));
      if (!e.filters) return r(new TypeError("requestDevice error: required member filters is undefined"));
      if (e.filters.constructor !== [].constructor) return r(new TypeError("requestDevice error: the provided value cannot be converted to a sequence"));
      return e.filters.every(e => e.protocolCode && !e.subclassCode ? (r(new TypeError("requestDevice error: subclass code is required")), !1) : !(e.subclassCode && !e.classCode) || (r(new TypeError("requestDevice error: class code is required")), !1)) ? k.listUSBDevices(e.filters).then(n => {
        if (0 === (n = n.filter(t => this.filterDevice(e, t))).length) return r(new Error("requestDevice error: no devices found"));

        function i(e) {
          this.replaceAllowedDevice(e) || this.allowedDevices.push(e), t(e);
        }

        return this.devicesFound ? this.devicesFound(n).then(e => (e || r(new Error("selected device not found")), i.call(this, e))) : i.call(this, n[0]);
      }).catch(e => {
        r(new Error(`requestDevice error: ${e}`));
      }) : void 0;
    });
  }

}

exports.USB = j;
const q = new j();
exports.usb = q;
},{"usb":"../node_modules/usb/usb.js","buffer":"../node_modules/buffer/index.js"}],"../node_modules/jacdac-ts/dist/jacdac.cjs.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
}); // Service: Common registers and commands

const ANNOUNCE_INTERVAL = 0x1f4;
exports.SystemReadingThreshold = void 0;

(function (SystemReadingThreshold) {
  SystemReadingThreshold[SystemReadingThreshold["Neutral"] = 1] = "Neutral";
  SystemReadingThreshold[SystemReadingThreshold["Inactive"] = 2] = "Inactive";
  SystemReadingThreshold[SystemReadingThreshold["Active"] = 3] = "Active";
})(exports.SystemReadingThreshold || (exports.SystemReadingThreshold = {}));

exports.SystemStatusCodes = void 0;

(function (SystemStatusCodes) {
  SystemStatusCodes[SystemStatusCodes["Ready"] = 0] = "Ready";
  SystemStatusCodes[SystemStatusCodes["Initializing"] = 1] = "Initializing";
  SystemStatusCodes[SystemStatusCodes["Calibrating"] = 2] = "Calibrating";
  SystemStatusCodes[SystemStatusCodes["Sleeping"] = 3] = "Sleeping";
  SystemStatusCodes[SystemStatusCodes["WaitingForInput"] = 4] = "WaitingForInput";
  SystemStatusCodes[SystemStatusCodes["CalibrationNeeded"] = 100] = "CalibrationNeeded";
})(exports.SystemStatusCodes || (exports.SystemStatusCodes = {}));

exports.SystemCmd = void 0;

(function (SystemCmd) {
  /**
   * No args. Enumeration data for control service; service-specific advertisement data otherwise.
   * Control broadcasts it automatically every ``announce_interval``ms, but other service have to be queried to provide it.
   */
  SystemCmd[SystemCmd["Announce"] = 0] = "Announce";
  /**
   * No args. Registers number `N` is fetched by issuing command `0x1000 | N`.
   * The report format is the same as the format of the register.
   */

  SystemCmd[SystemCmd["GetRegister"] = 4096] = "GetRegister";
  /**
   * No args. Registers number `N` is set by issuing command `0x2000 | N`, with the format
   * the same as the format of the register.
   */

  SystemCmd[SystemCmd["SetRegister"] = 8192] = "SetRegister";
  /**
   * Event from sensor or a broadcast service.
   *
   * ```
   * const [eventId, eventArgument] = jdunpack<[number, number]>(buf, "u32 u32")
   * ```
   */

  SystemCmd[SystemCmd["Event"] = 1] = "Event";
  /**
   * No args. Request to calibrate a sensor. The report indicates the calibration is done.
   */

  SystemCmd[SystemCmd["Calibrate"] = 2] = "Calibrate";
})(exports.SystemCmd || (exports.SystemCmd = {}));

exports.SystemReg = void 0;

(function (SystemReg) {
  /**
   * Read-write uint32_t. This is either binary on/off (0 or non-zero), or can be gradual (eg. brightness of an RGB LED strip).
   *
   * ```
   * const [intensity] = jdunpack<[number]>(buf, "u32")
   * ```
   */
  SystemReg[SystemReg["Intensity"] = 1] = "Intensity";
  /**
   * Read-write int32_t. The primary value of actuator (eg. servo pulse length, or motor duty cycle).
   *
   * ```
   * const [value] = jdunpack<[number]>(buf, "i32")
   * ```
   */

  SystemReg[SystemReg["Value"] = 2] = "Value";
  /**
   * Constant int32_t. The lowest value that can be reported for the value register.
   *
   * ```
   * const [minValue] = jdunpack<[number]>(buf, "i32")
   * ```
   */

  SystemReg[SystemReg["MinValue"] = 272] = "MinValue";
  /**
   * Constant int32_t. The highest value that can be reported for the value register.
   *
   * ```
   * const [maxValue] = jdunpack<[number]>(buf, "i32")
   * ```
   */

  SystemReg[SystemReg["MaxValue"] = 273] = "MaxValue";
  /**
   * Read-write mA uint16_t. Limit the power drawn by the service, in mA.
   *
   * ```
   * const [maxPower] = jdunpack<[number]>(buf, "u16")
   * ```
   */

  SystemReg[SystemReg["MaxPower"] = 7] = "MaxPower";
  /**
   * Read-write # uint8_t. Asks device to stream a given number of samples
   * (clients will typically write `255` to this register every second or so, while streaming is required).
   *
   * ```
   * const [streamingSamples] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  SystemReg[SystemReg["StreamingSamples"] = 3] = "StreamingSamples";
  /**
   * Read-write ms uint32_t. Period between packets of data when streaming in milliseconds.
   *
   * ```
   * const [streamingInterval] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  SystemReg[SystemReg["StreamingInterval"] = 4] = "StreamingInterval";
  /**
   * Read-only int32_t. Read-only value of the sensor, also reported in streaming.
   *
   * ```
   * const [reading] = jdunpack<[number]>(buf, "i32")
   * ```
   */

  SystemReg[SystemReg["Reading"] = 257] = "Reading";
  /**
   * Constant int32_t. The lowest value that can be reported by the sensor.
   *
   * ```
   * const [minReading] = jdunpack<[number]>(buf, "i32")
   * ```
   */

  SystemReg[SystemReg["MinReading"] = 260] = "MinReading";
  /**
   * Constant int32_t. The highest value that can be reported by the sensor.
   *
   * ```
   * const [maxReading] = jdunpack<[number]>(buf, "i32")
   * ```
   */

  SystemReg[SystemReg["MaxReading"] = 261] = "MaxReading";
  /**
   * Read-only uint32_t. The real value of whatever is measured is between `reading - reading_error` and `reading + reading_error`. It should be computed from the internal state of the sensor. This register is often, but not always `const`. If the register value is modified,
   * send a report in the same frame of the ``reading`` report.
   *
   * ```
   * const [readingError] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  SystemReg[SystemReg["ReadingError"] = 262] = "ReadingError";
  /**
   * Constant uint32_t. Smallest, yet distinguishable change in reading.
   *
   * ```
   * const [readingResolution] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  SystemReg[SystemReg["ReadingResolution"] = 264] = "ReadingResolution";
  /**
   * Read-write int32_t. Threshold when reading data gets inactive and triggers a ``inactive``.
   *
   * ```
   * const [inactiveThreshold] = jdunpack<[number]>(buf, "i32")
   * ```
   */

  SystemReg[SystemReg["InactiveThreshold"] = 5] = "InactiveThreshold";
  /**
   * Read-write int32_t. Thresholds when reading data gets active and triggers a ``active`` event.
   *
   * ```
   * const [activeThreshold] = jdunpack<[number]>(buf, "i32")
   * ```
   */

  SystemReg[SystemReg["ActiveThreshold"] = 6] = "ActiveThreshold";
  /**
   * Constant ms uint32_t. Preferred default streaming interval for sensor in milliseconds.
   *
   * ```
   * const [streamingPreferredInterval] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  SystemReg[SystemReg["StreamingPreferredInterval"] = 258] = "StreamingPreferredInterval";
  /**
   * Constant uint32_t. The hardware variant of the service.
   * For services which support this, there's an enum defining the meaning.
   *
   * ```
   * const [variant] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  SystemReg[SystemReg["Variant"] = 263] = "Variant";
  /**
   * Reports the current state or error status of the device. ``code`` is a standardized value from
   * the Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device
   * state. This report is typically not queried, when a device has an error, it will typically
   * add this report in frame along with the announce packet.
   *
   * ```
   * const [code, vendorCode] = jdunpack<[SystemStatusCodes, number]>(buf, "u16 u16")
   * ```
   */

  SystemReg[SystemReg["StatusCode"] = 259] = "StatusCode";
  /**
   * Constant string (bytes). A friendly name that describes the role of this service instance in the device.
   *
   * ```
   * const [instanceName] = jdunpack<[string]>(buf, "s")
   * ```
   */

  SystemReg[SystemReg["InstanceName"] = 265] = "InstanceName";
})(exports.SystemReg || (exports.SystemReg = {}));

exports.SystemEvent = void 0;

(function (SystemEvent) {
  /**
   * Notifies that the service has been activated (eg. button pressed, network connected, etc.)
   */
  SystemEvent[SystemEvent["Active"] = 1] = "Active";
  /**
   * Notifies that the service has been dis-activated.
   */

  SystemEvent[SystemEvent["Inactive"] = 2] = "Inactive";
  /**
   * Notifies that the some state of the service changed.
   */

  SystemEvent[SystemEvent["Change"] = 3] = "Change";
  /**
   * Notifies that the status code of the service changed.
   *
   * ```
   * const [code, vendorCode] = jdunpack<[SystemStatusCodes, number]>(buf, "u16 u16")
   * ```
   */

  SystemEvent[SystemEvent["StatusCodeChanged"] = 4] = "StatusCodeChanged";
  /**
   * Notifies that the threshold is back between ``low`` and ``high``.
   */

  SystemEvent[SystemEvent["Neutral"] = 7] = "Neutral";
})(exports.SystemEvent || (exports.SystemEvent = {})); // Service: Base service


exports.BaseReg = void 0;

(function (BaseReg) {
  /**
   * Constant string (bytes). A friendly name that describes the role of this service instance in the device.
   * It often corresponds to what's printed on the device:
   * for example, `A` for button A, or `S0` for servo channel 0.
   * Words like `left` should be avoided because of localization issues (unless they are printed on the device).
   *
   * ```
   * const [instanceName] = jdunpack<[string]>(buf, "s")
   * ```
   */
  BaseReg[BaseReg["InstanceName"] = 265] = "InstanceName";
  /**
   * Reports the current state or error status of the device. ``code`` is a standardized value from
   * the Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device
   * state. This report is typically not queried, when a device has an error, it will typically
   * add this report in frame along with the announce packet. If a service implements this register,
   * it should also support the ``status_code_changed`` event defined below.
   *
   * ```
   * const [code, vendorCode] = jdunpack<[number, number]>(buf, "u16 u16")
   * ```
   */

  BaseReg[BaseReg["StatusCode"] = 259] = "StatusCode";
})(exports.BaseReg || (exports.BaseReg = {}));

exports.BaseEvent = void 0;

(function (BaseEvent) {
  /**
   * Notifies that the status code of the service changed.
   *
   * ```
   * const [code, vendorCode] = jdunpack<[number, number]>(buf, "u16 u16")
   * ```
   */
  BaseEvent[BaseEvent["StatusCodeChanged"] = 4] = "StatusCodeChanged";
})(exports.BaseEvent || (exports.BaseEvent = {})); // Service: Sensor


exports.SensorReg = void 0;

(function (SensorReg) {
  /**
   * Read-write # uint8_t. Asks device to stream a given number of samples
   * (clients will typically write `255` to this register every second or so, while streaming is required).
   *
   * ```
   * const [streamingSamples] = jdunpack<[number]>(buf, "u8")
   * ```
   */
  SensorReg[SensorReg["StreamingSamples"] = 3] = "StreamingSamples";
  /**
   * Read-write ms uint32_t. Period between packets of data when streaming in milliseconds.
   *
   * ```
   * const [streamingInterval] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  SensorReg[SensorReg["StreamingInterval"] = 4] = "StreamingInterval";
  /**
   * Constant ms uint32_t. Preferred default streaming interval for sensor in milliseconds.
   *
   * ```
   * const [streamingPreferredInterval] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  SensorReg[SensorReg["StreamingPreferredInterval"] = 258] = "StreamingPreferredInterval";
})(exports.SensorReg || (exports.SensorReg = {})); // Service: Accelerometer


const SRV_ACCELEROMETER = 0x1f140409;
exports.AccelerometerReg = void 0;

(function (AccelerometerReg) {
  /**
   * Indicates the current forces acting on accelerometer.
   *
   * ```
   * const [x, y, z] = jdunpack<[number, number, number]>(buf, "i12.20 i12.20 i12.20")
   * ```
   */
  AccelerometerReg[AccelerometerReg["Forces"] = 257] = "Forces";
  /**
   * Read-only g i12.20 (int32_t). Error on the reading value.
   *
   * ```
   * const [forcesError] = jdunpack<[number]>(buf, "i12.20")
   * ```
   */

  AccelerometerReg[AccelerometerReg["ForcesError"] = 262] = "ForcesError";
  /**
   * Read-write g i12.20 (int32_t). Configures the range forces detected.
   * Read-back after setting to get current value.
   *
   * ```
   * const [maxForce] = jdunpack<[number]>(buf, "i12.20")
   * ```
   */

  AccelerometerReg[AccelerometerReg["MaxForce"] = 128] = "MaxForce";
})(exports.AccelerometerReg || (exports.AccelerometerReg = {}));

exports.AccelerometerEvent = void 0;

(function (AccelerometerEvent) {
  /**
   * Emitted when accelerometer is tilted in the given direction.
   */
  AccelerometerEvent[AccelerometerEvent["TiltUp"] = 129] = "TiltUp";
  /**
   * Emitted when accelerometer is tilted in the given direction.
   */

  AccelerometerEvent[AccelerometerEvent["TiltDown"] = 130] = "TiltDown";
  /**
   * Emitted when accelerometer is tilted in the given direction.
   */

  AccelerometerEvent[AccelerometerEvent["TiltLeft"] = 131] = "TiltLeft";
  /**
   * Emitted when accelerometer is tilted in the given direction.
   */

  AccelerometerEvent[AccelerometerEvent["TiltRight"] = 132] = "TiltRight";
  /**
   * Emitted when accelerometer is laying flat in the given direction.
   */

  AccelerometerEvent[AccelerometerEvent["FaceUp"] = 133] = "FaceUp";
  /**
   * Emitted when accelerometer is laying flat in the given direction.
   */

  AccelerometerEvent[AccelerometerEvent["FaceDown"] = 134] = "FaceDown";
  /**
   * Emitted when total force acting on accelerometer is much less than 1g.
   */

  AccelerometerEvent[AccelerometerEvent["Freefall"] = 135] = "Freefall";
  /**
   * Emitted when forces change violently a few times.
   */

  AccelerometerEvent[AccelerometerEvent["Shake"] = 139] = "Shake";
  /**
   * Emitted when force in any direction exceeds given threshold.
   */

  AccelerometerEvent[AccelerometerEvent["Force2g"] = 140] = "Force2g";
  /**
   * Emitted when force in any direction exceeds given threshold.
   */

  AccelerometerEvent[AccelerometerEvent["Force3g"] = 136] = "Force3g";
  /**
   * Emitted when force in any direction exceeds given threshold.
   */

  AccelerometerEvent[AccelerometerEvent["Force6g"] = 137] = "Force6g";
  /**
   * Emitted when force in any direction exceeds given threshold.
   */

  AccelerometerEvent[AccelerometerEvent["Force8g"] = 138] = "Force8g";
})(exports.AccelerometerEvent || (exports.AccelerometerEvent = {})); // Service: Arcade Gamepad


const SRV_ARCADE_GAMEPAD = 0x1deaa06e;
exports.ArcadeGamepadButton = void 0;

(function (ArcadeGamepadButton) {
  ArcadeGamepadButton[ArcadeGamepadButton["Left"] = 1] = "Left";
  ArcadeGamepadButton[ArcadeGamepadButton["Up"] = 2] = "Up";
  ArcadeGamepadButton[ArcadeGamepadButton["Right"] = 3] = "Right";
  ArcadeGamepadButton[ArcadeGamepadButton["Down"] = 4] = "Down";
  ArcadeGamepadButton[ArcadeGamepadButton["A"] = 5] = "A";
  ArcadeGamepadButton[ArcadeGamepadButton["B"] = 6] = "B";
  ArcadeGamepadButton[ArcadeGamepadButton["Menu"] = 7] = "Menu";
  ArcadeGamepadButton[ArcadeGamepadButton["Select"] = 8] = "Select";
  ArcadeGamepadButton[ArcadeGamepadButton["Reset"] = 9] = "Reset";
  ArcadeGamepadButton[ArcadeGamepadButton["Exit"] = 10] = "Exit";
})(exports.ArcadeGamepadButton || (exports.ArcadeGamepadButton = {}));

exports.ArcadeGamepadReg = void 0;

(function (ArcadeGamepadReg) {
  /**
   * Indicates which buttons are currently active (pressed).
   * `pressure` should be `0xff` for digital buttons, and proportional for analog ones.
   *
   * ```
   * const [rest] = jdunpack<[([ArcadeGamepadButton, number])[]]>(buf, "r: u8 u0.8")
   * const [button, pressure] = rest[0]
   * ```
   */
  ArcadeGamepadReg[ArcadeGamepadReg["Buttons"] = 257] = "Buttons";
  /**
   * Constant. Indicates number of players supported and which buttons are present on the controller.
   *
   * ```
   * const [button] = jdunpack<[ArcadeGamepadButton[]]>(buf, "u8[]")
   * ```
   */

  ArcadeGamepadReg[ArcadeGamepadReg["AvailableButtons"] = 384] = "AvailableButtons";
})(exports.ArcadeGamepadReg || (exports.ArcadeGamepadReg = {}));

exports.ArcadeGamepadEvent = void 0;

(function (ArcadeGamepadEvent) {
  /**
   * Argument: button Button (uint8_t). Emitted when button goes from inactive to active.
   *
   * ```
   * const [button] = jdunpack<[ArcadeGamepadButton]>(buf, "u8")
   * ```
   */
  ArcadeGamepadEvent[ArcadeGamepadEvent["Down"] = 1] = "Down";
  /**
   * Argument: button Button (uint8_t). Emitted when button goes from active to inactive.
   *
   * ```
   * const [button] = jdunpack<[ArcadeGamepadButton]>(buf, "u8")
   * ```
   */

  ArcadeGamepadEvent[ArcadeGamepadEvent["Up"] = 2] = "Up";
})(exports.ArcadeGamepadEvent || (exports.ArcadeGamepadEvent = {})); // Service: Arcade sound


const SRV_ARCADE_SOUND = 0x1fc63606;
exports.ArcadeSoundCmd = void 0;

(function (ArcadeSoundCmd) {
  /**
   * Argument: samples bytes. Play samples, which are single channel, signed 16-bit little endian values.
   *
   * ```
   * const [samples] = jdunpack<[Uint8Array]>(buf, "b")
   * ```
   */
  ArcadeSoundCmd[ArcadeSoundCmd["Play"] = 128] = "Play";
})(exports.ArcadeSoundCmd || (exports.ArcadeSoundCmd = {}));

exports.ArcadeSoundReg = void 0;

(function (ArcadeSoundReg) {
  /**
   * Read-write Hz u22.10 (uint32_t). Get or set playback sample rate (in samples per second).
   * If you set it, read it back, as the value may be rounded up or down.
   *
   * ```
   * const [sampleRate] = jdunpack<[number]>(buf, "u22.10")
   * ```
   */
  ArcadeSoundReg[ArcadeSoundReg["SampleRate"] = 128] = "SampleRate";
  /**
   * Constant B uint32_t. The size of the internal audio buffer.
   *
   * ```
   * const [bufferSize] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  ArcadeSoundReg[ArcadeSoundReg["BufferSize"] = 384] = "BufferSize";
  /**
   * Read-only B uint32_t. How much data is still left in the buffer to play.
   * Clients should not send more data than `buffer_size - buffer_pending`,
   * but can keep the `buffer_pending` as low as they want to ensure low latency
   * of audio playback.
   *
   * ```
   * const [bufferPending] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  ArcadeSoundReg[ArcadeSoundReg["BufferPending"] = 385] = "BufferPending";
})(exports.ArcadeSoundReg || (exports.ArcadeSoundReg = {})); // Service: Azure IoT Hub Health


const SRV_AZURE_IOT_HUB_HEALTH = 0x1462eefc;
exports.AzureIotHubHealthConnectionStatus = void 0;

(function (AzureIotHubHealthConnectionStatus) {
  AzureIotHubHealthConnectionStatus[AzureIotHubHealthConnectionStatus["Connected"] = 1] = "Connected";
  AzureIotHubHealthConnectionStatus[AzureIotHubHealthConnectionStatus["Disconnected"] = 2] = "Disconnected";
  AzureIotHubHealthConnectionStatus[AzureIotHubHealthConnectionStatus["Connecting"] = 3] = "Connecting";
  AzureIotHubHealthConnectionStatus[AzureIotHubHealthConnectionStatus["Disconnecting"] = 4] = "Disconnecting";
})(exports.AzureIotHubHealthConnectionStatus || (exports.AzureIotHubHealthConnectionStatus = {}));

exports.AzureIotHubHealthReg = void 0;

(function (AzureIotHubHealthReg) {
  /**
   * Read-only string (bytes). Something like `my-iot-hub.azure-devices.net`; empty string when not properly configured
   *
   * ```
   * const [hubName] = jdunpack<[string]>(buf, "s")
   * ```
   */
  AzureIotHubHealthReg[AzureIotHubHealthReg["HubName"] = 384] = "HubName";
  /**
   * Read-only string (bytes). Device identifier in Azure Iot Hub
   *
   * ```
   * const [hubDeviceId] = jdunpack<[string]>(buf, "s")
   * ```
   */

  AzureIotHubHealthReg[AzureIotHubHealthReg["HubDeviceId"] = 385] = "HubDeviceId";
  /**
   * Read-only ConnectionStatus (uint16_t). Indicates the status of connection. A message beyond the [0..3] range represents an HTTP error code.
   *
   * ```
   * const [connectionStatus] = jdunpack<[AzureIotHubHealthConnectionStatus]>(buf, "u16")
   * ```
   */

  AzureIotHubHealthReg[AzureIotHubHealthReg["ConnectionStatus"] = 386] = "ConnectionStatus";
})(exports.AzureIotHubHealthReg || (exports.AzureIotHubHealthReg = {}));

exports.AzureIotHubHealthCmd = void 0;

(function (AzureIotHubHealthCmd) {
  /**
   * No args. Starts a connection to the IoT hub service
   */
  AzureIotHubHealthCmd[AzureIotHubHealthCmd["Connect"] = 129] = "Connect";
  /**
   * No args. Starts disconnecting from the IoT hub service
   */

  AzureIotHubHealthCmd[AzureIotHubHealthCmd["Disconnect"] = 130] = "Disconnect";
  /**
   * Argument: connection_string string (bytes). Restricted command to override the existing connection string to the Azure IoT Hub.
   *
   * ```
   * const [connectionString] = jdunpack<[string]>(buf, "s")
   * ```
   */

  AzureIotHubHealthCmd[AzureIotHubHealthCmd["SetConnectionString"] = 134] = "SetConnectionString";
})(exports.AzureIotHubHealthCmd || (exports.AzureIotHubHealthCmd = {}));

exports.AzureIotHubHealthEvent = void 0;

(function (AzureIotHubHealthEvent) {
  /**
   * Argument: connection_status ConnectionStatus (uint16_t). Raised when the connection status changes
   *
   * ```
   * const [connectionStatus] = jdunpack<[AzureIotHubHealthConnectionStatus]>(buf, "u16")
   * ```
   */
  AzureIotHubHealthEvent[AzureIotHubHealthEvent["ConnectionStatusChange"] = 3] = "ConnectionStatusChange";
})(exports.AzureIotHubHealthEvent || (exports.AzureIotHubHealthEvent = {})); // Service: Barcode reader


const SRV_BARCODE_READER = 0x1c739e6c;
exports.BarcodeReaderFormat = void 0;

(function (BarcodeReaderFormat) {
  BarcodeReaderFormat[BarcodeReaderFormat["Aztec"] = 1] = "Aztec";
  BarcodeReaderFormat[BarcodeReaderFormat["Code128"] = 2] = "Code128";
  BarcodeReaderFormat[BarcodeReaderFormat["Code39"] = 3] = "Code39";
  BarcodeReaderFormat[BarcodeReaderFormat["Code93"] = 4] = "Code93";
  BarcodeReaderFormat[BarcodeReaderFormat["Codabar"] = 5] = "Codabar";
  BarcodeReaderFormat[BarcodeReaderFormat["DataMatrix"] = 6] = "DataMatrix";
  BarcodeReaderFormat[BarcodeReaderFormat["Ean13"] = 8] = "Ean13";
  BarcodeReaderFormat[BarcodeReaderFormat["Ean8"] = 9] = "Ean8";
  BarcodeReaderFormat[BarcodeReaderFormat["ITF"] = 10] = "ITF";
  BarcodeReaderFormat[BarcodeReaderFormat["Pdf417"] = 11] = "Pdf417";
  BarcodeReaderFormat[BarcodeReaderFormat["QrCode"] = 12] = "QrCode";
  BarcodeReaderFormat[BarcodeReaderFormat["UpcA"] = 13] = "UpcA";
  BarcodeReaderFormat[BarcodeReaderFormat["UpcE"] = 14] = "UpcE";
})(exports.BarcodeReaderFormat || (exports.BarcodeReaderFormat = {}));

exports.BarcodeReaderReg = void 0;

(function (BarcodeReaderReg) {
  /**
   * Read-write bool (uint8_t). Turns on or off the detection of barcodes.
   *
   * ```
   * const [enabled] = jdunpack<[number]>(buf, "u8")
   * ```
   */
  BarcodeReaderReg[BarcodeReaderReg["Enabled"] = 1] = "Enabled";
  /**
   * Constant. Reports the list of supported barcode formats, as documented in https://developer.mozilla.org/en-US/docs/Web/API/Barcode_Detection_API.
   *
   * ```
   * const [format] = jdunpack<[BarcodeReaderFormat[]]>(buf, "u8[]")
   * ```
   */

  BarcodeReaderReg[BarcodeReaderReg["Formats"] = 384] = "Formats";
})(exports.BarcodeReaderReg || (exports.BarcodeReaderReg = {}));

exports.BarcodeReaderEvent = void 0;

(function (BarcodeReaderEvent) {
  /**
   * Raised when a bar code is detected and decoded. If the reader detects multiple codes, it will issue multiple events.
   * In case of numeric barcodes, the `data` field should contain the ASCII (which is the same as UTF8 in that case) representation of the number.
   *
   * ```
   * const [format, data] = jdunpack<[BarcodeReaderFormat, string]>(buf, "u8 s")
   * ```
   */
  BarcodeReaderEvent[BarcodeReaderEvent["Detect"] = 1] = "Detect";
})(exports.BarcodeReaderEvent || (exports.BarcodeReaderEvent = {})); // Service: Barometer


const SRV_BAROMETER = 0x1e117cea;
exports.BarometerReg = void 0;

(function (BarometerReg) {
  /**
   * Read-only hPa u22.10 (uint32_t). The air pressure.
   *
   * ```
   * const [pressure] = jdunpack<[number]>(buf, "u22.10")
   * ```
   */
  BarometerReg[BarometerReg["Pressure"] = 257] = "Pressure";
  /**
   * Read-only hPa u22.10 (uint32_t). The real pressure is between `pressure - pressure_error` and `pressure + pressure_error`.
   *
   * ```
   * const [pressureError] = jdunpack<[number]>(buf, "u22.10")
   * ```
   */

  BarometerReg[BarometerReg["PressureError"] = 262] = "PressureError";
})(exports.BarometerReg || (exports.BarometerReg = {})); // Service: bit:radio


const SRV_BIT_RADIO = 0x1ac986cf;
exports.BitRadioReg = void 0;

(function (BitRadioReg) {
  /**
   * Read-write bool (uint8_t). Turns on/off the radio antenna.
   *
   * ```
   * const [enabled] = jdunpack<[number]>(buf, "u8")
   * ```
   */
  BitRadioReg[BitRadioReg["Enabled"] = 1] = "Enabled";
  /**
   * Read-write uint8_t. Group used to filter packets
   *
   * ```
   * const [group] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  BitRadioReg[BitRadioReg["Group"] = 128] = "Group";
  /**
   * Read-write uint8_t. Antenna power to increase or decrease range.
   *
   * ```
   * const [transmissionPower] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  BitRadioReg[BitRadioReg["TransmissionPower"] = 129] = "TransmissionPower";
  /**
   * Read-write uint8_t. Change the transmission and reception band of the radio to the given channel.
   *
   * ```
   * const [frequencyBand] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  BitRadioReg[BitRadioReg["FrequencyBand"] = 130] = "FrequencyBand";
})(exports.BitRadioReg || (exports.BitRadioReg = {}));

exports.BitRadioCmd = void 0;

(function (BitRadioCmd) {
  /**
   * Argument: message string (bytes). Sends a string payload as a radio message, maximum 18 characters.
   *
   * ```
   * const [message] = jdunpack<[string]>(buf, "s")
   * ```
   */
  BitRadioCmd[BitRadioCmd["SendString"] = 128] = "SendString";
  /**
   * Argument: value f64 (uint64_t). Sends a double precision number payload as a radio message
   *
   * ```
   * const [value] = jdunpack<[number]>(buf, "f64")
   * ```
   */

  BitRadioCmd[BitRadioCmd["SendNumber"] = 129] = "SendNumber";
  /**
   * Sends a double precision number and a name payload as a radio message
   *
   * ```
   * const [value, name] = jdunpack<[number, string]>(buf, "f64 s")
   * ```
   */

  BitRadioCmd[BitRadioCmd["SendValue"] = 130] = "SendValue";
  /**
   * Argument: data bytes. Sends a payload of bytes as a radio message
   *
   * ```
   * const [data] = jdunpack<[Uint8Array]>(buf, "b")
   * ```
   */

  BitRadioCmd[BitRadioCmd["SendBuffer"] = 131] = "SendBuffer";
  /**
   * Raised when a string packet is received
   *
   * ```
   * const [time, deviceSerialNumber, rssi, message] = jdunpack<[number, number, number, string]>(buf, "u32 u32 i8 x[1] s")
   * ```
   */

  BitRadioCmd[BitRadioCmd["StringReceived"] = 144] = "StringReceived";
  /**
   * Raised when a number packet is received
   *
   * ```
   * const [time, deviceSerialNumber, rssi, value, name] = jdunpack<[number, number, number, number, string]>(buf, "u32 u32 i8 x[3] f64 s")
   * ```
   */

  BitRadioCmd[BitRadioCmd["NumberReceived"] = 145] = "NumberReceived";
  /**
   * Raised when a buffer packet is received
   *
   * ```
   * const [time, deviceSerialNumber, rssi, data] = jdunpack<[number, number, number, Uint8Array]>(buf, "u32 u32 i8 x[1] b")
   * ```
   */

  BitRadioCmd[BitRadioCmd["BufferReceived"] = 146] = "BufferReceived";
})(exports.BitRadioCmd || (exports.BitRadioCmd = {})); // Service: Bootloader


const SRV_BOOTLOADER = 0x1ffa9948;
exports.BootloaderError = void 0;

(function (BootloaderError) {
  BootloaderError[BootloaderError["NoError"] = 0] = "NoError";
  BootloaderError[BootloaderError["PacketTooSmall"] = 1] = "PacketTooSmall";
  BootloaderError[BootloaderError["OutOfFlashableRange"] = 2] = "OutOfFlashableRange";
  BootloaderError[BootloaderError["InvalidPageOffset"] = 3] = "InvalidPageOffset";
  BootloaderError[BootloaderError["NotPageAligned"] = 4] = "NotPageAligned";
})(exports.BootloaderError || (exports.BootloaderError = {}));

exports.BootloaderCmd = void 0;

(function (BootloaderCmd) {
  /**
   * No args. The `service_class` is always `0x1ffa9948`. The `product_identifer` identifies the kind of firmware
   * that "fits" this device.
   */
  BootloaderCmd[BootloaderCmd["Info"] = 0] = "Info";
  /**
   * report Info
   * ```
   * const [serviceClass, pageSize, flashableSize, productIdentifer] = jdunpack<[number, number, number, number]>(buf, "u32 u32 u32 u32")
   * ```
   */

  /**
   * Argument: session_id uint32_t. The flashing server should generate a random id, and use this command to set it.
   *
   * ```
   * const [sessionId] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  BootloaderCmd[BootloaderCmd["SetSession"] = 129] = "SetSession";
  /**
   * report SetSession
   * ```
   * const [sessionId] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  /**
   * Use to send flashing data. A physical page is split into `chunk_max + 1` chunks, where `chunk_no = 0 ... chunk_max`.
   * Each chunk is stored at `page_address + page_offset`. `page_address` has to be equal in all chunks,
   * and is included in response.
   * Only the last chunk causes writing to flash and elicits response.
   *
   * ```
   * const [pageAddress, pageOffset, chunkNo, chunkMax, sessionId, pageData] = jdunpack<[number, number, number, number, number, Uint8Array]>(buf, "u32 u16 u8 u8 u32 x[4] x[4] x[4] x[4] b[208]")
   * ```
   */

  BootloaderCmd[BootloaderCmd["PageData"] = 128] = "PageData";
  /**
   * report PageData
   * ```
   * const [sessionId, pageError, pageAddress] = jdunpack<[number, BootloaderError, number]>(buf, "u32 u32 u32")
   * ```
   */
})(exports.BootloaderCmd || (exports.BootloaderCmd = {})); // Service: Button


const SRV_BUTTON = 0x1473a263;
exports.ButtonReg = void 0;

(function (ButtonReg) {
  /**
   * Read-only ratio u0.16 (uint16_t). Indicates the pressure state of the button, where ``0`` is open.
   *
   * ```
   * const [pressure] = jdunpack<[number]>(buf, "u0.16")
   * ```
   */
  ButtonReg[ButtonReg["Pressure"] = 257] = "Pressure";
  /**
   * Constant bool (uint8_t). Indicates if the button provides analog ``pressure`` readings.
   *
   * ```
   * const [analog] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  ButtonReg[ButtonReg["Analog"] = 384] = "Analog";
  /**
   * Read-only bool (uint8_t). Determines if the button is pressed currently.
   */

  ButtonReg[ButtonReg["Pressed"] = 385] = "Pressed";
})(exports.ButtonReg || (exports.ButtonReg = {}));

exports.ButtonEvent = void 0;

(function (ButtonEvent) {
  /**
   * Emitted when button goes from inactive to active.
   */
  ButtonEvent[ButtonEvent["Down"] = 1] = "Down";
  /**
   * Argument: time ms uint32_t. Emitted when button goes from active to inactive. The 'time' parameter
   * records the amount of time between the down and up events.
   *
   * ```
   * const [time] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  ButtonEvent[ButtonEvent["Up"] = 2] = "Up";
  /**
   * Argument: time ms uint32_t. Emitted when the press time is greater than 500ms, and then at least every 500ms
   * as long as the button remains pressed. The 'time' parameter records the the amount of time
   * that the button has been held (since the down event).
   *
   * ```
   * const [time] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  ButtonEvent[ButtonEvent["Hold"] = 129] = "Hold";
})(exports.ButtonEvent || (exports.ButtonEvent = {})); // Service: Buzzer


const SRV_BUZZER = 0x1b57b1d7;
exports.BuzzerReg = void 0;

(function (BuzzerReg) {
  /**
   * Read-write ratio u0.8 (uint8_t). The volume (duty cycle) of the buzzer.
   *
   * ```
   * const [volume] = jdunpack<[number]>(buf, "u0.8")
   * ```
   */
  BuzzerReg[BuzzerReg["Volume"] = 1] = "Volume";
})(exports.BuzzerReg || (exports.BuzzerReg = {}));

exports.BuzzerCmd = void 0;

(function (BuzzerCmd) {
  /**
   * Play a PWM tone with given period and duty for given duration.
   * The duty is scaled down with `volume` register.
   * To play tone at frequency `F` Hz and volume `V` (in `0..1`) you will want
   * to send `P = 1000000 / F` and `D = P * V / 2`.
   *
   * ```
   * const [period, duty, duration] = jdunpack<[number, number, number]>(buf, "u16 u16 u16")
   * ```
   */
  BuzzerCmd[BuzzerCmd["PlayTone"] = 128] = "PlayTone";
  /**
   * Play a note at the given frequency and volume.
   */

  BuzzerCmd[BuzzerCmd["PlayNote"] = 129] = "PlayNote";
})(exports.BuzzerCmd || (exports.BuzzerCmd = {})); // Service: Capacitive Button


const SRV_CAPACITIVE_BUTTON = 0x2865adc9;
exports.CapacitiveButtonReg = void 0;

(function (CapacitiveButtonReg) {
  /**
   * Read-write ratio u0.16 (uint16_t). Indicates the threshold for ``up`` events.
   *
   * ```
   * const [threshold] = jdunpack<[number]>(buf, "u0.16")
   * ```
   */
  CapacitiveButtonReg[CapacitiveButtonReg["Threshold"] = 6] = "Threshold";
})(exports.CapacitiveButtonReg || (exports.CapacitiveButtonReg = {}));

exports.CapacitiveButtonCmd = void 0;

(function (CapacitiveButtonCmd) {
  /**
   * No args. Request to calibrate the capactive. When calibration is requested, the device expects that no object is touching the button.
   * The report indicates the calibration is done.
   */
  CapacitiveButtonCmd[CapacitiveButtonCmd["Calibrate"] = 2] = "Calibrate";
})(exports.CapacitiveButtonCmd || (exports.CapacitiveButtonCmd = {})); // Service: Character Screen


const SRV_CHARACTER_SCREEN = 0x1f37c56a;
exports.CharacterScreenVariant = void 0;

(function (CharacterScreenVariant) {
  CharacterScreenVariant[CharacterScreenVariant["LCD"] = 1] = "LCD";
  CharacterScreenVariant[CharacterScreenVariant["OLED"] = 2] = "OLED";
  CharacterScreenVariant[CharacterScreenVariant["Braille"] = 3] = "Braille";
})(exports.CharacterScreenVariant || (exports.CharacterScreenVariant = {}));

exports.CharacterScreenTextDirection = void 0;

(function (CharacterScreenTextDirection) {
  CharacterScreenTextDirection[CharacterScreenTextDirection["LeftToRight"] = 1] = "LeftToRight";
  CharacterScreenTextDirection[CharacterScreenTextDirection["RightToLeft"] = 2] = "RightToLeft";
})(exports.CharacterScreenTextDirection || (exports.CharacterScreenTextDirection = {}));

exports.CharacterScreenReg = void 0;

(function (CharacterScreenReg) {
  /**
   * Read-write string (bytes). Text to show. Use `\n` to break lines.
   *
   * ```
   * const [message] = jdunpack<[string]>(buf, "s")
   * ```
   */
  CharacterScreenReg[CharacterScreenReg["Message"] = 2] = "Message";
  /**
   * Read-write ratio u0.8 (uint8_t). Brightness of the screen. `0` means off.
   *
   * ```
   * const [brightness] = jdunpack<[number]>(buf, "u0.8")
   * ```
   */

  CharacterScreenReg[CharacterScreenReg["Brightness"] = 1] = "Brightness";
  /**
   * Constant Variant (uint8_t). Describes the type of character LED screen.
   *
   * ```
   * const [variant] = jdunpack<[CharacterScreenVariant]>(buf, "u8")
   * ```
   */

  CharacterScreenReg[CharacterScreenReg["Variant"] = 263] = "Variant";
  /**
   * Read-write TextDirection (uint8_t). Specifies the RTL or LTR direction of the text.
   *
   * ```
   * const [textDirection] = jdunpack<[CharacterScreenTextDirection]>(buf, "u8")
   * ```
   */

  CharacterScreenReg[CharacterScreenReg["TextDirection"] = 130] = "TextDirection";
  /**
   * Constant # uint8_t. Gets the number of rows.
   *
   * ```
   * const [rows] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  CharacterScreenReg[CharacterScreenReg["Rows"] = 384] = "Rows";
  /**
   * Constant # uint8_t. Gets the number of columns.
   *
   * ```
   * const [columns] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  CharacterScreenReg[CharacterScreenReg["Columns"] = 385] = "Columns";
})(exports.CharacterScreenReg || (exports.CharacterScreenReg = {}));

exports.CharacterScreenCmd = void 0;

(function (CharacterScreenCmd) {
  /**
   * Overrides the content of a single line at a 0-based index.
   *
   * ```
   * const [index, message] = jdunpack<[number, string]>(buf, "u16 s")
   * ```
   */
  CharacterScreenCmd[CharacterScreenCmd["SetLine"] = 128] = "SetLine";
  /**
   * No args. Clears all text from the display.
   */

  CharacterScreenCmd[CharacterScreenCmd["Clear"] = 129] = "Clear";
})(exports.CharacterScreenCmd || (exports.CharacterScreenCmd = {})); // Service: Color


const SRV_COLOR = 0x1630d567;
exports.ColorReg = void 0;

(function (ColorReg) {
  /**
   * Detected color in the RGB color space.
   *
   * ```
   * const [red, green, blue] = jdunpack<[number, number, number]>(buf, "u0.16 u0.16 u0.16")
   * ```
   */
  ColorReg[ColorReg["Color"] = 257] = "Color";
})(exports.ColorReg || (exports.ColorReg = {})); // Service: Compass


const SRV_COMPASS = 0x15b7b9bf;
exports.CompassReg = void 0;

(function (CompassReg) {
  /**
   * Read-only ° u16.16 (uint32_t). The heading with respect to the magnetic north.
   *
   * ```
   * const [heading] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */
  CompassReg[CompassReg["Heading"] = 257] = "Heading";
  /**
   * Read-write bool (uint8_t). Turn on or off the sensor. Turning on the sensor may start a calibration sequence.
   *
   * ```
   * const [enabled] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  CompassReg[CompassReg["Enabled"] = 1] = "Enabled";
  /**
   * Read-only ° u16.16 (uint32_t). Error on the heading reading
   *
   * ```
   * const [headingError] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */

  CompassReg[CompassReg["HeadingError"] = 262] = "HeadingError";
})(exports.CompassReg || (exports.CompassReg = {}));

exports.CompassCmd = void 0;

(function (CompassCmd) {
  /**
   * No args. Starts a calibration sequence for the compass.
   */
  CompassCmd[CompassCmd["Calibrate"] = 2] = "Calibrate";
})(exports.CompassCmd || (exports.CompassCmd = {})); // Service: Control


const SRV_CONTROL = 0x0;
exports.ControlAnnounceFlags = void 0;

(function (ControlAnnounceFlags) {
  ControlAnnounceFlags[ControlAnnounceFlags["RestartCounterSteady"] = 15] = "RestartCounterSteady";
  ControlAnnounceFlags[ControlAnnounceFlags["RestartCounter1"] = 1] = "RestartCounter1";
  ControlAnnounceFlags[ControlAnnounceFlags["RestartCounter2"] = 2] = "RestartCounter2";
  ControlAnnounceFlags[ControlAnnounceFlags["RestartCounter4"] = 4] = "RestartCounter4";
  ControlAnnounceFlags[ControlAnnounceFlags["RestartCounter8"] = 8] = "RestartCounter8";
  ControlAnnounceFlags[ControlAnnounceFlags["StatusLightNone"] = 0] = "StatusLightNone";
  ControlAnnounceFlags[ControlAnnounceFlags["StatusLightMono"] = 16] = "StatusLightMono";
  ControlAnnounceFlags[ControlAnnounceFlags["StatusLightRgbNoFade"] = 32] = "StatusLightRgbNoFade";
  ControlAnnounceFlags[ControlAnnounceFlags["StatusLightRgbFade"] = 48] = "StatusLightRgbFade";
  ControlAnnounceFlags[ControlAnnounceFlags["SupportsACK"] = 256] = "SupportsACK";
  ControlAnnounceFlags[ControlAnnounceFlags["SupportsBroadcast"] = 512] = "SupportsBroadcast";
  ControlAnnounceFlags[ControlAnnounceFlags["SupportsFrames"] = 1024] = "SupportsFrames";
  ControlAnnounceFlags[ControlAnnounceFlags["IsClient"] = 2048] = "IsClient";
})(exports.ControlAnnounceFlags || (exports.ControlAnnounceFlags = {}));

exports.ControlCmd = void 0;

(function (ControlCmd) {
  /**
   * No args. The `restart_counter` is computed from the `flags & RestartCounterSteady`, starts at `0x1` and increments by one until it reaches `0xf`, then it stays at `0xf`.
   * If this number ever goes down, it indicates that the device restarted.
   * `service_class` indicates class identifier for each service index (service index `0` is always control, so it's
   * skipped in this enumeration).
   * `packet_count` indicates the number of packets sent by the current device since last announce,
   * including the current announce packet (it is always 0 if this feature is not supported).
   * The command form can be used to induce report, which is otherwise broadcast every 500ms.
   */
  ControlCmd[ControlCmd["Services"] = 0] = "Services";
  /**
   * report Services
   * ```
   * const [flags, packetCount, serviceClass] = jdunpack<[ControlAnnounceFlags, number, number[]]>(buf, "u16 u8 x[1] u32[]")
   * ```
   */

  /**
   * No args. Do nothing. Always ignored. Can be used to test ACKs.
   */

  ControlCmd[ControlCmd["Noop"] = 128] = "Noop";
  /**
   * No args. Blink the status LED (262ms on, 262ms off, four times, with the blue LED) or otherwise draw user's attention to device with no status light.
   * For devices with status light (this can be discovered in the announce flags), the client should
   * send the sequence of status light command to generate the identify animation.
   */

  ControlCmd[ControlCmd["Identify"] = 129] = "Identify";
  /**
   * No args. Reset device. ACK may or may not be sent.
   */

  ControlCmd[ControlCmd["Reset"] = 130] = "Reset";
  /**
   * The device will respond `num_responses` times, as fast as it can, setting the `counter` field in the report
   * to `start_counter`, then `start_counter + 1`, ..., and finally `start_counter + num_responses - 1`.
   * The `dummy_payload` is `size` bytes long and contains bytes `0, 1, 2, ...`.
   *
   * ```
   * const [numResponses, startCounter, size] = jdunpack<[number, number, number]>(buf, "u32 u32 u8")
   * ```
   */

  ControlCmd[ControlCmd["FloodPing"] = 131] = "FloodPing";
  /**
   * report FloodPing
   * ```
   * const [counter, dummyPayload] = jdunpack<[number, Uint8Array]>(buf, "u32 b")
   * ```
   */

  /**
   * Initiates a color transition of the status light from its current color to the one specified.
   * The transition will complete in about `512 / speed` frames
   * (each frame is currently 100ms, so speed of `51` is about 1 second and `26` 0.5 second).
   * As a special case, if speed is `0` the transition is immediate.
   * If MCU is not capable of executing transitions, it can consider `speed` to be always `0`.
   * If a monochrome LEDs is fitted, the average value of ``red``, ``green``, ``blue`` is used.
   * If intensity of a monochrome LED cannot be controlled, any value larger than `0` should be considered
   * on, and `0` (for all three channels) should be considered off.
   *
   * ```
   * const [toRed, toGreen, toBlue, speed] = jdunpack<[number, number, number, number]>(buf, "u8 u8 u8 u8")
   * ```
   */

  ControlCmd[ControlCmd["SetStatusLight"] = 132] = "SetStatusLight";
  /**
   * No args. Force client device into proxy mode.
   */

  ControlCmd[ControlCmd["Proxy"] = 133] = "Proxy";
})(exports.ControlCmd || (exports.ControlCmd = {}));

exports.ControlReg = void 0;

(function (ControlReg) {
  /**
   * Read-write μs uint32_t. When set to value other than `0`, it asks the device to reset after specified number of microseconds.
   * This is typically used to implement watchdog functionality, where a brain device sets `reset_in` to
   * say 1.6s every 0.5s.
   *
   * ```
   * const [resetIn] = jdunpack<[number]>(buf, "u32")
   * ```
   */
  ControlReg[ControlReg["ResetIn"] = 128] = "ResetIn";
  /**
   * Constant string (bytes). Identifies the type of hardware (eg., ACME Corp. Servo X-42 Rev C)
   *
   * ```
   * const [deviceDescription] = jdunpack<[string]>(buf, "s")
   * ```
   */

  ControlReg[ControlReg["DeviceDescription"] = 384] = "DeviceDescription";
  /**
   * Constant uint32_t. A numeric code for the string above; used to identify firmware images and devices.
   *
   * ```
   * const [productIdentifier] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  ControlReg[ControlReg["ProductIdentifier"] = 385] = "ProductIdentifier";
  /**
   * Constant uint32_t. Typically the same as `product_identifier` unless device was flashed by hand; the bootloader will respond to that code.
   *
   * ```
   * const [bootloaderProductIdentifier] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  ControlReg[ControlReg["BootloaderProductIdentifier"] = 388] = "BootloaderProductIdentifier";
  /**
   * Constant string (bytes). A string describing firmware version; typically semver.
   *
   * ```
   * const [firmwareVersion] = jdunpack<[string]>(buf, "s")
   * ```
   */

  ControlReg[ControlReg["FirmwareVersion"] = 389] = "FirmwareVersion";
  /**
   * Read-only °C int16_t. MCU temperature in degrees Celsius (approximate).
   *
   * ```
   * const [mcuTemperature] = jdunpack<[number]>(buf, "i16")
   * ```
   */

  ControlReg[ControlReg["McuTemperature"] = 386] = "McuTemperature";
  /**
   * Read-only μs uint64_t. Number of microseconds since boot.
   *
   * ```
   * const [uptime] = jdunpack<[number]>(buf, "u64")
   * ```
   */

  ControlReg[ControlReg["Uptime"] = 390] = "Uptime";
})(exports.ControlReg || (exports.ControlReg = {})); // Service: Dimmer


const SRV_DIMMER = 0x1fb02645;
exports.DimmerVariant = void 0;

(function (DimmerVariant) {
  DimmerVariant[DimmerVariant["Light"] = 1] = "Light";
  DimmerVariant[DimmerVariant["Fan"] = 2] = "Fan";
  DimmerVariant[DimmerVariant["Pump"] = 3] = "Pump";
})(exports.DimmerVariant || (exports.DimmerVariant = {}));

exports.DimmerReg = void 0;

(function (DimmerReg) {
  /**
   * Read-write ratio u0.16 (uint16_t). The intensity of the current. Set to ``0`` to turn off completely the current.
   *
   * ```
   * const [intensity] = jdunpack<[number]>(buf, "u0.16")
   * ```
   */
  DimmerReg[DimmerReg["Intensity"] = 1] = "Intensity";
  /**
   * Constant Variant (uint8_t). The type of physical device
   *
   * ```
   * const [variant] = jdunpack<[DimmerVariant]>(buf, "u8")
   * ```
   */

  DimmerReg[DimmerReg["Variant"] = 263] = "Variant";
})(exports.DimmerReg || (exports.DimmerReg = {})); // Service: Distance


const SRV_DISTANCE = 0x141a6b8a;
exports.DistanceVariant = void 0;

(function (DistanceVariant) {
  DistanceVariant[DistanceVariant["Ultrasonic"] = 1] = "Ultrasonic";
  DistanceVariant[DistanceVariant["Infrared"] = 2] = "Infrared";
  DistanceVariant[DistanceVariant["LiDAR"] = 3] = "LiDAR";
  DistanceVariant[DistanceVariant["Laser"] = 4] = "Laser";
})(exports.DistanceVariant || (exports.DistanceVariant = {}));

exports.DistanceReg = void 0;

(function (DistanceReg) {
  /**
   * Read-only m u16.16 (uint32_t). Current distance from the object
   *
   * ```
   * const [distance] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */
  DistanceReg[DistanceReg["Distance"] = 257] = "Distance";
  /**
   * Constant m u16.16 (uint32_t). Minimum measurable distance
   *
   * ```
   * const [minRange] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */

  DistanceReg[DistanceReg["MinRange"] = 260] = "MinRange";
  /**
   * Constant m u16.16 (uint32_t). Maximum measurable distance
   *
   * ```
   * const [maxRange] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */

  DistanceReg[DistanceReg["MaxRange"] = 261] = "MaxRange";
  /**
   * Constant Variant (uint8_t). Determines the type of sensor used.
   *
   * ```
   * const [variant] = jdunpack<[DistanceVariant]>(buf, "u8")
   * ```
   */

  DistanceReg[DistanceReg["Variant"] = 263] = "Variant";
})(exports.DistanceReg || (exports.DistanceReg = {})); // Service: DMX


const SRV_DMX = 0x11cf8c05;
exports.DmxReg = void 0;

(function (DmxReg) {
  /**
   * Read-write bool (uint8_t). Determines if the DMX bridge is active
   *
   * ```
   * const [enabled] = jdunpack<[number]>(buf, "u8")
   * ```
   */
  DmxReg[DmxReg["Enabled"] = 1] = "Enabled";
})(exports.DmxReg || (exports.DmxReg = {}));

exports.DmxCmd = void 0;

(function (DmxCmd) {
  /**
   * Argument: channels bytes. Send a DMX packet, up to 236bytes long, including the start code.
   *
   * ```
   * const [channels] = jdunpack<[Uint8Array]>(buf, "b")
   * ```
   */
  DmxCmd[DmxCmd["Send"] = 128] = "Send";
})(exports.DmxCmd || (exports.DmxCmd = {})); // Service: Dot Matrix


const SRV_DOT_MATRIX = 0x110d154b;
exports.DotMatrixVariant = void 0;

(function (DotMatrixVariant) {
  DotMatrixVariant[DotMatrixVariant["LED"] = 1] = "LED";
  DotMatrixVariant[DotMatrixVariant["Braille"] = 2] = "Braille";
})(exports.DotMatrixVariant || (exports.DotMatrixVariant = {}));

exports.DotMatrixReg = void 0;

(function (DotMatrixReg) {
  /**
   * Read-write bytes. The state of the screen where dot on/off state is
   * stored as a bit, column by column. The column should be byte aligned.
   *
   * ```
   * const [dots] = jdunpack<[Uint8Array]>(buf, "b")
   * ```
   */
  DotMatrixReg[DotMatrixReg["Dots"] = 2] = "Dots";
  /**
   * Read-write ratio u0.8 (uint8_t). Reads the general brightness of the display, brightness for LEDs. `0` when the screen is off.
   *
   * ```
   * const [brightness] = jdunpack<[number]>(buf, "u0.8")
   * ```
   */

  DotMatrixReg[DotMatrixReg["Brightness"] = 1] = "Brightness";
  /**
   * Constant # uint16_t. Number of rows on the screen
   *
   * ```
   * const [rows] = jdunpack<[number]>(buf, "u16")
   * ```
   */

  DotMatrixReg[DotMatrixReg["Rows"] = 385] = "Rows";
  /**
   * Constant # uint16_t. Number of columns on the screen
   *
   * ```
   * const [columns] = jdunpack<[number]>(buf, "u16")
   * ```
   */

  DotMatrixReg[DotMatrixReg["Columns"] = 386] = "Columns";
  /**
   * Constant Variant (uint8_t). Describes the type of matrix used.
   *
   * ```
   * const [variant] = jdunpack<[DotMatrixVariant]>(buf, "u8")
   * ```
   */

  DotMatrixReg[DotMatrixReg["Variant"] = 263] = "Variant";
})(exports.DotMatrixReg || (exports.DotMatrixReg = {})); // Service: Equivalent CO₂


const SRV_E_CO2 = 0x169c9dc6;
exports.ECO2Variant = void 0;

(function (ECO2Variant) {
  ECO2Variant[ECO2Variant["VOC"] = 1] = "VOC";
  ECO2Variant[ECO2Variant["NDIR"] = 2] = "NDIR";
})(exports.ECO2Variant || (exports.ECO2Variant = {}));

exports.ECO2Reg = void 0;

(function (ECO2Reg) {
  /**
   * Read-only ppm u22.10 (uint32_t). Equivalent CO₂ (eCO₂) readings.
   *
   * ```
   * const [eCO2] = jdunpack<[number]>(buf, "u22.10")
   * ```
   */
  ECO2Reg[ECO2Reg["ECO2"] = 257] = "ECO2";
  /**
   * Read-only ppm u22.10 (uint32_t). Error on the reading value.
   *
   * ```
   * const [eCO2Error] = jdunpack<[number]>(buf, "u22.10")
   * ```
   */

  ECO2Reg[ECO2Reg["ECO2Error"] = 262] = "ECO2Error";
  /**
   * Constant ppm u22.10 (uint32_t). Minimum measurable value
   *
   * ```
   * const [minECO2] = jdunpack<[number]>(buf, "u22.10")
   * ```
   */

  ECO2Reg[ECO2Reg["MinECO2"] = 260] = "MinECO2";
  /**
   * Constant ppm u22.10 (uint32_t). Minimum measurable value
   *
   * ```
   * const [maxECO2] = jdunpack<[number]>(buf, "u22.10")
   * ```
   */

  ECO2Reg[ECO2Reg["MaxECO2"] = 261] = "MaxECO2";
  /**
   * Constant s uint32_t. Time required to achieve good sensor stability before measuring after long idle period.
   *
   * ```
   * const [conditioningPeriod] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  ECO2Reg[ECO2Reg["ConditioningPeriod"] = 384] = "ConditioningPeriod";
  /**
   * Constant Variant (uint8_t). Type of physical sensor and capabilities.
   *
   * ```
   * const [variant] = jdunpack<[ECO2Variant]>(buf, "u8")
   * ```
   */

  ECO2Reg[ECO2Reg["Variant"] = 263] = "Variant";
})(exports.ECO2Reg || (exports.ECO2Reg = {})); // Service: Flex


const SRV_FLEX = 0x1f47c6c6;
exports.FlexVariant = void 0;

(function (FlexVariant) {
  FlexVariant[FlexVariant["Linear22Inch"] = 1] = "Linear22Inch";
  FlexVariant[FlexVariant["Linear45Inch"] = 2] = "Linear45Inch";
})(exports.FlexVariant || (exports.FlexVariant = {}));

exports.FlexReg = void 0;

(function (FlexReg) {
  /**
   * Read-only ratio u0.16 (uint16_t). The relative position of the slider.
   *
   * ```
   * const [bending] = jdunpack<[number]>(buf, "u0.16")
   * ```
   */
  FlexReg[FlexReg["Bending"] = 257] = "Bending";
  /**
   * Constant Variant (uint8_t). Specifies the physical layout of the flex sensor.
   *
   * ```
   * const [variant] = jdunpack<[FlexVariant]>(buf, "u8")
   * ```
   */

  FlexReg[FlexReg["Variant"] = 263] = "Variant";
})(exports.FlexReg || (exports.FlexReg = {})); // Service: Gyroscope


const SRV_GYROSCOPE = 0x1e1b06f2;
exports.GyroscopeReg = void 0;

(function (GyroscopeReg) {
  /**
   * Indicates the current forces acting on accelerometer.
   *
   * ```
   * const [x, y, z] = jdunpack<[number, number, number]>(buf, "i12.20 i12.20 i12.20")
   * ```
   */
  GyroscopeReg[GyroscopeReg["RotationRates"] = 257] = "RotationRates";
  /**
   * Read-only °/s i12.20 (int32_t). Error on the reading value.
   *
   * ```
   * const [rotationRatesError] = jdunpack<[number]>(buf, "i12.20")
   * ```
   */

  GyroscopeReg[GyroscopeReg["RotationRatesError"] = 262] = "RotationRatesError";
  /**
   * Read-write °/s i12.20 (int32_t). Configures the range of range of rotation rates.
   *
   * ```
   * const [maxRate] = jdunpack<[number]>(buf, "i12.20")
   * ```
   */

  GyroscopeReg[GyroscopeReg["MaxRate"] = 128] = "MaxRate";
})(exports.GyroscopeReg || (exports.GyroscopeReg = {})); // Service: Heart Rate


const SRV_HEART_RATE = 0x166c6dc4;
exports.HeartRateVariant = void 0;

(function (HeartRateVariant) {
  HeartRateVariant[HeartRateVariant["Finger"] = 1] = "Finger";
  HeartRateVariant[HeartRateVariant["Chest"] = 2] = "Chest";
  HeartRateVariant[HeartRateVariant["Wrist"] = 3] = "Wrist";
  HeartRateVariant[HeartRateVariant["Pump"] = 4] = "Pump";
  HeartRateVariant[HeartRateVariant["WebCam"] = 5] = "WebCam";
})(exports.HeartRateVariant || (exports.HeartRateVariant = {}));

exports.HeartRateReg = void 0;

(function (HeartRateReg) {
  /**
   * Read-only bpm u16.16 (uint32_t). The estimated heart rate.
   *
   * ```
   * const [heartRate] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */
  HeartRateReg[HeartRateReg["HeartRate"] = 257] = "HeartRate";
  /**
   * Read-only bpm u16.16 (uint32_t). The estimated error on the reported sensor data.
   *
   * ```
   * const [heartRateError] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */

  HeartRateReg[HeartRateReg["HeartRateError"] = 262] = "HeartRateError";
  /**
   * Constant Variant (uint8_t). The type of physical sensor
   *
   * ```
   * const [variant] = jdunpack<[HeartRateVariant]>(buf, "u8")
   * ```
   */

  HeartRateReg[HeartRateReg["Variant"] = 263] = "Variant";
})(exports.HeartRateReg || (exports.HeartRateReg = {})); // Service: HID Adapter


const SRV_HID_ADAPTER = 0x1e5758b5;
exports.HidAdapterReg = void 0;

(function (HidAdapterReg) {
  /**
   * Read-write uint8_t. The number of configurations stored on the server.
   *
   * ```
   * const [numConfigurations] = jdunpack<[number]>(buf, "u8")
   * ```
   */
  HidAdapterReg[HidAdapterReg["NumConfigurations"] = 128] = "NumConfigurations";
  /**
   * Read-write uint8_t. The current configuration the server is using.
   *
   * ```
   * const [currentConfiguration] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  HidAdapterReg[HidAdapterReg["CurrentConfiguration"] = 129] = "CurrentConfiguration";
})(exports.HidAdapterReg || (exports.HidAdapterReg = {}));

exports.HidAdapterCmd = void 0;

(function (HidAdapterCmd) {
  /**
   * Retrieves a configuration stored on the server. If the configuration does not exist, an empty report will be returned
   *
   * ```
   * const [results, configurationNumber] = jdunpack<[Uint8Array, number]>(buf, "b[12] u8")
   * ```
   */
  HidAdapterCmd[HidAdapterCmd["GetConfiguration"] = 128] = "GetConfiguration";
  /**
   * Stores the given binding on the server. If a binding exists at this index, the new binding will replace it.
   *
   * ```
   * const [configurationNumber, bindingIndex, deviceId, serviceClass, triggerValue, triggerContext, serviceIndex, selector, modifiers] = jdunpack<[number, number, number, number, number, number, number, number, number]>(buf, "u8 u8 x[2] u64 u32 u32 u8 u8 u16 u16")
   * ```
   */

  HidAdapterCmd[HidAdapterCmd["SetBinding"] = 130] = "SetBinding";
  /**
   * Clears a specific binding stored on the device.
   *
   * ```
   * const [configurationNumber, bindingIndex] = jdunpack<[number, number]>(buf, "u8 u8")
   * ```
   */

  HidAdapterCmd[HidAdapterCmd["ClearBinding"] = 131] = "ClearBinding";
  /**
   * Argument: configuration_number uint8_t. Clears a specific configuration stored on the device.
   *
   * ```
   * const [configurationNumber] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  HidAdapterCmd[HidAdapterCmd["ClearConfiguration"] = 132] = "ClearConfiguration";
  /**
   * No args. Clears all configurations and bindings stored on the device.
   */

  HidAdapterCmd[HidAdapterCmd["Clear"] = 133] = "Clear";
})(exports.HidAdapterCmd || (exports.HidAdapterCmd = {}));
/**
 * pipe_report Configuration
 * ```
 * const [configurationNumber, bindingIndex, deviceId, serviceClass, triggerValue, triggerContext, serviceIndex, selector, modifiers] = jdunpack<[number, number, number, number, number, number, number, number, number]>(buf, "u8 u8 x[2] u64 u32 u32 u8 u8 u16 u16")
 * ```
 */


exports.HidAdapterEvent = void 0;

(function (HidAdapterEvent) {
  /**
   * Event that notifies clients that the server has swapped to a new configuration or changed key bindings.
   */
  HidAdapterEvent[HidAdapterEvent["Changed"] = 3] = "Changed";
})(exports.HidAdapterEvent || (exports.HidAdapterEvent = {})); // Service: HID Keyboard


const SRV_HID_KEYBOARD = 0x18b05b6a;
exports.HidKeyboardModifiers = void 0;

(function (HidKeyboardModifiers) {
  HidKeyboardModifiers[HidKeyboardModifiers["None"] = 0] = "None";
  HidKeyboardModifiers[HidKeyboardModifiers["LeftControl"] = 1] = "LeftControl";
  HidKeyboardModifiers[HidKeyboardModifiers["LeftShift"] = 2] = "LeftShift";
  HidKeyboardModifiers[HidKeyboardModifiers["LeftAlt"] = 4] = "LeftAlt";
  HidKeyboardModifiers[HidKeyboardModifiers["LeftGUI"] = 8] = "LeftGUI";
  HidKeyboardModifiers[HidKeyboardModifiers["RightControl"] = 16] = "RightControl";
  HidKeyboardModifiers[HidKeyboardModifiers["RightShift"] = 32] = "RightShift";
  HidKeyboardModifiers[HidKeyboardModifiers["RightAlt"] = 64] = "RightAlt";
  HidKeyboardModifiers[HidKeyboardModifiers["RightGUI"] = 128] = "RightGUI";
})(exports.HidKeyboardModifiers || (exports.HidKeyboardModifiers = {}));

exports.HidKeyboardAction = void 0;

(function (HidKeyboardAction) {
  HidKeyboardAction[HidKeyboardAction["Press"] = 0] = "Press";
  HidKeyboardAction[HidKeyboardAction["Up"] = 1] = "Up";
  HidKeyboardAction[HidKeyboardAction["Down"] = 2] = "Down";
})(exports.HidKeyboardAction || (exports.HidKeyboardAction = {}));

exports.HidKeyboardCmd = void 0;

(function (HidKeyboardCmd) {
  /**
   * Presses a key or a sequence of keys down.
   *
   * ```
   * const [rest] = jdunpack<[([number, HidKeyboardModifiers, HidKeyboardAction])[]]>(buf, "r: u16 u8 u8")
   * const [selector, modifiers, action] = rest[0]
   * ```
   */
  HidKeyboardCmd[HidKeyboardCmd["Key"] = 128] = "Key";
  /**
   * No args. Clears all pressed keys.
   */

  HidKeyboardCmd[HidKeyboardCmd["Clear"] = 129] = "Clear";
})(exports.HidKeyboardCmd || (exports.HidKeyboardCmd = {})); // Service: HID Mouse


const SRV_HID_MOUSE = 0x1885dc1c;
exports.HidMouseButton = void 0;

(function (HidMouseButton) {
  HidMouseButton[HidMouseButton["Left"] = 1] = "Left";
  HidMouseButton[HidMouseButton["Right"] = 2] = "Right";
  HidMouseButton[HidMouseButton["Middle"] = 4] = "Middle";
})(exports.HidMouseButton || (exports.HidMouseButton = {}));

exports.HidMouseButtonEvent = void 0;

(function (HidMouseButtonEvent) {
  HidMouseButtonEvent[HidMouseButtonEvent["Up"] = 1] = "Up";
  HidMouseButtonEvent[HidMouseButtonEvent["Down"] = 2] = "Down";
  HidMouseButtonEvent[HidMouseButtonEvent["Click"] = 3] = "Click";
  HidMouseButtonEvent[HidMouseButtonEvent["DoubleClick"] = 4] = "DoubleClick";
})(exports.HidMouseButtonEvent || (exports.HidMouseButtonEvent = {}));

exports.HidMouseCmd = void 0;

(function (HidMouseCmd) {
  /**
   * Sets the up/down state of one or more buttons.
   * A ``Click`` is the same as ``Down`` followed by ``Up`` after 100ms.
   * A ``DoubleClick`` is two clicks with ``150ms`` gap between them (that is, ``100ms`` first click, ``150ms`` gap, ``100ms`` second click).
   *
   * ```
   * const [buttons, event] = jdunpack<[HidMouseButton, HidMouseButtonEvent]>(buf, "u16 u8")
   * ```
   */
  HidMouseCmd[HidMouseCmd["SetButton"] = 128] = "SetButton";
  /**
   * Moves the mouse by the distance specified.
   * If the time is positive, it specifies how long to make the move.
   *
   * ```
   * const [dx, dy, time] = jdunpack<[number, number, number]>(buf, "i16 i16 u16")
   * ```
   */

  HidMouseCmd[HidMouseCmd["Move"] = 129] = "Move";
  /**
   * Turns the wheel up or down. Positive if scrolling up.
   * If the time is positive, it specifies how long to make the move.
   *
   * ```
   * const [dy, time] = jdunpack<[number, number]>(buf, "i16 u16")
   * ```
   */

  HidMouseCmd[HidMouseCmd["Wheel"] = 130] = "Wheel";
})(exports.HidMouseCmd || (exports.HidMouseCmd = {})); // Service: Humidity


const SRV_HUMIDITY = 0x16c810b8;
exports.HumidityReg = void 0;

(function (HumidityReg) {
  /**
   * Read-only %RH u22.10 (uint32_t). The relative humidity in percentage of full water saturation.
   *
   * ```
   * const [humidity] = jdunpack<[number]>(buf, "u22.10")
   * ```
   */
  HumidityReg[HumidityReg["Humidity"] = 257] = "Humidity";
  /**
   * Read-only %RH u22.10 (uint32_t). The real humidity is between `humidity - humidity_error` and `humidity + humidity_error`.
   *
   * ```
   * const [humidityError] = jdunpack<[number]>(buf, "u22.10")
   * ```
   */

  HumidityReg[HumidityReg["HumidityError"] = 262] = "HumidityError";
  /**
   * Constant %RH u22.10 (uint32_t). Lowest humidity that can be reported.
   *
   * ```
   * const [minHumidity] = jdunpack<[number]>(buf, "u22.10")
   * ```
   */

  HumidityReg[HumidityReg["MinHumidity"] = 260] = "MinHumidity";
  /**
   * Constant %RH u22.10 (uint32_t). Highest humidity that can be reported.
   *
   * ```
   * const [maxHumidity] = jdunpack<[number]>(buf, "u22.10")
   * ```
   */

  HumidityReg[HumidityReg["MaxHumidity"] = 261] = "MaxHumidity";
})(exports.HumidityReg || (exports.HumidityReg = {})); // Service: Illuminance


const SRV_ILLUMINANCE = 0x1e6ecaf2;
exports.IlluminanceReg = void 0;

(function (IlluminanceReg) {
  /**
   * Read-only lux u22.10 (uint32_t). The amount of illuminance, as lumens per square metre.
   *
   * ```
   * const [light] = jdunpack<[number]>(buf, "u22.10")
   * ```
   */
  IlluminanceReg[IlluminanceReg["Light"] = 257] = "Light";
  /**
   * Read-only lux u22.10 (uint32_t). Error on the reported sensor value.
   *
   * ```
   * const [lightError] = jdunpack<[number]>(buf, "u22.10")
   * ```
   */

  IlluminanceReg[IlluminanceReg["LightError"] = 262] = "LightError";
})(exports.IlluminanceReg || (exports.IlluminanceReg = {})); // Service: Indexed screen


const SRV_INDEXED_SCREEN = 0x16fa36e5;
exports.IndexedScreenCmd = void 0;

(function (IndexedScreenCmd) {
  /**
   * Sets the update window for subsequent `set_pixels` commands.
   *
   * ```
   * const [x, y, width, height] = jdunpack<[number, number, number, number]>(buf, "u16 u16 u16 u16")
   * ```
   */
  IndexedScreenCmd[IndexedScreenCmd["StartUpdate"] = 129] = "StartUpdate";
  /**
   * Argument: pixels bytes. Set pixels in current window, according to current palette.
   * Each "line" of data is aligned to a byte.
   *
   * ```
   * const [pixels] = jdunpack<[Uint8Array]>(buf, "b")
   * ```
   */

  IndexedScreenCmd[IndexedScreenCmd["SetPixels"] = 131] = "SetPixels";
})(exports.IndexedScreenCmd || (exports.IndexedScreenCmd = {}));

exports.IndexedScreenReg = void 0;

(function (IndexedScreenReg) {
  /**
   * Read-write ratio u0.8 (uint8_t). Set backlight brightness.
   * If set to `0` the display may go to sleep.
   *
   * ```
   * const [brightness] = jdunpack<[number]>(buf, "u0.8")
   * ```
   */
  IndexedScreenReg[IndexedScreenReg["Brightness"] = 1] = "Brightness";
  /**
   * The current palette.
   * The color entry repeats `1 << bits_per_pixel` times.
   * This register may be write-only.
   *
   * ```
   * const [rest] = jdunpack<[([number, number, number])[]]>(buf, "r: u8 u8 u8 x[1]")
   * const [blue, green, red] = rest[0]
   * ```
   */

  IndexedScreenReg[IndexedScreenReg["Palette"] = 128] = "Palette";
  /**
   * Constant bit uint8_t. Determines the number of palette entries.
   * Typical values are 1, 2, 4, or 8.
   *
   * ```
   * const [bitsPerPixel] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  IndexedScreenReg[IndexedScreenReg["BitsPerPixel"] = 384] = "BitsPerPixel";
  /**
   * Constant px uint16_t. Screen width in "natural" orientation.
   *
   * ```
   * const [width] = jdunpack<[number]>(buf, "u16")
   * ```
   */

  IndexedScreenReg[IndexedScreenReg["Width"] = 385] = "Width";
  /**
   * Constant px uint16_t. Screen height in "natural" orientation.
   *
   * ```
   * const [height] = jdunpack<[number]>(buf, "u16")
   * ```
   */

  IndexedScreenReg[IndexedScreenReg["Height"] = 386] = "Height";
  /**
   * Read-write bool (uint8_t). If true, consecutive pixels in the "width" direction are sent next to each other (this is typical for graphics cards).
   * If false, consecutive pixels in the "height" direction are sent next to each other.
   * For embedded screen controllers, this is typically true iff `width < height`
   * (in other words, it's only true for portrait orientation screens).
   * Some controllers may allow the user to change this (though the refresh order may not be optimal then).
   * This is independent of the `rotation` register.
   *
   * ```
   * const [widthMajor] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  IndexedScreenReg[IndexedScreenReg["WidthMajor"] = 129] = "WidthMajor";
  /**
   * Read-write px uint8_t. Every pixel sent over wire is represented by `up_sampling x up_sampling` square of physical pixels.
   * Some displays may allow changing this (which will also result in changes to `width` and `height`).
   * Typical values are 1 and 2.
   *
   * ```
   * const [upSampling] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  IndexedScreenReg[IndexedScreenReg["UpSampling"] = 130] = "UpSampling";
  /**
   * Read-write ° uint16_t. Possible values are 0, 90, 180 and 270 only.
   * Write to this register do not affect `width` and `height` registers,
   * and may be ignored by some screens.
   *
   * ```
   * const [rotation] = jdunpack<[number]>(buf, "u16")
   * ```
   */

  IndexedScreenReg[IndexedScreenReg["Rotation"] = 131] = "Rotation";
})(exports.IndexedScreenReg || (exports.IndexedScreenReg = {})); // Service: Infrastructure


const SRV_INFRASTRUCTURE = 0x1e1589eb; // Service: Joystick

const SRV_JOYSTICK = 0x108f7456;
exports.JoystickButtons = void 0;

(function (JoystickButtons) {
  JoystickButtons[JoystickButtons["Left"] = 1] = "Left";
  JoystickButtons[JoystickButtons["Up"] = 2] = "Up";
  JoystickButtons[JoystickButtons["Right"] = 4] = "Right";
  JoystickButtons[JoystickButtons["Down"] = 8] = "Down";
  JoystickButtons[JoystickButtons["A"] = 16] = "A";
  JoystickButtons[JoystickButtons["B"] = 32] = "B";
  JoystickButtons[JoystickButtons["Menu"] = 64] = "Menu";
  JoystickButtons[JoystickButtons["Select"] = 128] = "Select";
  JoystickButtons[JoystickButtons["Reset"] = 256] = "Reset";
  JoystickButtons[JoystickButtons["Exit"] = 512] = "Exit";
  JoystickButtons[JoystickButtons["X"] = 1024] = "X";
  JoystickButtons[JoystickButtons["Y"] = 2048] = "Y";
})(exports.JoystickButtons || (exports.JoystickButtons = {}));

exports.JoystickVariant = void 0;

(function (JoystickVariant) {
  JoystickVariant[JoystickVariant["Thumb"] = 1] = "Thumb";
  JoystickVariant[JoystickVariant["ArcadeBall"] = 2] = "ArcadeBall";
  JoystickVariant[JoystickVariant["ArcadeStick"] = 3] = "ArcadeStick";
  JoystickVariant[JoystickVariant["Gamepad"] = 4] = "Gamepad";
})(exports.JoystickVariant || (exports.JoystickVariant = {}));

exports.JoystickReg = void 0;

(function (JoystickReg) {
  /**
   * If the joystick is analog, the directional buttons should be "simulated", based on joystick position
   * (`Left` is `{ x = -1, y = 0 }`, `Up` is `{ x = 0, y = -1}`).
   * If the joystick is digital, then each direction will read as either `-1`, `0`, or `1` (in fixed representation).
   * The primary button on the joystick is `A`.
   *
   * ```
   * const [buttons, x, y] = jdunpack<[JoystickButtons, number, number]>(buf, "u32 i1.15 i1.15")
   * ```
   */
  JoystickReg[JoystickReg["Direction"] = 257] = "Direction";
  /**
   * Constant Variant (uint8_t). The type of physical joystick.
   *
   * ```
   * const [variant] = jdunpack<[JoystickVariant]>(buf, "u8")
   * ```
   */

  JoystickReg[JoystickReg["Variant"] = 263] = "Variant";
  /**
   * Constant Buttons (uint32_t). Indicates a bitmask of the buttons that are mounted on the joystick.
   * If the `Left`/`Up`/`Right`/`Down` buttons are marked as available here, the joystick is digital.
   * Even when marked as not available, they will still be simulated based on the analog joystick.
   *
   * ```
   * const [buttonsAvailable] = jdunpack<[JoystickButtons]>(buf, "u32")
   * ```
   */

  JoystickReg[JoystickReg["ButtonsAvailable"] = 384] = "ButtonsAvailable";
})(exports.JoystickReg || (exports.JoystickReg = {}));

exports.JoystickEvent = void 0;

(function (JoystickEvent) {
  /**
   * Argument: buttons Buttons (uint32_t). Emitted whenever the state of buttons changes.
   *
   * ```
   * const [buttons] = jdunpack<[JoystickButtons]>(buf, "u32")
   * ```
   */
  JoystickEvent[JoystickEvent["ButtonsChanged"] = 3] = "ButtonsChanged";
})(exports.JoystickEvent || (exports.JoystickEvent = {})); // Service: LED


const SRV_LED = 0x1e3048f8;
exports.LedVariant = void 0;

(function (LedVariant) {
  LedVariant[LedVariant["ThroughHole"] = 1] = "ThroughHole";
  LedVariant[LedVariant["SMD"] = 2] = "SMD";
  LedVariant[LedVariant["Power"] = 3] = "Power";
  LedVariant[LedVariant["Bead"] = 4] = "Bead";
})(exports.LedVariant || (exports.LedVariant = {}));

exports.LedCmd = void 0;

(function (LedCmd) {
  /**
   * This has the same semantics as `set_status_light` in the control service.
   *
   * ```
   * const [toRed, toGreen, toBlue, speed] = jdunpack<[number, number, number, number]>(buf, "u8 u8 u8 u8")
   * ```
   */
  LedCmd[LedCmd["Animate"] = 128] = "Animate";
})(exports.LedCmd || (exports.LedCmd = {}));

exports.LedReg = void 0;

(function (LedReg) {
  /**
   * The current color of the LED.
   *
   * ```
   * const [red, green, blue] = jdunpack<[number, number, number]>(buf, "u8 u8 u8")
   * ```
   */
  LedReg[LedReg["Color"] = 384] = "Color";
  /**
   * Read-write mA uint16_t. Limit the power drawn by the light-strip (and controller).
   *
   * ```
   * const [maxPower] = jdunpack<[number]>(buf, "u16")
   * ```
   */

  LedReg[LedReg["MaxPower"] = 7] = "MaxPower";
  /**
   * Constant uint16_t. If known, specifies the number of LEDs in parallel on this device.
   *
   * ```
   * const [ledCount] = jdunpack<[number]>(buf, "u16")
   * ```
   */

  LedReg[LedReg["LedCount"] = 387] = "LedCount";
  /**
   * Constant nm uint16_t. If monochrome LED, specifies the wave length of the LED.
   *
   * ```
   * const [waveLength] = jdunpack<[number]>(buf, "u16")
   * ```
   */

  LedReg[LedReg["WaveLength"] = 385] = "WaveLength";
  /**
   * Constant mcd uint16_t. The luminous intensity of the LED, at full value, in micro candella.
   *
   * ```
   * const [luminousIntensity] = jdunpack<[number]>(buf, "u16")
   * ```
   */

  LedReg[LedReg["LuminousIntensity"] = 386] = "LuminousIntensity";
  /**
   * Constant Variant (uint8_t). The physical type of LED.
   *
   * ```
   * const [variant] = jdunpack<[LedVariant]>(buf, "u8")
   * ```
   */

  LedReg[LedReg["Variant"] = 263] = "Variant";
})(exports.LedReg || (exports.LedReg = {})); // Service: LED Pixel


const SRV_LED_PIXEL = 0x126f00e0;
exports.LedPixelLightType = void 0;

(function (LedPixelLightType) {
  LedPixelLightType[LedPixelLightType["WS2812B_GRB"] = 0] = "WS2812B_GRB";
  LedPixelLightType[LedPixelLightType["APA102"] = 16] = "APA102";
  LedPixelLightType[LedPixelLightType["SK9822"] = 17] = "SK9822";
})(exports.LedPixelLightType || (exports.LedPixelLightType = {}));

exports.LedPixelVariant = void 0;

(function (LedPixelVariant) {
  LedPixelVariant[LedPixelVariant["Strip"] = 1] = "Strip";
  LedPixelVariant[LedPixelVariant["Ring"] = 2] = "Ring";
  LedPixelVariant[LedPixelVariant["Stick"] = 3] = "Stick";
  LedPixelVariant[LedPixelVariant["Jewel"] = 4] = "Jewel";
  LedPixelVariant[LedPixelVariant["Matrix"] = 5] = "Matrix";
})(exports.LedPixelVariant || (exports.LedPixelVariant = {}));

exports.LedPixelReg = void 0;

(function (LedPixelReg) {
  /**
   * Read-write ratio u0.8 (uint8_t). Set the luminosity of the strip.
   * At `0` the power to the strip is completely shut down.
   *
   * ```
   * const [brightness] = jdunpack<[number]>(buf, "u0.8")
   * ```
   */
  LedPixelReg[LedPixelReg["Brightness"] = 1] = "Brightness";
  /**
   * Read-only ratio u0.8 (uint8_t). This is the luminosity actually applied to the strip.
   * May be lower than `brightness` if power-limited by the `max_power` register.
   * It will rise slowly (few seconds) back to `brightness` is limits are no longer required.
   *
   * ```
   * const [actualBrightness] = jdunpack<[number]>(buf, "u0.8")
   * ```
   */

  LedPixelReg[LedPixelReg["ActualBrightness"] = 384] = "ActualBrightness";
  /**
   * Read-write LightType (uint8_t). Specifies the type of light strip connected to controller.
   * Controllers which are sold with lights should default to the correct type
   * and could not allow change.
   *
   * ```
   * const [lightType] = jdunpack<[LedPixelLightType]>(buf, "u8")
   * ```
   */

  LedPixelReg[LedPixelReg["LightType"] = 128] = "LightType";
  /**
   * Read-write # uint16_t. Specifies the number of pixels in the strip.
   * Controllers which are sold with lights should default to the correct length
   * and could not allow change. Increasing length at runtime leads to ineffective use of memory and may lead to controller reboot.
   *
   * ```
   * const [numPixels] = jdunpack<[number]>(buf, "u16")
   * ```
   */

  LedPixelReg[LedPixelReg["NumPixels"] = 129] = "NumPixels";
  /**
   * Read-write # uint16_t. If the LED pixel strip is a matrix, specifies the number of columns. Otherwise, a square shape is assumed. Controllers which are sold with lights should default to the correct length
   * and could not allow change. Increasing length at runtime leads to ineffective use of memory and may lead to controller reboot.
   *
   * ```
   * const [numColumns] = jdunpack<[number]>(buf, "u16")
   * ```
   */

  LedPixelReg[LedPixelReg["NumColumns"] = 131] = "NumColumns";
  /**
   * Read-write mA uint16_t. Limit the power drawn by the light-strip (and controller).
   *
   * ```
   * const [maxPower] = jdunpack<[number]>(buf, "u16")
   * ```
   */

  LedPixelReg[LedPixelReg["MaxPower"] = 7] = "MaxPower";
  /**
   * Constant # uint16_t. The maximum supported number of pixels.
   * All writes to `num_pixels` are clamped to `max_pixels`.
   *
   * ```
   * const [maxPixels] = jdunpack<[number]>(buf, "u16")
   * ```
   */

  LedPixelReg[LedPixelReg["MaxPixels"] = 385] = "MaxPixels";
  /**
   * Read-write # uint16_t. How many times to repeat the program passed in `run` command.
   * Should be set before the `run` command.
   * Setting to `0` means to repeat forever.
   *
   * ```
   * const [numRepeats] = jdunpack<[number]>(buf, "u16")
   * ```
   */

  LedPixelReg[LedPixelReg["NumRepeats"] = 130] = "NumRepeats";
  /**
   * Constant Variant (uint8_t). Specifies the shape of the light strip.
   *
   * ```
   * const [variant] = jdunpack<[LedPixelVariant]>(buf, "u8")
   * ```
   */

  LedPixelReg[LedPixelReg["Variant"] = 263] = "Variant";
})(exports.LedPixelReg || (exports.LedPixelReg = {}));

exports.LedPixelCmd = void 0;

(function (LedPixelCmd) {
  /**
   * Argument: program bytes. Run the given light "program". See service description for details.
   *
   * ```
   * const [program] = jdunpack<[Uint8Array]>(buf, "b")
   * ```
   */
  LedPixelCmd[LedPixelCmd["Run"] = 129] = "Run";
})(exports.LedPixelCmd || (exports.LedPixelCmd = {})); // Service: Light level


const SRV_LIGHT_LEVEL = 0x17dc9a1c;
exports.LightLevelVariant = void 0;

(function (LightLevelVariant) {
  LightLevelVariant[LightLevelVariant["PhotoResistor"] = 1] = "PhotoResistor";
  LightLevelVariant[LightLevelVariant["LEDMatrix"] = 2] = "LEDMatrix";
  LightLevelVariant[LightLevelVariant["Ambient"] = 3] = "Ambient";
})(exports.LightLevelVariant || (exports.LightLevelVariant = {}));

exports.LightLevelReg = void 0;

(function (LightLevelReg) {
  /**
   * Read-only ratio u0.16 (uint16_t). Detect light level
   *
   * ```
   * const [lightLevel] = jdunpack<[number]>(buf, "u0.16")
   * ```
   */
  LightLevelReg[LightLevelReg["LightLevel"] = 257] = "LightLevel";
  /**
   * Constant Variant (uint8_t). The type of physical sensor.
   *
   * ```
   * const [variant] = jdunpack<[LightLevelVariant]>(buf, "u8")
   * ```
   */

  LightLevelReg[LightLevelReg["Variant"] = 263] = "Variant";
})(exports.LightLevelReg || (exports.LightLevelReg = {})); // Service: Logger


const SRV_LOGGER = 0x12dc1fca;
exports.LoggerPriority = void 0;

(function (LoggerPriority) {
  LoggerPriority[LoggerPriority["Debug"] = 0] = "Debug";
  LoggerPriority[LoggerPriority["Log"] = 1] = "Log";
  LoggerPriority[LoggerPriority["Warning"] = 2] = "Warning";
  LoggerPriority[LoggerPriority["Error"] = 3] = "Error";
  LoggerPriority[LoggerPriority["Silent"] = 4] = "Silent";
})(exports.LoggerPriority || (exports.LoggerPriority = {}));

exports.LoggerReg = void 0;

(function (LoggerReg) {
  /**
   * Read-write Priority (uint8_t). Messages with level lower than this won't be emitted. The default setting may vary.
   * Loggers should revert this to their default setting if the register has not been
   * updated in 3000ms, and also keep the lowest setting they have seen in the last 1500ms.
   * Thus, clients should write this register every 1000ms and ignore messages which are
   * too verbose for them.
   *
   * ```
   * const [minPriority] = jdunpack<[LoggerPriority]>(buf, "u8")
   * ```
   */
  LoggerReg[LoggerReg["MinPriority"] = 128] = "MinPriority";
})(exports.LoggerReg || (exports.LoggerReg = {}));

exports.LoggerCmd = void 0;

(function (LoggerCmd) {
  /**
   * Argument: message string (bytes). Report a message.
   *
   * ```
   * const [message] = jdunpack<[string]>(buf, "s")
   * ```
   */
  LoggerCmd[LoggerCmd["Debug"] = 128] = "Debug";
  /**
   * Argument: message string (bytes). Report a message.
   *
   * ```
   * const [message] = jdunpack<[string]>(buf, "s")
   * ```
   */

  LoggerCmd[LoggerCmd["Log"] = 129] = "Log";
  /**
   * Argument: message string (bytes). Report a message.
   *
   * ```
   * const [message] = jdunpack<[string]>(buf, "s")
   * ```
   */

  LoggerCmd[LoggerCmd["Warn"] = 130] = "Warn";
  /**
   * Argument: message string (bytes). Report a message.
   *
   * ```
   * const [message] = jdunpack<[string]>(buf, "s")
   * ```
   */

  LoggerCmd[LoggerCmd["Error"] = 131] = "Error";
})(exports.LoggerCmd || (exports.LoggerCmd = {})); // Service: Magnetometer


const SRV_MAGNETOMETER = 0x13029088;
exports.MagnetometerReg = void 0;

(function (MagnetometerReg) {
  /**
   * Indicates the current magnetic field on magnetometer.
   * For reference: `1 mgauss` is `100 nT` (and `1 gauss` is `100 000 nT`).
   *
   * ```
   * const [x, y, z] = jdunpack<[number, number, number]>(buf, "i32 i32 i32")
   * ```
   */
  MagnetometerReg[MagnetometerReg["Forces"] = 257] = "Forces";
  /**
   * Read-only nT int32_t. Error on the readings.
   *
   * ```
   * const [forcesError] = jdunpack<[number]>(buf, "i32")
   * ```
   */

  MagnetometerReg[MagnetometerReg["ForcesError"] = 262] = "ForcesError";
})(exports.MagnetometerReg || (exports.MagnetometerReg = {}));

exports.MagnetometerCmd = void 0;

(function (MagnetometerCmd) {
  /**
   * No args. Forces a calibration sequence where the user/device
   * might have to rotate to be calibrated.
   */
  MagnetometerCmd[MagnetometerCmd["Calibrate"] = 2] = "Calibrate";
})(exports.MagnetometerCmd || (exports.MagnetometerCmd = {})); // Service: Matrix Keypad


const SRV_MATRIX_KEYPAD = 0x13062dc8;
exports.MatrixKeypadVariant = void 0;

(function (MatrixKeypadVariant) {
  MatrixKeypadVariant[MatrixKeypadVariant["Membrane"] = 1] = "Membrane";
  MatrixKeypadVariant[MatrixKeypadVariant["Keyboard"] = 2] = "Keyboard";
  MatrixKeypadVariant[MatrixKeypadVariant["Elastomer"] = 3] = "Elastomer";
  MatrixKeypadVariant[MatrixKeypadVariant["ElastomerLEDPixel"] = 4] = "ElastomerLEDPixel";
})(exports.MatrixKeypadVariant || (exports.MatrixKeypadVariant = {}));

exports.MatrixKeypadReg = void 0;

(function (MatrixKeypadReg) {
  /**
   * Read-only. The coordinate of the button currently pressed. Keys are zero-indexed from left to right, top to bottom:
   * ``row = index / columns``, ``column = index % columns``.
   *
   * ```
   * const [index] = jdunpack<[number[]]>(buf, "u8[]")
   * ```
   */
  MatrixKeypadReg[MatrixKeypadReg["Pressed"] = 257] = "Pressed";
  /**
   * Constant # uint8_t. Number of rows in the matrix
   *
   * ```
   * const [rows] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  MatrixKeypadReg[MatrixKeypadReg["Rows"] = 384] = "Rows";
  /**
   * Constant # uint8_t. Number of columns in the matrix
   *
   * ```
   * const [columns] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  MatrixKeypadReg[MatrixKeypadReg["Columns"] = 385] = "Columns";
  /**
   * Constant. The characters printed on the keys if any, in indexing sequence.
   *
   * ```
   * const [label] = jdunpack<[string[]]>(buf, "z[]")
   * ```
   */

  MatrixKeypadReg[MatrixKeypadReg["Labels"] = 386] = "Labels";
  /**
   * Constant Variant (uint8_t). The type of physical keypad. If the variant is ``ElastomerLEDPixel``
   * and the next service on the device is a ``LEDPixel`` service, it is considered
   * as the service controlling the LED pixel on the keypad.
   *
   * ```
   * const [variant] = jdunpack<[MatrixKeypadVariant]>(buf, "u8")
   * ```
   */

  MatrixKeypadReg[MatrixKeypadReg["Variant"] = 263] = "Variant";
})(exports.MatrixKeypadReg || (exports.MatrixKeypadReg = {}));

exports.MatrixKeypadEvent = void 0;

(function (MatrixKeypadEvent) {
  /**
   * Argument: uint8_t. Emitted when a key, at the given index, goes from inactive (`pressed == 0`) to active.
   *
   * ```
   * const [down] = jdunpack<[number]>(buf, "u8")
   * ```
   */
  MatrixKeypadEvent[MatrixKeypadEvent["Down"] = 1] = "Down";
  /**
   * Argument: uint8_t. Emitted when a key, at the given index, goes from active (`pressed == 1`) to inactive.
   *
   * ```
   * const [up] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  MatrixKeypadEvent[MatrixKeypadEvent["Up"] = 2] = "Up";
  /**
   * Argument: uint8_t. Emitted together with `up` when the press time was not longer than 500ms.
   *
   * ```
   * const [click] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  MatrixKeypadEvent[MatrixKeypadEvent["Click"] = 128] = "Click";
  /**
   * Argument: uint8_t. Emitted together with `up` when the press time was more than 500ms.
   *
   * ```
   * const [longClick] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  MatrixKeypadEvent[MatrixKeypadEvent["LongClick"] = 129] = "LongClick";
})(exports.MatrixKeypadEvent || (exports.MatrixKeypadEvent = {})); // Service: Microphone


const SRV_MICROPHONE = 0x113dac86;
exports.MicrophoneCmd = void 0;

(function (MicrophoneCmd) {
  /**
   * The samples will be streamed back over the `samples` pipe.
   * If `num_samples` is `0`, streaming will only stop when the pipe is closed.
   * Otherwise the specified number of samples is streamed.
   * Samples are sent as `i16`.
   *
   * ```
   * const [samples, numSamples] = jdunpack<[Uint8Array, number]>(buf, "b[12] u32")
   * ```
   */
  MicrophoneCmd[MicrophoneCmd["Sample"] = 129] = "Sample";
})(exports.MicrophoneCmd || (exports.MicrophoneCmd = {}));

exports.MicrophoneReg = void 0;

(function (MicrophoneReg) {
  /**
   * Read-write μs uint32_t. Get or set microphone sampling period.
   * Sampling rate is `1_000_000 / sampling_period Hz`.
   *
   * ```
   * const [samplingPeriod] = jdunpack<[number]>(buf, "u32")
   * ```
   */
  MicrophoneReg[MicrophoneReg["SamplingPeriod"] = 128] = "SamplingPeriod";
})(exports.MicrophoneReg || (exports.MicrophoneReg = {})); // Service: MIDI output


const SRV_MIDI_OUTPUT = 0x1a848cd7;
exports.MidiOutputReg = void 0;

(function (MidiOutputReg) {
  /**
   * Read-write bool (uint8_t). Opens or closes the port to the MIDI device
   *
   * ```
   * const [enabled] = jdunpack<[number]>(buf, "u8")
   * ```
   */
  MidiOutputReg[MidiOutputReg["Enabled"] = 1] = "Enabled";
})(exports.MidiOutputReg || (exports.MidiOutputReg = {}));

exports.MidiOutputCmd = void 0;

(function (MidiOutputCmd) {
  /**
   * No args. Clears any pending send data that has not yet been sent from the MIDIOutput's queue.
   */
  MidiOutputCmd[MidiOutputCmd["Clear"] = 128] = "Clear";
  /**
   * Argument: data bytes. Enqueues the message to be sent to the corresponding MIDI port
   *
   * ```
   * const [data] = jdunpack<[Uint8Array]>(buf, "b")
   * ```
   */

  MidiOutputCmd[MidiOutputCmd["Send"] = 129] = "Send";
})(exports.MidiOutputCmd || (exports.MidiOutputCmd = {})); // Service: Model Runner


const SRV_MODEL_RUNNER = 0x140f9a78;
exports.ModelRunnerModelFormat = void 0;

(function (ModelRunnerModelFormat) {
  ModelRunnerModelFormat[ModelRunnerModelFormat["TFLite"] = 860636756] = "TFLite";
  ModelRunnerModelFormat[ModelRunnerModelFormat["ML4F"] = 809963362] = "ML4F";
  ModelRunnerModelFormat[ModelRunnerModelFormat["EdgeImpulseCompiled"] = 810961221] = "EdgeImpulseCompiled";
})(exports.ModelRunnerModelFormat || (exports.ModelRunnerModelFormat = {}));

exports.ModelRunnerCmd = void 0;

(function (ModelRunnerCmd) {
  /**
   * Argument: model_size B uint32_t. Open pipe for streaming in the model. The size of the model has to be declared upfront.
   * The model is streamed over regular pipe data packets.
   * The format supported by this instance of the service is specified in `format` register.
   * When the pipe is closed, the model is written all into flash, and the device running the service may reset.
   *
   * ```
   * const [modelSize] = jdunpack<[number]>(buf, "u32")
   * ```
   */
  ModelRunnerCmd[ModelRunnerCmd["SetModel"] = 128] = "SetModel";
  /**
   * report SetModel
   * ```
   * const [modelPort] = jdunpack<[number]>(buf, "u16")
   * ```
   */

  /**
   * Argument: outputs pipe (bytes). Open channel that can be used to manually invoke the model. When enough data is sent over the `inputs` pipe, the model is invoked,
   * and results are send over the `outputs` pipe.
   *
   * ```
   * const [outputs] = jdunpack<[Uint8Array]>(buf, "b[12]")
   * ```
   */

  ModelRunnerCmd[ModelRunnerCmd["Predict"] = 129] = "Predict";
  /**
   * report Predict
   * ```
   * const [inputs] = jdunpack<[number]>(buf, "u16")
   * ```
   */
})(exports.ModelRunnerCmd || (exports.ModelRunnerCmd = {}));

exports.ModelRunnerReg = void 0;

(function (ModelRunnerReg) {
  /**
   * Read-write uint16_t. When register contains `N > 0`, run the model automatically every time new `N` samples are collected.
   * Model may be run less often if it takes longer to run than `N * sampling_interval`.
   * The `outputs` register will stream its value after each run.
   * This register is not stored in flash.
   *
   * ```
   * const [autoInvokeEvery] = jdunpack<[number]>(buf, "u16")
   * ```
   */
  ModelRunnerReg[ModelRunnerReg["AutoInvokeEvery"] = 128] = "AutoInvokeEvery";
  /**
   * Read-only. Results of last model invocation as `float32` array.
   *
   * ```
   * const [output] = jdunpack<[number[]]>(buf, "f32[]")
   * ```
   */

  ModelRunnerReg[ModelRunnerReg["Outputs"] = 257] = "Outputs";
  /**
   * Read-only. The shape of the input tensor.
   *
   * ```
   * const [dimension] = jdunpack<[number[]]>(buf, "u16[]")
   * ```
   */

  ModelRunnerReg[ModelRunnerReg["InputShape"] = 384] = "InputShape";
  /**
   * Read-only. The shape of the output tensor.
   *
   * ```
   * const [dimension] = jdunpack<[number[]]>(buf, "u16[]")
   * ```
   */

  ModelRunnerReg[ModelRunnerReg["OutputShape"] = 385] = "OutputShape";
  /**
   * Read-only μs uint32_t. The time consumed in last model execution.
   *
   * ```
   * const [lastRunTime] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  ModelRunnerReg[ModelRunnerReg["LastRunTime"] = 386] = "LastRunTime";
  /**
   * Read-only B uint32_t. Number of RAM bytes allocated for model execution.
   *
   * ```
   * const [allocatedArenaSize] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  ModelRunnerReg[ModelRunnerReg["AllocatedArenaSize"] = 387] = "AllocatedArenaSize";
  /**
   * Read-only B uint32_t. The size of the model in bytes.
   *
   * ```
   * const [modelSize] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  ModelRunnerReg[ModelRunnerReg["ModelSize"] = 388] = "ModelSize";
  /**
   * Read-only string (bytes). Textual description of last error when running or loading model (if any).
   *
   * ```
   * const [lastError] = jdunpack<[string]>(buf, "s")
   * ```
   */

  ModelRunnerReg[ModelRunnerReg["LastError"] = 389] = "LastError";
  /**
   * Constant ModelFormat (uint32_t). The type of ML models supported by this service.
   * `TFLite` is flatbuffer `.tflite` file.
   * `ML4F` is compiled machine code model for Cortex-M4F.
   * The format is typically present as first or second little endian word of model file.
   *
   * ```
   * const [format] = jdunpack<[ModelRunnerModelFormat]>(buf, "u32")
   * ```
   */

  ModelRunnerReg[ModelRunnerReg["Format"] = 390] = "Format";
  /**
   * Constant uint32_t. A version number for the format.
   *
   * ```
   * const [formatVersion] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  ModelRunnerReg[ModelRunnerReg["FormatVersion"] = 391] = "FormatVersion";
  /**
   * Constant bool (uint8_t). If present and true this service can run models independently of other
   * instances of this service on the device.
   *
   * ```
   * const [parallel] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  ModelRunnerReg[ModelRunnerReg["Parallel"] = 392] = "Parallel";
})(exports.ModelRunnerReg || (exports.ModelRunnerReg = {})); // Service: Motion


const SRV_MOTION = 0x1179a749;
exports.MotionVariant = void 0;

(function (MotionVariant) {
  MotionVariant[MotionVariant["PIR"] = 1] = "PIR";
})(exports.MotionVariant || (exports.MotionVariant = {}));

exports.MotionReg = void 0;

(function (MotionReg) {
  /**
   * Read-only bool (uint8_t). Reports is movement is currently detected by the sensor.
   *
   * ```
   * const [moving] = jdunpack<[number]>(buf, "u8")
   * ```
   */
  MotionReg[MotionReg["Moving"] = 257] = "Moving";
  /**
   * Constant m u16.16 (uint32_t). Maximum distance where objects can be detected.
   *
   * ```
   * const [maxDistance] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */

  MotionReg[MotionReg["MaxDistance"] = 384] = "MaxDistance";
  /**
   * Constant ° uint16_t. Opening of the field of view
   *
   * ```
   * const [angle] = jdunpack<[number]>(buf, "u16")
   * ```
   */

  MotionReg[MotionReg["Angle"] = 385] = "Angle";
  /**
   * Constant Variant (uint8_t). Type of physical sensor
   *
   * ```
   * const [variant] = jdunpack<[MotionVariant]>(buf, "u8")
   * ```
   */

  MotionReg[MotionReg["Variant"] = 263] = "Variant";
})(exports.MotionReg || (exports.MotionReg = {}));

exports.MotionEvent = void 0;

(function (MotionEvent) {
  /**
   * A movement was detected.
   */
  MotionEvent[MotionEvent["Movement"] = 1] = "Movement";
})(exports.MotionEvent || (exports.MotionEvent = {})); // Service: Motor


const SRV_MOTOR = 0x17004cd8;
exports.MotorReg = void 0;

(function (MotorReg) {
  /**
   * Read-write ratio i1.15 (int16_t). PWM duty cycle of the motor. Use negative/positive values to run the motor forwards and backwards.
   * Positive is recommended to be clockwise rotation and negative counterclockwise. A duty of ``0``
   * while ``enabled`` acts as brake.
   *
   * ```
   * const [duty] = jdunpack<[number]>(buf, "i1.15")
   * ```
   */
  MotorReg[MotorReg["Duty"] = 2] = "Duty";
  /**
   * Read-write bool (uint8_t). Turn the power to the motor on/off.
   *
   * ```
   * const [enabled] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  MotorReg[MotorReg["Enabled"] = 1] = "Enabled";
  /**
   * Constant kg/cm u16.16 (uint32_t). Torque required to produce the rated power of an electrical motor at load speed.
   *
   * ```
   * const [loadTorque] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */

  MotorReg[MotorReg["LoadTorque"] = 384] = "LoadTorque";
  /**
   * Constant rpm u16.16 (uint32_t). Revolutions per minute of the motor under full load.
   *
   * ```
   * const [loadSpeed] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */

  MotorReg[MotorReg["LoadSpeed"] = 385] = "LoadSpeed";
})(exports.MotorReg || (exports.MotorReg = {})); // Service: Multitouch


const SRV_MULTITOUCH = 0x18d55e2b;
exports.MultitouchReg = void 0;

(function (MultitouchReg) {
  /**
   * Read-only. Capacitance of channels. The capacitance is continuously calibrated, and a value of `0` indicates
   * no touch, wheres a value of around `100` or more indicates touch.
   * It's best to ignore this (unless debugging), and use events.
   *
   * ```
   * const [capacitance] = jdunpack<[number[]]>(buf, "i32[]")
   * ```
   */
  MultitouchReg[MultitouchReg["Capacity"] = 257] = "Capacity";
})(exports.MultitouchReg || (exports.MultitouchReg = {}));

exports.MultitouchEvent = void 0;

(function (MultitouchEvent) {
  /**
   * Argument: channel uint32_t. Emitted when an input is touched.
   *
   * ```
   * const [channel] = jdunpack<[number]>(buf, "u32")
   * ```
   */
  MultitouchEvent[MultitouchEvent["Touch"] = 1] = "Touch";
  /**
   * Argument: channel uint32_t. Emitted when an input is no longer touched.
   *
   * ```
   * const [channel] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  MultitouchEvent[MultitouchEvent["Release"] = 2] = "Release";
  /**
   * Argument: channel uint32_t. Emitted when an input is briefly touched. TODO Not implemented.
   *
   * ```
   * const [channel] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  MultitouchEvent[MultitouchEvent["Tap"] = 128] = "Tap";
  /**
   * Argument: channel uint32_t. Emitted when an input is touched for longer than 500ms. TODO Not implemented.
   *
   * ```
   * const [channel] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  MultitouchEvent[MultitouchEvent["LongPress"] = 129] = "LongPress";
  /**
   * Emitted when input channels are successively touched in order of increasing channel numbers.
   */

  MultitouchEvent[MultitouchEvent["SwipePos"] = 144] = "SwipePos";
  /**
   * Emitted when input channels are successively touched in order of decreasing channel numbers.
   */

  MultitouchEvent[MultitouchEvent["SwipeNeg"] = 145] = "SwipeNeg";
})(exports.MultitouchEvent || (exports.MultitouchEvent = {})); // Service: Potentiometer


const SRV_POTENTIOMETER = 0x1f274746;
exports.PotentiometerVariant = void 0;

(function (PotentiometerVariant) {
  PotentiometerVariant[PotentiometerVariant["Slider"] = 1] = "Slider";
  PotentiometerVariant[PotentiometerVariant["Rotary"] = 2] = "Rotary";
})(exports.PotentiometerVariant || (exports.PotentiometerVariant = {}));

exports.PotentiometerReg = void 0;

(function (PotentiometerReg) {
  /**
   * Read-only ratio u0.16 (uint16_t). The relative position of the slider.
   *
   * ```
   * const [position] = jdunpack<[number]>(buf, "u0.16")
   * ```
   */
  PotentiometerReg[PotentiometerReg["Position"] = 257] = "Position";
  /**
   * Constant Variant (uint8_t). Specifies the physical layout of the potentiometer.
   *
   * ```
   * const [variant] = jdunpack<[PotentiometerVariant]>(buf, "u8")
   * ```
   */

  PotentiometerReg[PotentiometerReg["Variant"] = 263] = "Variant";
})(exports.PotentiometerReg || (exports.PotentiometerReg = {})); // Service: Power


const SRV_POWER = 0x1fa4c95a;
exports.PowerPowerStatus = void 0;

(function (PowerPowerStatus) {
  PowerPowerStatus[PowerPowerStatus["Disallowed"] = 0] = "Disallowed";
  PowerPowerStatus[PowerPowerStatus["Powering"] = 1] = "Powering";
  PowerPowerStatus[PowerPowerStatus["Overload"] = 2] = "Overload";
  PowerPowerStatus[PowerPowerStatus["Overprovision"] = 3] = "Overprovision";
})(exports.PowerPowerStatus || (exports.PowerPowerStatus = {}));

exports.PowerReg = void 0;

(function (PowerReg) {
  /**
   * Read-write bool (uint8_t). Can be used to completely disable the service.
   * When allowed, the service may still not be providing power, see
   * `power_status` for the actual current state.
   *
   * ```
   * const [allowed] = jdunpack<[number]>(buf, "u8")
   * ```
   */
  PowerReg[PowerReg["Allowed"] = 1] = "Allowed";
  /**
   * Read-write mA uint16_t. Limit the power provided by the service. The actual maximum limit will depend on hardware.
   * This field may be read-only in some implementations - you should read it back after setting.
   *
   * ```
   * const [maxPower] = jdunpack<[number]>(buf, "u16")
   * ```
   */

  PowerReg[PowerReg["MaxPower"] = 7] = "MaxPower";
  /**
   * Read-only PowerStatus (uint8_t). Indicates whether the power provider is currently providing power (`Powering` state), and if not, why not.
   * `Overprovision` means there was another power provider, and we stopped not to overprovision the bus.
   *
   * ```
   * const [powerStatus] = jdunpack<[PowerPowerStatus]>(buf, "u8")
   * ```
   */

  PowerReg[PowerReg["PowerStatus"] = 385] = "PowerStatus";
  /**
   * Read-only mA uint16_t. Present current draw from the bus.
   *
   * ```
   * const [currentDraw] = jdunpack<[number]>(buf, "u16")
   * ```
   */

  PowerReg[PowerReg["CurrentDraw"] = 257] = "CurrentDraw";
  /**
   * Read-only mV uint16_t. Voltage on input.
   *
   * ```
   * const [batteryVoltage] = jdunpack<[number]>(buf, "u16")
   * ```
   */

  PowerReg[PowerReg["BatteryVoltage"] = 384] = "BatteryVoltage";
  /**
   * Read-only ratio u0.16 (uint16_t). Fraction of charge in the battery.
   *
   * ```
   * const [batteryCharge] = jdunpack<[number]>(buf, "u0.16")
   * ```
   */

  PowerReg[PowerReg["BatteryCharge"] = 386] = "BatteryCharge";
  /**
   * Constant mWh uint32_t. Energy that can be delivered to the bus when battery is fully charged.
   * This excludes conversion overheads if any.
   *
   * ```
   * const [batteryCapacity] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  PowerReg[PowerReg["BatteryCapacity"] = 387] = "BatteryCapacity";
  /**
   * Read-write ms uint16_t. Many USB power packs need current to be drawn from time to time to prevent shutdown.
   * This regulates how often and for how long such current is drawn.
   * Typically a 1/8W 22 ohm resistor is used as load. This limits the duty cycle to 10%.
   *
   * ```
   * const [keepOnPulseDuration] = jdunpack<[number]>(buf, "u16")
   * ```
   */

  PowerReg[PowerReg["KeepOnPulseDuration"] = 128] = "KeepOnPulseDuration";
  /**
   * Read-write ms uint16_t. Many USB power packs need current to be drawn from time to time to prevent shutdown.
   * This regulates how often and for how long such current is drawn.
   * Typically a 1/8W 22 ohm resistor is used as load. This limits the duty cycle to 10%.
   *
   * ```
   * const [keepOnPulsePeriod] = jdunpack<[number]>(buf, "u16")
   * ```
   */

  PowerReg[PowerReg["KeepOnPulsePeriod"] = 129] = "KeepOnPulsePeriod";
})(exports.PowerReg || (exports.PowerReg = {}));

exports.PowerCmd = void 0;

(function (PowerCmd) {
  /**
   * No args. Sent by the power service periodically, as broadcast.
   */
  PowerCmd[PowerCmd["Shutdown"] = 128] = "Shutdown";
})(exports.PowerCmd || (exports.PowerCmd = {}));

exports.PowerEvent = void 0;

(function (PowerEvent) {
  /**
   * Argument: power_status PowerStatus (uint8_t). Emitted whenever `power_status` changes.
   *
   * ```
   * const [powerStatus] = jdunpack<[PowerPowerStatus]>(buf, "u8")
   * ```
   */
  PowerEvent[PowerEvent["PowerStatusChanged"] = 3] = "PowerStatusChanged";
})(exports.PowerEvent || (exports.PowerEvent = {})); // Service: Pressure Button


const SRV_PRESSURE_BUTTON = 0x281740c3;
exports.PressureButtonReg = void 0;

(function (PressureButtonReg) {
  /**
   * Read-write ratio u0.16 (uint16_t). Indicates the threshold for ``up`` events.
   *
   * ```
   * const [threshold] = jdunpack<[number]>(buf, "u0.16")
   * ```
   */
  PressureButtonReg[PressureButtonReg["Threshold"] = 6] = "Threshold";
})(exports.PressureButtonReg || (exports.PressureButtonReg = {})); // Service: Protocol Test


const SRV_PROTO_TEST = 0x16c7466a;
exports.ProtoTestReg = void 0;

(function (ProtoTestReg) {
  /**
   * Read-write bool (uint8_t). A read write bool register.
   *
   * ```
   * const [rwBool] = jdunpack<[number]>(buf, "u8")
   * ```
   */
  ProtoTestReg[ProtoTestReg["RwBool"] = 129] = "RwBool";
  /**
   * Read-only bool (uint8_t). A read only bool register. Mirrors rw_bool.
   *
   * ```
   * const [roBool] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  ProtoTestReg[ProtoTestReg["RoBool"] = 385] = "RoBool";
  /**
   * Read-write uint32_t. A read write u32 register.
   *
   * ```
   * const [rwU32] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  ProtoTestReg[ProtoTestReg["RwU32"] = 130] = "RwU32";
  /**
   * Read-only uint32_t. A read only u32 register.. Mirrors rw_u32.
   *
   * ```
   * const [roU32] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  ProtoTestReg[ProtoTestReg["RoU32"] = 386] = "RoU32";
  /**
   * Read-write int32_t. A read write i32 register.
   *
   * ```
   * const [rwI32] = jdunpack<[number]>(buf, "i32")
   * ```
   */

  ProtoTestReg[ProtoTestReg["RwI32"] = 131] = "RwI32";
  /**
   * Read-only int32_t. A read only i32 register.. Mirrors rw_i32.
   *
   * ```
   * const [roI32] = jdunpack<[number]>(buf, "i32")
   * ```
   */

  ProtoTestReg[ProtoTestReg["RoI32"] = 387] = "RoI32";
  /**
   * Read-write string (bytes). A read write string register.
   *
   * ```
   * const [rwString] = jdunpack<[string]>(buf, "s")
   * ```
   */

  ProtoTestReg[ProtoTestReg["RwString"] = 132] = "RwString";
  /**
   * Read-only string (bytes). A read only string register. Mirrors rw_string.
   *
   * ```
   * const [roString] = jdunpack<[string]>(buf, "s")
   * ```
   */

  ProtoTestReg[ProtoTestReg["RoString"] = 388] = "RoString";
  /**
   * Read-write bytes. A read write string register.
   *
   * ```
   * const [rwBytes] = jdunpack<[Uint8Array]>(buf, "b")
   * ```
   */

  ProtoTestReg[ProtoTestReg["RwBytes"] = 133] = "RwBytes";
  /**
   * Read-only bytes. A read only string register. Mirrors ro_bytes.
   *
   * ```
   * const [roBytes] = jdunpack<[Uint8Array]>(buf, "b")
   * ```
   */

  ProtoTestReg[ProtoTestReg["RoBytes"] = 389] = "RoBytes";
  /**
   * A read write i8, u8, u16, i32 register.
   *
   * ```
   * const [i8, u8, u16, i32] = jdunpack<[number, number, number, number]>(buf, "i8 u8 u16 i32")
   * ```
   */

  ProtoTestReg[ProtoTestReg["RwI8U8U16I32"] = 134] = "RwI8U8U16I32";
  /**
   * A read only i8, u8, u16, i32 register.. Mirrors rw_i8_u8_u16_i32.
   *
   * ```
   * const [i8, u8, u16, i32] = jdunpack<[number, number, number, number]>(buf, "i8 u8 u16 i32")
   * ```
   */

  ProtoTestReg[ProtoTestReg["RoI8U8U16I32"] = 390] = "RoI8U8U16I32";
  /**
   * A read write u8, string register.
   *
   * ```
   * const [u8, string] = jdunpack<[number, string]>(buf, "u8 s")
   * ```
   */

  ProtoTestReg[ProtoTestReg["RwU8String"] = 135] = "RwU8String";
  /**
   * A read only u8, string register.. Mirrors rw_u8_string.
   *
   * ```
   * const [u8, string] = jdunpack<[number, string]>(buf, "u8 s")
   * ```
   */

  ProtoTestReg[ProtoTestReg["RoU8String"] = 391] = "RoU8String";
})(exports.ProtoTestReg || (exports.ProtoTestReg = {}));

exports.ProtoTestEvent = void 0;

(function (ProtoTestEvent) {
  /**
   * Argument: bool bool (uint8_t). An event raised when rw_bool is modified
   *
   * ```
   * const [bool] = jdunpack<[number]>(buf, "u8")
   * ```
   */
  ProtoTestEvent[ProtoTestEvent["EBool"] = 129] = "EBool";
  /**
   * Argument: u32 uint32_t. An event raised when rw_u32 is modified
   *
   * ```
   * const [u32] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  ProtoTestEvent[ProtoTestEvent["EU32"] = 130] = "EU32";
  /**
   * Argument: i32 int32_t. An event raised when rw_i32 is modified
   *
   * ```
   * const [i32] = jdunpack<[number]>(buf, "i32")
   * ```
   */

  ProtoTestEvent[ProtoTestEvent["EI32"] = 131] = "EI32";
  /**
   * Argument: string string (bytes). An event raised when rw_string is modified
   *
   * ```
   * const [string] = jdunpack<[string]>(buf, "s")
   * ```
   */

  ProtoTestEvent[ProtoTestEvent["EString"] = 132] = "EString";
  /**
   * Argument: bytes bytes. An event raised when rw_bytes is modified
   *
   * ```
   * const [bytes] = jdunpack<[Uint8Array]>(buf, "b")
   * ```
   */

  ProtoTestEvent[ProtoTestEvent["EBytes"] = 133] = "EBytes";
  /**
   * An event raised when rw_i8_u8_u16_i32 is modified
   *
   * ```
   * const [i8, u8, u16, i32] = jdunpack<[number, number, number, number]>(buf, "i8 u8 u16 i32")
   * ```
   */

  ProtoTestEvent[ProtoTestEvent["EI8U8U16I32"] = 134] = "EI8U8U16I32";
  /**
   * An event raised when rw_u8_string is modified
   *
   * ```
   * const [u8, string] = jdunpack<[number, string]>(buf, "u8 s")
   * ```
   */

  ProtoTestEvent[ProtoTestEvent["EU8String"] = 135] = "EU8String";
})(exports.ProtoTestEvent || (exports.ProtoTestEvent = {}));

exports.ProtoTestCmd = void 0;

(function (ProtoTestCmd) {
  /**
   * Argument: bool bool (uint8_t). A command to set rw_bool.
   *
   * ```
   * const [bool] = jdunpack<[number]>(buf, "u8")
   * ```
   */
  ProtoTestCmd[ProtoTestCmd["CBool"] = 129] = "CBool";
  /**
   * Argument: u32 uint32_t. A command to set rw_u32.
   *
   * ```
   * const [u32] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  ProtoTestCmd[ProtoTestCmd["CU32"] = 130] = "CU32";
  /**
   * Argument: i32 int32_t. A command to set rw_i32.
   *
   * ```
   * const [i32] = jdunpack<[number]>(buf, "i32")
   * ```
   */

  ProtoTestCmd[ProtoTestCmd["CI32"] = 131] = "CI32";
  /**
   * Argument: string string (bytes). A command to set rw_string.
   *
   * ```
   * const [string] = jdunpack<[string]>(buf, "s")
   * ```
   */

  ProtoTestCmd[ProtoTestCmd["CString"] = 132] = "CString";
  /**
   * Argument: bytes bytes. A command to set rw_string.
   *
   * ```
   * const [bytes] = jdunpack<[Uint8Array]>(buf, "b")
   * ```
   */

  ProtoTestCmd[ProtoTestCmd["CBytes"] = 133] = "CBytes";
  /**
   * A command to set rw_bytes.
   *
   * ```
   * const [i8, u8, u16, i32] = jdunpack<[number, number, number, number]>(buf, "i8 u8 u16 i32")
   * ```
   */

  ProtoTestCmd[ProtoTestCmd["CI8U8U16I32"] = 134] = "CI8U8U16I32";
  /**
   * A command to set rw_u8_string.
   *
   * ```
   * const [u8, string] = jdunpack<[number, string]>(buf, "u8 s")
   * ```
   */

  ProtoTestCmd[ProtoTestCmd["CU8String"] = 135] = "CU8String";
  /**
   * Argument: p_bytes pipe (bytes). A command to read the content of rw_bytes, byte per byte, as a pipe.
   *
   * ```
   * const [pBytes] = jdunpack<[Uint8Array]>(buf, "b[12]")
   * ```
   */

  ProtoTestCmd[ProtoTestCmd["CReportPipe"] = 144] = "CReportPipe";
})(exports.ProtoTestCmd || (exports.ProtoTestCmd = {}));
/**
 * pipe_report PBytes
 * ```
 * const [byte] = jdunpack<[number]>(buf, "u8")
 * ```
 */
// Service: Pulse Oximeter


const SRV_PULSE_OXIMETER = 0x10bb4eb6;
exports.PulseOximeterReg = void 0;

(function (PulseOximeterReg) {
  /**
   * Read-only % u8.8 (uint16_t). The estimated oxygen level in blood.
   *
   * ```
   * const [oxygen] = jdunpack<[number]>(buf, "u8.8")
   * ```
   */
  PulseOximeterReg[PulseOximeterReg["Oxygen"] = 257] = "Oxygen";
  /**
   * Read-only % u8.8 (uint16_t). The estimated error on the reported sensor data.
   *
   * ```
   * const [oxygenError] = jdunpack<[number]>(buf, "u8.8")
   * ```
   */

  PulseOximeterReg[PulseOximeterReg["OxygenError"] = 262] = "OxygenError";
})(exports.PulseOximeterReg || (exports.PulseOximeterReg = {})); // Service: Rain gauge


const SRV_RAIN_GAUGE = 0x13734c95;
exports.RainGaugeReg = void 0;

(function (RainGaugeReg) {
  /**
   * Read-only mm u16.16 (uint32_t). Total precipitation recorded so far.
   *
   * ```
   * const [precipitation] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */
  RainGaugeReg[RainGaugeReg["Precipitation"] = 257] = "Precipitation";
  /**
   * Constant mm u16.16 (uint32_t). Typically the amount of rain needed for tipping the bucket.
   *
   * ```
   * const [precipitationPrecision] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */

  RainGaugeReg[RainGaugeReg["PrecipitationPrecision"] = 264] = "PrecipitationPrecision";
})(exports.RainGaugeReg || (exports.RainGaugeReg = {})); // Service: Real time clock


const SRV_REAL_TIME_CLOCK = 0x1a8b1a28;
exports.RealTimeClockVariant = void 0;

(function (RealTimeClockVariant) {
  RealTimeClockVariant[RealTimeClockVariant["Computer"] = 1] = "Computer";
  RealTimeClockVariant[RealTimeClockVariant["Crystal"] = 2] = "Crystal";
  RealTimeClockVariant[RealTimeClockVariant["Cuckoo"] = 3] = "Cuckoo";
})(exports.RealTimeClockVariant || (exports.RealTimeClockVariant = {}));

exports.RealTimeClockReg = void 0;

(function (RealTimeClockReg) {
  /**
   * Current time in 24h representation.
   * * ``day_of_month`` is day of the month, starting at ``1``
   * * ``day_of_week`` is day of the week, starting at ``1`` as monday
   * Default streaming period is 1 second.
   *
   * ```
   * const [year, month, dayOfMonth, dayOfWeek, hour, min, sec] = jdunpack<[number, number, number, number, number, number, number]>(buf, "u16 u8 u8 u8 u8 u8 u8")
   * ```
   */
  RealTimeClockReg[RealTimeClockReg["LocalTime"] = 257] = "LocalTime";
  /**
   * Read-only s u16.16 (uint32_t). Time drift since the last call to the ``set_time`` command.
   *
   * ```
   * const [error] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */

  RealTimeClockReg[RealTimeClockReg["Error"] = 384] = "Error";
  /**
   * Constant ppm u16.16 (uint32_t). Error on the clock, in parts per million of seconds.
   *
   * ```
   * const [precision] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */

  RealTimeClockReg[RealTimeClockReg["Precision"] = 385] = "Precision";
  /**
   * Constant Variant (uint8_t). The type of physical clock used by the sensor.
   *
   * ```
   * const [variant] = jdunpack<[RealTimeClockVariant]>(buf, "u8")
   * ```
   */

  RealTimeClockReg[RealTimeClockReg["Variant"] = 263] = "Variant";
})(exports.RealTimeClockReg || (exports.RealTimeClockReg = {}));

exports.RealTimeClockCmd = void 0;

(function (RealTimeClockCmd) {
  /**
   * Sets the current time and resets the error.
   *
   * ```
   * const [year, month, dayOfMonth, dayOfWeek, hour, min, sec] = jdunpack<[number, number, number, number, number, number, number]>(buf, "u16 u8 u8 u8 u8 u8 u8")
   * ```
   */
  RealTimeClockCmd[RealTimeClockCmd["SetTime"] = 128] = "SetTime";
})(exports.RealTimeClockCmd || (exports.RealTimeClockCmd = {})); // Service: Reflected light


const SRV_REFLECTED_LIGHT = 0x126c4cb2;
exports.ReflectedLightVariant = void 0;

(function (ReflectedLightVariant) {
  ReflectedLightVariant[ReflectedLightVariant["InfraredDigital"] = 1] = "InfraredDigital";
  ReflectedLightVariant[ReflectedLightVariant["InfraredAnalog"] = 2] = "InfraredAnalog";
})(exports.ReflectedLightVariant || (exports.ReflectedLightVariant = {}));

exports.ReflectedLightReg = void 0;

(function (ReflectedLightReg) {
  /**
   * Read-only ratio u0.16 (uint16_t). Reports the reflected brightness. It may be a digital value or, for some sensor, analog value.
   *
   * ```
   * const [brightness] = jdunpack<[number]>(buf, "u0.16")
   * ```
   */
  ReflectedLightReg[ReflectedLightReg["Brightness"] = 257] = "Brightness";
  /**
   * Constant Variant (uint8_t). Type of physical sensor used
   *
   * ```
   * const [variant] = jdunpack<[ReflectedLightVariant]>(buf, "u8")
   * ```
   */

  ReflectedLightReg[ReflectedLightReg["Variant"] = 263] = "Variant";
})(exports.ReflectedLightReg || (exports.ReflectedLightReg = {}));

exports.ReflectedLightEvent = void 0;

(function (ReflectedLightEvent) {
  /**
   * The sensor detected a transition from light to dark
   */
  ReflectedLightEvent[ReflectedLightEvent["Dark"] = 2] = "Dark";
  /**
   * The sensor detected a transition from dark to light
   */

  ReflectedLightEvent[ReflectedLightEvent["Light"] = 1] = "Light";
})(exports.ReflectedLightEvent || (exports.ReflectedLightEvent = {})); // Service: Relay


const SRV_RELAY = 0x183fe656;
exports.RelayVariant = void 0;

(function (RelayVariant) {
  RelayVariant[RelayVariant["Electromechanical"] = 1] = "Electromechanical";
  RelayVariant[RelayVariant["SolidState"] = 2] = "SolidState";
  RelayVariant[RelayVariant["Reed"] = 3] = "Reed";
})(exports.RelayVariant || (exports.RelayVariant = {}));

exports.RelayReg = void 0;

(function (RelayReg) {
  /**
   * Read-write bool (uint8_t). Indicates whether the relay circuit is currently energized (closed) or not.
   *
   * ```
   * const [closed] = jdunpack<[number]>(buf, "u8")
   * ```
   */
  RelayReg[RelayReg["Closed"] = 1] = "Closed";
  /**
   * Constant Variant (uint8_t). Describes the type of relay used.
   *
   * ```
   * const [variant] = jdunpack<[RelayVariant]>(buf, "u8")
   * ```
   */

  RelayReg[RelayReg["Variant"] = 263] = "Variant";
  /**
   * Constant mA uint32_t. Maximum switching current for a resistive load.
   *
   * ```
   * const [maxSwitchingCurrent] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  RelayReg[RelayReg["MaxSwitchingCurrent"] = 384] = "MaxSwitchingCurrent";
})(exports.RelayReg || (exports.RelayReg = {}));

exports.RelayEvent = void 0;

(function (RelayEvent) {
  /**
   * Emitted when relay goes from `inactive` to `active` state.
   * Normally open (NO) relays close the circuit when activated.
   */
  RelayEvent[RelayEvent["Active"] = 1] = "Active";
  /**
   * Emitted when relay goes from `active` to `inactive` state.
   * Normally closed (NC) relays open the circuit when activated.
   */

  RelayEvent[RelayEvent["Inactive"] = 2] = "Inactive";
})(exports.RelayEvent || (exports.RelayEvent = {})); // Service: Random Number Generator


const SRV_RNG = 0x1789f0a2;
exports.RngVariant = void 0;

(function (RngVariant) {
  RngVariant[RngVariant["Quantum"] = 1] = "Quantum";
  RngVariant[RngVariant["ADCNoise"] = 2] = "ADCNoise";
  RngVariant[RngVariant["WebCrypto"] = 3] = "WebCrypto";
})(exports.RngVariant || (exports.RngVariant = {}));

exports.RngReg = void 0;

(function (RngReg) {
  /**
   * Read-only bytes. A register that returns a 64 bytes random buffer on every request.
   * This never blocks for a long time. If you need additional random bytes, keep querying the register.
   *
   * ```
   * const [random] = jdunpack<[Uint8Array]>(buf, "b")
   * ```
   */
  RngReg[RngReg["Random"] = 384] = "Random";
  /**
   * Constant Variant (uint8_t). The type of algorithm/technique used to generate the number.
   * `Quantum` refers to dedicated hardware device generating random noise due to quantum effects.
   * `ADCNoise` is the noise from quick readings of analog-digital converter, which reads temperature of the MCU or some floating pin.
   * `WebCrypto` refers is used in simulators, where the source of randomness comes from an advanced operating system.
   *
   * ```
   * const [variant] = jdunpack<[RngVariant]>(buf, "u8")
   * ```
   */

  RngReg[RngReg["Variant"] = 263] = "Variant";
})(exports.RngReg || (exports.RngReg = {})); // Service: Role Manager


const SRV_ROLE_MANAGER = 0x1e4b7e66;
exports.RoleManagerReg = void 0;

(function (RoleManagerReg) {
  /**
   * Read-write bool (uint8_t). Normally, if some roles are unfilled, and there are idle services that can fulfill them,
   * the brain device will assign roles (bind) automatically.
   * Such automatic assignment happens every second or so, and is trying to be smart about
   * co-locating roles that share "host" (part before first slash),
   * as well as reasonably stable assignments.
   * Once user start assigning roles manually using this service, auto-binding should be disabled to avoid confusion.
   *
   * ```
   * const [autoBind] = jdunpack<[number]>(buf, "u8")
   * ```
   */
  RoleManagerReg[RoleManagerReg["AutoBind"] = 128] = "AutoBind";
  /**
   * Read-only bool (uint8_t). Indicates if all required roles have been allocated to devices.
   *
   * ```
   * const [allRolesAllocated] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  RoleManagerReg[RoleManagerReg["AllRolesAllocated"] = 385] = "AllRolesAllocated";
})(exports.RoleManagerReg || (exports.RoleManagerReg = {}));

exports.RoleManagerCmd = void 0;

(function (RoleManagerCmd) {
  /**
   * Get the role corresponding to given device identifer. Returns empty string if unset.
   *
   * ```
   * const [deviceId, serviceIdx] = jdunpack<[Uint8Array, number]>(buf, "b[8] u8")
   * ```
   */
  RoleManagerCmd[RoleManagerCmd["GetRole"] = 128] = "GetRole";
  /**
   * report GetRole
   * ```
   * const [deviceId, serviceIdx, role] = jdunpack<[Uint8Array, number, string]>(buf, "b[8] u8 s")
   * ```
   */

  /**
   * Set role. Can set to empty to remove role binding.
   *
   * ```
   * const [deviceId, serviceIdx, role] = jdunpack<[Uint8Array, number, string]>(buf, "b[8] u8 s")
   * ```
   */

  RoleManagerCmd[RoleManagerCmd["SetRole"] = 129] = "SetRole";
  /**
   * No args. Remove all role bindings.
   */

  RoleManagerCmd[RoleManagerCmd["ClearAllRoles"] = 132] = "ClearAllRoles";
  /**
   * Argument: stored_roles pipe (bytes). Return all roles stored internally.
   *
   * ```
   * const [storedRoles] = jdunpack<[Uint8Array]>(buf, "b[12]")
   * ```
   */

  RoleManagerCmd[RoleManagerCmd["ListStoredRoles"] = 130] = "ListStoredRoles";
  /**
   * Argument: required_roles pipe (bytes). List all roles required by the current program. `device_id` and `service_idx` are `0` if role is unbound.
   *
   * ```
   * const [requiredRoles] = jdunpack<[Uint8Array]>(buf, "b[12]")
   * ```
   */

  RoleManagerCmd[RoleManagerCmd["ListRequiredRoles"] = 131] = "ListRequiredRoles";
})(exports.RoleManagerCmd || (exports.RoleManagerCmd = {}));
/**
 * pipe_report StoredRoles
 * ```
 * const [deviceId, serviceIdx, role] = jdunpack<[Uint8Array, number, string]>(buf, "b[8] u8 s")
 * ```
 */

/**
 * pipe_report RequiredRoles
 * ```
 * const [deviceId, serviceClass, serviceIdx, role] = jdunpack<[Uint8Array, number, number, string]>(buf, "b[8] u32 u8 s")
 * ```
 */


exports.RoleManagerEvent = void 0;

(function (RoleManagerEvent) {
  /**
   * Notifies that role bindings have changed.
   */
  RoleManagerEvent[RoleManagerEvent["Change"] = 3] = "Change";
})(exports.RoleManagerEvent || (exports.RoleManagerEvent = {})); // Service: Rotary encoder


const SRV_ROTARY_ENCODER = 0x10fa29c9;
exports.RotaryEncoderReg = void 0;

(function (RotaryEncoderReg) {
  /**
   * Read-only # int32_t. Upon device reset starts at `0` (regardless of the shaft position).
   * Increases by `1` for a clockwise "click", by `-1` for counter-clockwise.
   *
   * ```
   * const [position] = jdunpack<[number]>(buf, "i32")
   * ```
   */
  RotaryEncoderReg[RotaryEncoderReg["Position"] = 257] = "Position";
  /**
   * Constant # uint16_t. This specifies by how much `position` changes when the crank does 360 degree turn. Typically 12 or 24.
   *
   * ```
   * const [clicksPerTurn] = jdunpack<[number]>(buf, "u16")
   * ```
   */

  RotaryEncoderReg[RotaryEncoderReg["ClicksPerTurn"] = 384] = "ClicksPerTurn";
})(exports.RotaryEncoderReg || (exports.RotaryEncoderReg = {})); // Service: Rover


const SRV_ROVER = 0x19f4d06b;
exports.RoverReg = void 0;

(function (RoverReg) {
  /**
   * The current position and orientation of the robot.
   *
   * ```
   * const [x, y, vx, vy, heading] = jdunpack<[number, number, number, number, number]>(buf, "i16.16 i16.16 i16.16 i16.16 i16.16")
   * ```
   */
  RoverReg[RoverReg["Kinematics"] = 257] = "Kinematics";
})(exports.RoverReg || (exports.RoverReg = {})); // Service: Sensor Aggregator


const SRV_SENSOR_AGGREGATOR = 0x1d90e1c5;
exports.SensorAggregatorSampleType = void 0;

(function (SensorAggregatorSampleType) {
  SensorAggregatorSampleType[SensorAggregatorSampleType["U8"] = 8] = "U8";
  SensorAggregatorSampleType[SensorAggregatorSampleType["I8"] = 136] = "I8";
  SensorAggregatorSampleType[SensorAggregatorSampleType["U16"] = 16] = "U16";
  SensorAggregatorSampleType[SensorAggregatorSampleType["I16"] = 144] = "I16";
  SensorAggregatorSampleType[SensorAggregatorSampleType["U32"] = 32] = "U32";
  SensorAggregatorSampleType[SensorAggregatorSampleType["I32"] = 160] = "I32";
})(exports.SensorAggregatorSampleType || (exports.SensorAggregatorSampleType = {}));

exports.SensorAggregatorReg = void 0;

(function (SensorAggregatorReg) {
  /**
   * Set automatic input collection.
   * These settings are stored in flash.
   *
   * ```
   * const [samplingInterval, samplesInWindow, rest] = jdunpack<[number, number, ([Uint8Array, number, number, number, SensorAggregatorSampleType, number])[]]>(buf, "u16 u16 x[4] r: b[8] u32 u8 u8 u8 i8")
   * const [deviceId, serviceClass, serviceNum, sampleSize, sampleType, sampleShift] = rest[0]
   * ```
   */
  SensorAggregatorReg[SensorAggregatorReg["Inputs"] = 128] = "Inputs";
  /**
   * Read-only uint32_t. Number of input samples collected so far.
   *
   * ```
   * const [numSamples] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  SensorAggregatorReg[SensorAggregatorReg["NumSamples"] = 384] = "NumSamples";
  /**
   * Read-only B uint8_t. Size of a single sample.
   *
   * ```
   * const [sampleSize] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  SensorAggregatorReg[SensorAggregatorReg["SampleSize"] = 385] = "SampleSize";
  /**
   * Read-write # uint32_t. When set to `N`, will stream `N` samples as `current_sample` reading.
   *
   * ```
   * const [streamingSamples] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  SensorAggregatorReg[SensorAggregatorReg["StreamingSamples"] = 129] = "StreamingSamples";
  /**
   * Read-only bytes. Last collected sample.
   *
   * ```
   * const [currentSample] = jdunpack<[Uint8Array]>(buf, "b")
   * ```
   */

  SensorAggregatorReg[SensorAggregatorReg["CurrentSample"] = 257] = "CurrentSample";
})(exports.SensorAggregatorReg || (exports.SensorAggregatorReg = {})); // Service: Servo


const SRV_SERVO = 0x12fc9103;
exports.ServoReg = void 0;

(function (ServoReg) {
  /**
   * Read-write ° i16.16 (int32_t). Specifies the angle of the arm (request).
   *
   * ```
   * const [angle] = jdunpack<[number]>(buf, "i16.16")
   * ```
   */
  ServoReg[ServoReg["Angle"] = 2] = "Angle";
  /**
   * Read-write bool (uint8_t). Turn the power to the servo on/off.
   *
   * ```
   * const [enabled] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  ServoReg[ServoReg["Enabled"] = 1] = "Enabled";
  /**
   * Read-write ° i16.16 (int32_t). Correction applied to the angle to account for the servo arm drift.
   *
   * ```
   * const [offset] = jdunpack<[number]>(buf, "i16.16")
   * ```
   */

  ServoReg[ServoReg["Offset"] = 129] = "Offset";
  /**
   * Constant ° i16.16 (int32_t). Lowest angle that can be set.
   *
   * ```
   * const [minAngle] = jdunpack<[number]>(buf, "i16.16")
   * ```
   */

  ServoReg[ServoReg["MinAngle"] = 272] = "MinAngle";
  /**
   * Read-write μs uint16_t. The length of pulse corresponding to lowest angle.
   *
   * ```
   * const [minPulse] = jdunpack<[number]>(buf, "u16")
   * ```
   */

  ServoReg[ServoReg["MinPulse"] = 131] = "MinPulse";
  /**
   * Constant ° i16.16 (int32_t). Highest angle that can be set.
   *
   * ```
   * const [maxAngle] = jdunpack<[number]>(buf, "i16.16")
   * ```
   */

  ServoReg[ServoReg["MaxAngle"] = 273] = "MaxAngle";
  /**
   * Read-write μs uint16_t. The length of pulse corresponding to highest angle.
   *
   * ```
   * const [maxPulse] = jdunpack<[number]>(buf, "u16")
   * ```
   */

  ServoReg[ServoReg["MaxPulse"] = 133] = "MaxPulse";
  /**
   * Constant kg/cm u16.16 (uint32_t). The servo motor will stop rotating when it is trying to move a ``stall_torque`` weight at a radial distance of ``1.0`` cm.
   *
   * ```
   * const [stallTorque] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */

  ServoReg[ServoReg["StallTorque"] = 384] = "StallTorque";
  /**
   * Constant s/60° u16.16 (uint32_t). Time to move 60°.
   *
   * ```
   * const [responseSpeed] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */

  ServoReg[ServoReg["ResponseSpeed"] = 385] = "ResponseSpeed";
  /**
   * Read-only ° i16.16 (int32_t). The current physical position of the arm.
   *
   * ```
   * const [currentAngle] = jdunpack<[number]>(buf, "i16.16")
   * ```
   */

  ServoReg[ServoReg["CurrentAngle"] = 257] = "CurrentAngle";
})(exports.ServoReg || (exports.ServoReg = {})); // Service: Settings


const SRV_SETTINGS = 0x1107dc4a;
exports.SettingsCmd = void 0;

(function (SettingsCmd) {
  /**
   * Argument: key string (bytes). Get the value of given setting. If no such entry exists, the value returned is empty.
   *
   * ```
   * const [key] = jdunpack<[string]>(buf, "s")
   * ```
   */
  SettingsCmd[SettingsCmd["Get"] = 128] = "Get";
  /**
   * report Get
   * ```
   * const [key, value] = jdunpack<[string, Uint8Array]>(buf, "z b")
   * ```
   */

  /**
   * Set the value of a given setting.
   *
   * ```
   * const [key, value] = jdunpack<[string, Uint8Array]>(buf, "z b")
   * ```
   */

  SettingsCmd[SettingsCmd["Set"] = 129] = "Set";
  /**
   * Argument: key string (bytes). Delete a given setting.
   *
   * ```
   * const [key] = jdunpack<[string]>(buf, "s")
   * ```
   */

  SettingsCmd[SettingsCmd["Delete"] = 132] = "Delete";
  /**
   * Argument: results pipe (bytes). Return keys of all settings.
   *
   * ```
   * const [results] = jdunpack<[Uint8Array]>(buf, "b[12]")
   * ```
   */

  SettingsCmd[SettingsCmd["ListKeys"] = 130] = "ListKeys";
  /**
   * Argument: results pipe (bytes). Return keys and values of all settings.
   *
   * ```
   * const [results] = jdunpack<[Uint8Array]>(buf, "b[12]")
   * ```
   */

  SettingsCmd[SettingsCmd["List"] = 131] = "List";
  /**
   * No args. Clears all keys.
   */

  SettingsCmd[SettingsCmd["Clear"] = 133] = "Clear";
})(exports.SettingsCmd || (exports.SettingsCmd = {}));
/**
 * pipe_report ListedKey
 * ```
 * const [key] = jdunpack<[string]>(buf, "s")
 * ```
 */

/**
 * pipe_report ListedEntry
 * ```
 * const [key, value] = jdunpack<[string, Uint8Array]>(buf, "z b")
 * ```
 */


exports.SettingsEvent = void 0;

(function (SettingsEvent) {
  /**
   * Notifies that some setting have been modified.
   */
  SettingsEvent[SettingsEvent["Change"] = 3] = "Change";
})(exports.SettingsEvent || (exports.SettingsEvent = {})); // Service: 7-segment display


const SRV_SEVEN_SEGMENT_DISPLAY = 0x196158f7;
exports.SevenSegmentDisplayReg = void 0;

(function (SevenSegmentDisplayReg) {
  /**
   * Read-write bytes. Each byte encodes the display status of a digit using,
   * where bit 0 encodes segment `A`, bit 1 encodes segments `B`, ..., bit 6 encodes segments `G`, and bit 7 encodes the decimal point (if present).
   * If incoming ``digits`` data is smaller than `digit_count`, the remaining digits will be cleared.
   * Thus, sending an empty ``digits`` payload clears the screen.
   *
   * ```
   * const [digits] = jdunpack<[Uint8Array]>(buf, "b")
   * ```
   */
  SevenSegmentDisplayReg[SevenSegmentDisplayReg["Digits"] = 2] = "Digits";
  /**
   * Read-write ratio u0.16 (uint16_t). Controls the brightness of the LEDs. ``0`` means off.
   *
   * ```
   * const [brightness] = jdunpack<[number]>(buf, "u0.16")
   * ```
   */

  SevenSegmentDisplayReg[SevenSegmentDisplayReg["Brightness"] = 1] = "Brightness";
  /**
   * Read-write bool (uint8_t). Turn on or off the column LEDs (separating minutes from hours, etc.) in of the segment.
   * If the column LEDs is not supported, the value remains false.
   *
   * ```
   * const [doubleDots] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  SevenSegmentDisplayReg[SevenSegmentDisplayReg["DoubleDots"] = 128] = "DoubleDots";
  /**
   * Constant uint8_t. The number of digits available on the display.
   *
   * ```
   * const [digitCount] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  SevenSegmentDisplayReg[SevenSegmentDisplayReg["DigitCount"] = 384] = "DigitCount";
  /**
   * Constant bool (uint8_t). True if decimal points are available (on all digits).
   *
   * ```
   * const [decimalPoint] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  SevenSegmentDisplayReg[SevenSegmentDisplayReg["DecimalPoint"] = 385] = "DecimalPoint";
})(exports.SevenSegmentDisplayReg || (exports.SevenSegmentDisplayReg = {}));

exports.SevenSegmentDisplayCmd = void 0;

(function (SevenSegmentDisplayCmd) {
  /**
   * Argument: value f64 (uint64_t). Shows the number on the screen using the decimal dot if available.
   */
  SevenSegmentDisplayCmd[SevenSegmentDisplayCmd["SetNumber"] = 128] = "SetNumber";
  /**
   * Argument: text string (bytes). Shows the text on the screen. The client may decide to scroll the text if too long.
   */

  SevenSegmentDisplayCmd[SevenSegmentDisplayCmd["SetText"] = 129] = "SetText";
})(exports.SevenSegmentDisplayCmd || (exports.SevenSegmentDisplayCmd = {})); // Service: Soil moisture


const SRV_SOIL_MOISTURE = 0x1d4aa3b3;
exports.SoilMoistureVariant = void 0;

(function (SoilMoistureVariant) {
  SoilMoistureVariant[SoilMoistureVariant["Resistive"] = 1] = "Resistive";
  SoilMoistureVariant[SoilMoistureVariant["Capacitive"] = 2] = "Capacitive";
})(exports.SoilMoistureVariant || (exports.SoilMoistureVariant = {}));

exports.SoilMoistureReg = void 0;

(function (SoilMoistureReg) {
  /**
   * Read-only ratio u0.16 (uint16_t). Indicates the wetness of the soil, from ``dry`` to ``wet``.
   *
   * ```
   * const [moisture] = jdunpack<[number]>(buf, "u0.16")
   * ```
   */
  SoilMoistureReg[SoilMoistureReg["Moisture"] = 257] = "Moisture";
  /**
   * Constant Variant (uint8_t). Describe the type of physical sensor.
   *
   * ```
   * const [variant] = jdunpack<[SoilMoistureVariant]>(buf, "u8")
   * ```
   */

  SoilMoistureReg[SoilMoistureReg["Variant"] = 263] = "Variant";
})(exports.SoilMoistureReg || (exports.SoilMoistureReg = {})); // Service: Solenoid


const SRV_SOLENOID = 0x171723ca;
exports.SolenoidVariant = void 0;

(function (SolenoidVariant) {
  SolenoidVariant[SolenoidVariant["PushPull"] = 1] = "PushPull";
  SolenoidVariant[SolenoidVariant["Valve"] = 2] = "Valve";
  SolenoidVariant[SolenoidVariant["Latch"] = 3] = "Latch";
})(exports.SolenoidVariant || (exports.SolenoidVariant = {}));

exports.SolenoidReg = void 0;

(function (SolenoidReg) {
  /**
   * Read-write bool (uint8_t). Indicates whether the solenoid is energized and pulled (on) or pushed (off).
   *
   * ```
   * const [pulled] = jdunpack<[number]>(buf, "u8")
   * ```
   */
  SolenoidReg[SolenoidReg["Pulled"] = 1] = "Pulled";
  /**
   * Constant Variant (uint8_t). Describes the type of solenoid used.
   *
   * ```
   * const [variant] = jdunpack<[SolenoidVariant]>(buf, "u8")
   * ```
   */

  SolenoidReg[SolenoidReg["Variant"] = 263] = "Variant";
})(exports.SolenoidReg || (exports.SolenoidReg = {})); // Service: Sound level


const SRV_SOUND_LEVEL = 0x14ad1a5d;
exports.SoundLevelReg = void 0;

(function (SoundLevelReg) {
  /**
   * Read-only ratio u0.16 (uint16_t). The sound level detected by the microphone
   *
   * ```
   * const [soundLevel] = jdunpack<[number]>(buf, "u0.16")
   * ```
   */
  SoundLevelReg[SoundLevelReg["SoundLevel"] = 257] = "SoundLevel";
  /**
   * Read-write bool (uint8_t). Turn on or off the microphone.
   *
   * ```
   * const [enabled] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  SoundLevelReg[SoundLevelReg["Enabled"] = 1] = "Enabled";
  /**
   * Read-write dB int16_t. The minimum power value considered by the sensor.
   * If both ``min_decibels`` and ``max_decibels`` are supported,
   * the volume in deciment can be linearly interpolated between
   * ``[min_decibels, max_decibels]``.
   *
   * ```
   * const [minDecibels] = jdunpack<[number]>(buf, "i16")
   * ```
   */

  SoundLevelReg[SoundLevelReg["MinDecibels"] = 129] = "MinDecibels";
  /**
   * Read-write dB int16_t. The maximum power value considered by the sensor.
   * If both ``min_decibels`` and ``max_decibels`` are supported,
   * the volume in deciment can be linearly interpolated between
   * ``[min_decibels, max_decibels]``.
   *
   * ```
   * const [maxDecibels] = jdunpack<[number]>(buf, "i16")
   * ```
   */

  SoundLevelReg[SoundLevelReg["MaxDecibels"] = 130] = "MaxDecibels";
  /**
   * Read-write ratio u0.16 (uint16_t). The sound level to trigger a loud event.
   *
   * ```
   * const [loudThreshold] = jdunpack<[number]>(buf, "u0.16")
   * ```
   */

  SoundLevelReg[SoundLevelReg["LoudThreshold"] = 6] = "LoudThreshold";
  /**
   * Read-write ratio u0.16 (uint16_t). The sound level to trigger a quiet event.
   *
   * ```
   * const [quietThreshold] = jdunpack<[number]>(buf, "u0.16")
   * ```
   */

  SoundLevelReg[SoundLevelReg["QuietThreshold"] = 5] = "QuietThreshold";
})(exports.SoundLevelReg || (exports.SoundLevelReg = {}));

exports.SoundLevelEvent = void 0;

(function (SoundLevelEvent) {
  /**
   * Raised when a loud sound is detected
   */
  SoundLevelEvent[SoundLevelEvent["Loud"] = 1] = "Loud";
  /**
   * Raised when a period of quietness is detected
   */

  SoundLevelEvent[SoundLevelEvent["Quiet"] = 2] = "Quiet";
})(exports.SoundLevelEvent || (exports.SoundLevelEvent = {})); // Service: Sound player


const SRV_SOUND_PLAYER = 0x1403d338;
exports.SoundPlayerReg = void 0;

(function (SoundPlayerReg) {
  /**
   * Read-write ratio u0.16 (uint16_t). Global volume of the output. ``0`` means completely off. This volume is mixed with each play volumes.
   *
   * ```
   * const [volume] = jdunpack<[number]>(buf, "u0.16")
   * ```
   */
  SoundPlayerReg[SoundPlayerReg["Volume"] = 1] = "Volume";
})(exports.SoundPlayerReg || (exports.SoundPlayerReg = {}));

exports.SoundPlayerCmd = void 0;

(function (SoundPlayerCmd) {
  /**
   * Argument: name string (bytes). Starts playing a sound.
   *
   * ```
   * const [name] = jdunpack<[string]>(buf, "s")
   * ```
   */
  SoundPlayerCmd[SoundPlayerCmd["Play"] = 128] = "Play";
  /**
   * Argument: sounds_port pipe (bytes). Returns the list of sounds available to play.
   *
   * ```
   * const [soundsPort] = jdunpack<[Uint8Array]>(buf, "b[12]")
   * ```
   */

  SoundPlayerCmd[SoundPlayerCmd["ListSounds"] = 129] = "ListSounds";
})(exports.SoundPlayerCmd || (exports.SoundPlayerCmd = {}));
/**
 * pipe_report ListSoundsPipe
 * ```
 * const [duration, name] = jdunpack<[number, string]>(buf, "u32 s")
 * ```
 */
// Service: Sound Spectrum


const SRV_SOUND_SPECTRUM = 0x157abc1e;
exports.SoundSpectrumReg = void 0;

(function (SoundSpectrumReg) {
  /**
   * Read-only bytes. The computed frequency data.
   *
   * ```
   * const [frequencyBins] = jdunpack<[Uint8Array]>(buf, "b")
   * ```
   */
  SoundSpectrumReg[SoundSpectrumReg["FrequencyBins"] = 257] = "FrequencyBins";
  /**
   * Read-write bool (uint8_t). Turns on/off the micropohone.
   *
   * ```
   * const [enabled] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  SoundSpectrumReg[SoundSpectrumReg["Enabled"] = 1] = "Enabled";
  /**
   * Read-write uint8_t. The power of 2 used as the size of the FFT to be used to determine the frequency domain.
   *
   * ```
   * const [fftPow2Size] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  SoundSpectrumReg[SoundSpectrumReg["FftPow2Size"] = 128] = "FftPow2Size";
  /**
   * Read-write dB int16_t. The minimum power value in the scaling range for the FFT analysis data
   *
   * ```
   * const [minDecibels] = jdunpack<[number]>(buf, "i16")
   * ```
   */

  SoundSpectrumReg[SoundSpectrumReg["MinDecibels"] = 129] = "MinDecibels";
  /**
   * Read-write dB int16_t. The maximum power value in the scaling range for the FFT analysis data
   *
   * ```
   * const [maxDecibels] = jdunpack<[number]>(buf, "i16")
   * ```
   */

  SoundSpectrumReg[SoundSpectrumReg["MaxDecibels"] = 130] = "MaxDecibels";
  /**
   * Read-write ratio u0.8 (uint8_t). The averaging constant with the last analysis frame.
   * If ``0`` is set, there is no averaging done, whereas a value of ``1`` means "overlap the previous and current buffer quite a lot while computing the value".
   *
   * ```
   * const [smoothingTimeConstant] = jdunpack<[number]>(buf, "u0.8")
   * ```
   */

  SoundSpectrumReg[SoundSpectrumReg["SmoothingTimeConstant"] = 131] = "SmoothingTimeConstant";
})(exports.SoundSpectrumReg || (exports.SoundSpectrumReg = {})); // Service: Speech synthesis


const SRV_SPEECH_SYNTHESIS = 0x1204d995;
exports.SpeechSynthesisReg = void 0;

(function (SpeechSynthesisReg) {
  /**
   * Read-write bool (uint8_t). Determines if the speech engine is in a non-paused state.
   *
   * ```
   * const [enabled] = jdunpack<[number]>(buf, "u8")
   * ```
   */
  SpeechSynthesisReg[SpeechSynthesisReg["Enabled"] = 1] = "Enabled";
  /**
   * Read-write string (bytes). Language used for utterances as defined in https://www.ietf.org/rfc/bcp/bcp47.txt.
   *
   * ```
   * const [lang] = jdunpack<[string]>(buf, "s")
   * ```
   */

  SpeechSynthesisReg[SpeechSynthesisReg["Lang"] = 128] = "Lang";
  /**
   * Read-write ratio u0.8 (uint8_t). Volume for utterances.
   *
   * ```
   * const [volume] = jdunpack<[number]>(buf, "u0.8")
   * ```
   */

  SpeechSynthesisReg[SpeechSynthesisReg["Volume"] = 129] = "Volume";
  /**
   * Read-write u16.16 (uint32_t). Pitch for utterances
   *
   * ```
   * const [pitch] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */

  SpeechSynthesisReg[SpeechSynthesisReg["Pitch"] = 130] = "Pitch";
  /**
   * Read-write u16.16 (uint32_t). Rate for utterances
   *
   * ```
   * const [rate] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */

  SpeechSynthesisReg[SpeechSynthesisReg["Rate"] = 131] = "Rate";
})(exports.SpeechSynthesisReg || (exports.SpeechSynthesisReg = {}));

exports.SpeechSynthesisCmd = void 0;

(function (SpeechSynthesisCmd) {
  /**
   * Argument: text string (bytes). Adds an utterance to the utterance queue; it will be spoken when any other utterances queued before it have been spoken.
   *
   * ```
   * const [text] = jdunpack<[string]>(buf, "s")
   * ```
   */
  SpeechSynthesisCmd[SpeechSynthesisCmd["Speak"] = 128] = "Speak";
  /**
   * No args. Cancels current utterance and all utterances from the utterance queue.
   */

  SpeechSynthesisCmd[SpeechSynthesisCmd["Cancel"] = 129] = "Cancel";
})(exports.SpeechSynthesisCmd || (exports.SpeechSynthesisCmd = {})); // Service: Switch


const SRV_SWITCH = 0x1ad29402;
exports.SwitchVariant = void 0;

(function (SwitchVariant) {
  SwitchVariant[SwitchVariant["Slide"] = 1] = "Slide";
  SwitchVariant[SwitchVariant["Tilt"] = 2] = "Tilt";
  SwitchVariant[SwitchVariant["PushButton"] = 3] = "PushButton";
  SwitchVariant[SwitchVariant["Tactile"] = 4] = "Tactile";
  SwitchVariant[SwitchVariant["Toggle"] = 5] = "Toggle";
  SwitchVariant[SwitchVariant["Proximity"] = 6] = "Proximity";
  SwitchVariant[SwitchVariant["Magnetic"] = 7] = "Magnetic";
  SwitchVariant[SwitchVariant["FootPedal"] = 8] = "FootPedal";
})(exports.SwitchVariant || (exports.SwitchVariant = {}));

exports.SwitchReg = void 0;

(function (SwitchReg) {
  /**
   * Read-only bool (uint8_t). Indicates whether the switch is currently active (on).
   *
   * ```
   * const [active] = jdunpack<[number]>(buf, "u8")
   * ```
   */
  SwitchReg[SwitchReg["Active"] = 257] = "Active";
  /**
   * Constant Variant (uint8_t). Describes the type of switch used.
   *
   * ```
   * const [variant] = jdunpack<[SwitchVariant]>(buf, "u8")
   * ```
   */

  SwitchReg[SwitchReg["Variant"] = 263] = "Variant";
  /**
   * Constant s u16.16 (uint32_t). Specifies the delay without activity to automatically turn off after turning on.
   * For example, some light switches in staircases have such a capability.
   *
   * ```
   * const [autoOffDelay] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */

  SwitchReg[SwitchReg["AutoOffDelay"] = 384] = "AutoOffDelay";
})(exports.SwitchReg || (exports.SwitchReg = {}));

exports.SwitchEvent = void 0;

(function (SwitchEvent) {
  /**
   * Emitted when switch goes from ``off`` to ``on``.
   */
  SwitchEvent[SwitchEvent["On"] = 1] = "On";
  /**
   * Emitted when switch goes from ``on`` to ``off``.
   */

  SwitchEvent[SwitchEvent["Off"] = 2] = "Off";
})(exports.SwitchEvent || (exports.SwitchEvent = {})); // Service: TCP


const SRV_TCP = 0x1b43b70b;
exports.TcpTcpError = void 0;

(function (TcpTcpError) {
  TcpTcpError[TcpTcpError["InvalidCommand"] = 1] = "InvalidCommand";
  TcpTcpError[TcpTcpError["InvalidCommandPayload"] = 2] = "InvalidCommandPayload";
})(exports.TcpTcpError || (exports.TcpTcpError = {}));

exports.TcpCmd = void 0;

(function (TcpCmd) {
  /**
   * Argument: inbound pipe (bytes). Open pair of pipes between network peripheral and a controlling device. In/outbound refers to direction from/to internet.
   *
   * ```
   * const [inbound] = jdunpack<[Uint8Array]>(buf, "b[12]")
   * ```
   */
  TcpCmd[TcpCmd["Open"] = 128] = "Open";
  /**
   * report Open
   * ```
   * const [outboundPort] = jdunpack<[number]>(buf, "u16")
   * ```
   */
})(exports.TcpCmd || (exports.TcpCmd = {}));

exports.TcpPipeCmd = void 0;

(function (TcpPipeCmd) {
  /**
   * Open an SSL connection to a given host:port pair. Can be issued only once on given pipe.
   * After the connection is established, an empty data report is sent.
   * Connection is closed by closing the pipe.
   *
   * ```
   * const [tcpPort, hostname] = jdunpack<[number, string]>(buf, "u16 s")
   * ```
   */
  TcpPipeCmd[TcpPipeCmd["OpenSsl"] = 1] = "OpenSsl";
  /**
   * Argument: error TcpError (int32_t). Reported when an error is encountered. Negative error codes come directly from the SSL implementation.
   *
   * ```
   * const [error] = jdunpack<[TcpTcpError]>(buf, "i32")
   * ```
   */

  TcpPipeCmd[TcpPipeCmd["Error"] = 0] = "Error";
})(exports.TcpPipeCmd || (exports.TcpPipeCmd = {}));
/**
 * pipe_command Outdata
 * ```
 * const [data] = jdunpack<[Uint8Array]>(buf, "b")
 * ```
 */

/**
 * pipe_report Indata
 * ```
 * const [data] = jdunpack<[Uint8Array]>(buf, "b")
 * ```
 */
// Service: Thermocouple


const SRV_THERMOCOUPLE = 0x143ac061;
exports.ThermocoupleVariant = void 0;

(function (ThermocoupleVariant) {
  ThermocoupleVariant[ThermocoupleVariant["TypeK"] = 1] = "TypeK";
  ThermocoupleVariant[ThermocoupleVariant["TypeJ"] = 2] = "TypeJ";
  ThermocoupleVariant[ThermocoupleVariant["TypeT"] = 3] = "TypeT";
  ThermocoupleVariant[ThermocoupleVariant["TypeE"] = 4] = "TypeE";
  ThermocoupleVariant[ThermocoupleVariant["TypeN"] = 5] = "TypeN";
  ThermocoupleVariant[ThermocoupleVariant["TypeS"] = 6] = "TypeS";
  ThermocoupleVariant[ThermocoupleVariant["TypeR"] = 7] = "TypeR";
  ThermocoupleVariant[ThermocoupleVariant["TypeB"] = 8] = "TypeB";
})(exports.ThermocoupleVariant || (exports.ThermocoupleVariant = {}));

exports.ThermocoupleReg = void 0;

(function (ThermocoupleReg) {
  /**
   * Read-only °C i22.10 (int32_t). The temperature.
   *
   * ```
   * const [temperature] = jdunpack<[number]>(buf, "i22.10")
   * ```
   */
  ThermocoupleReg[ThermocoupleReg["Temperature"] = 257] = "Temperature";
  /**
   * Constant °C i22.10 (int32_t). Lowest temperature that can be reported.
   *
   * ```
   * const [minTemperature] = jdunpack<[number]>(buf, "i22.10")
   * ```
   */

  ThermocoupleReg[ThermocoupleReg["MinTemperature"] = 260] = "MinTemperature";
  /**
   * Constant °C i22.10 (int32_t). Highest temperature that can be reported.
   *
   * ```
   * const [maxTemperature] = jdunpack<[number]>(buf, "i22.10")
   * ```
   */

  ThermocoupleReg[ThermocoupleReg["MaxTemperature"] = 261] = "MaxTemperature";
  /**
   * Read-only °C u22.10 (uint32_t). The real temperature is between `temperature - temperature_error` and `temperature + temperature_error`.
   *
   * ```
   * const [temperatureError] = jdunpack<[number]>(buf, "u22.10")
   * ```
   */

  ThermocoupleReg[ThermocoupleReg["TemperatureError"] = 262] = "TemperatureError";
  /**
   * Constant Variant (uint8_t). Specifies the type of thermometer.
   *
   * ```
   * const [variant] = jdunpack<[ThermocoupleVariant]>(buf, "u8")
   * ```
   */

  ThermocoupleReg[ThermocoupleReg["Variant"] = 263] = "Variant";
})(exports.ThermocoupleReg || (exports.ThermocoupleReg = {})); // Service: Thermometer


const SRV_THERMOMETER = 0x1421bac7;
exports.ThermometerVariant = void 0;

(function (ThermometerVariant) {
  ThermometerVariant[ThermometerVariant["Outdoor"] = 1] = "Outdoor";
  ThermometerVariant[ThermometerVariant["Indoor"] = 2] = "Indoor";
  ThermometerVariant[ThermometerVariant["Body"] = 3] = "Body";
})(exports.ThermometerVariant || (exports.ThermometerVariant = {}));

exports.ThermometerReg = void 0;

(function (ThermometerReg) {
  /**
   * Read-only °C i22.10 (int32_t). The temperature.
   *
   * ```
   * const [temperature] = jdunpack<[number]>(buf, "i22.10")
   * ```
   */
  ThermometerReg[ThermometerReg["Temperature"] = 257] = "Temperature";
  /**
   * Constant °C i22.10 (int32_t). Lowest temperature that can be reported.
   *
   * ```
   * const [minTemperature] = jdunpack<[number]>(buf, "i22.10")
   * ```
   */

  ThermometerReg[ThermometerReg["MinTemperature"] = 260] = "MinTemperature";
  /**
   * Constant °C i22.10 (int32_t). Highest temperature that can be reported.
   *
   * ```
   * const [maxTemperature] = jdunpack<[number]>(buf, "i22.10")
   * ```
   */

  ThermometerReg[ThermometerReg["MaxTemperature"] = 261] = "MaxTemperature";
  /**
   * Read-only °C u22.10 (uint32_t). The real temperature is between `temperature - temperature_error` and `temperature + temperature_error`.
   *
   * ```
   * const [temperatureError] = jdunpack<[number]>(buf, "u22.10")
   * ```
   */

  ThermometerReg[ThermometerReg["TemperatureError"] = 262] = "TemperatureError";
  /**
   * Constant Variant (uint8_t). Specifies the type of thermometer.
   *
   * ```
   * const [variant] = jdunpack<[ThermometerVariant]>(buf, "u8")
   * ```
   */

  ThermometerReg[ThermometerReg["Variant"] = 263] = "Variant";
})(exports.ThermometerReg || (exports.ThermometerReg = {})); // Service: Traffic Light


const SRV_TRAFFIC_LIGHT = 0x15c38d9b;
exports.TrafficLightReg = void 0;

(function (TrafficLightReg) {
  /**
   * Read-write bool (uint8_t). The on/off state of the red light.
   *
   * ```
   * const [red] = jdunpack<[number]>(buf, "u8")
   * ```
   */
  TrafficLightReg[TrafficLightReg["Red"] = 128] = "Red";
  /**
   * Read-write bool (uint8_t). The on/off state of the red light.
   *
   * ```
   * const [orange] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  TrafficLightReg[TrafficLightReg["Orange"] = 129] = "Orange";
  /**
   * Read-write bool (uint8_t). The on/off state of the red light.
   *
   * ```
   * const [green] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  TrafficLightReg[TrafficLightReg["Green"] = 130] = "Green";
})(exports.TrafficLightReg || (exports.TrafficLightReg = {})); // Service: Total Volatile organic compound


const SRV_TVOC = 0x12a5b597;
exports.TvocReg = void 0;

(function (TvocReg) {
  /**
   * Read-only ppb u22.10 (uint32_t). Total volatile organic compound readings in parts per billion.
   *
   * ```
   * const [tVOC] = jdunpack<[number]>(buf, "u22.10")
   * ```
   */
  TvocReg[TvocReg["TVOC"] = 257] = "TVOC";
  /**
   * Read-only ppb u22.10 (uint32_t). Error on the reading data
   *
   * ```
   * const [tVOCError] = jdunpack<[number]>(buf, "u22.10")
   * ```
   */

  TvocReg[TvocReg["TVOCError"] = 262] = "TVOCError";
  /**
   * Constant ppb u22.10 (uint32_t). Minimum measurable value
   *
   * ```
   * const [minTVOC] = jdunpack<[number]>(buf, "u22.10")
   * ```
   */

  TvocReg[TvocReg["MinTVOC"] = 260] = "MinTVOC";
  /**
   * Constant ppb u22.10 (uint32_t). Minimum measurable value
   *
   * ```
   * const [maxTVOC] = jdunpack<[number]>(buf, "u22.10")
   * ```
   */

  TvocReg[TvocReg["MaxTVOC"] = 261] = "MaxTVOC";
  /**
   * Constant s uint32_t. Time required to achieve good sensor stability before measuring after long idle period.
   *
   * ```
   * const [conditioningPeriod] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  TvocReg[TvocReg["ConditioningPeriod"] = 384] = "ConditioningPeriod";
})(exports.TvocReg || (exports.TvocReg = {})); // Service: UV index


const SRV_UV_INDEX = 0x1f6e0d90;
exports.UvIndexVariant = void 0;

(function (UvIndexVariant) {
  UvIndexVariant[UvIndexVariant["UVA_UVB"] = 1] = "UVA_UVB";
  UvIndexVariant[UvIndexVariant["Visible_IR"] = 2] = "Visible_IR";
})(exports.UvIndexVariant || (exports.UvIndexVariant = {}));

exports.UvIndexReg = void 0;

(function (UvIndexReg) {
  /**
   * Read-only uv u16.16 (uint32_t). Ultraviolet index, typically refreshed every second.
   *
   * ```
   * const [uvIndex] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */
  UvIndexReg[UvIndexReg["UvIndex"] = 257] = "UvIndex";
  /**
   * Read-only uv u16.16 (uint32_t). Error on the UV measure.
   *
   * ```
   * const [uvIndexError] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */

  UvIndexReg[UvIndexReg["UvIndexError"] = 262] = "UvIndexError";
  /**
   * Constant Variant (uint8_t). The type of physical sensor and capabilities.
   *
   * ```
   * const [variant] = jdunpack<[UvIndexVariant]>(buf, "u8")
   * ```
   */

  UvIndexReg[UvIndexReg["Variant"] = 263] = "Variant";
})(exports.UvIndexReg || (exports.UvIndexReg = {})); // Service: Verified Telemetry


const SRV_VERIFIED_TELEMETRY = 0x2194841f;
exports.VerifiedTelemetryStatus = void 0;

(function (VerifiedTelemetryStatus) {
  VerifiedTelemetryStatus[VerifiedTelemetryStatus["Unknown"] = 0] = "Unknown";
  VerifiedTelemetryStatus[VerifiedTelemetryStatus["Working"] = 1] = "Working";
  VerifiedTelemetryStatus[VerifiedTelemetryStatus["Faulty"] = 2] = "Faulty";
})(exports.VerifiedTelemetryStatus || (exports.VerifiedTelemetryStatus = {}));

exports.VerifiedTelemetryFingerprintType = void 0;

(function (VerifiedTelemetryFingerprintType) {
  VerifiedTelemetryFingerprintType[VerifiedTelemetryFingerprintType["FallCurve"] = 1] = "FallCurve";
  VerifiedTelemetryFingerprintType[VerifiedTelemetryFingerprintType["CurrentSense"] = 2] = "CurrentSense";
  VerifiedTelemetryFingerprintType[VerifiedTelemetryFingerprintType["Custom"] = 3] = "Custom";
})(exports.VerifiedTelemetryFingerprintType || (exports.VerifiedTelemetryFingerprintType = {}));

exports.VerifiedTelemetryReg = void 0;

(function (VerifiedTelemetryReg) {
  /**
   * Read-only Status (uint8_t). Reads the telemetry working status, where ``true`` is working and ``false`` is faulty.
   *
   * ```
   * const [telemetryStatus] = jdunpack<[VerifiedTelemetryStatus]>(buf, "u8")
   * ```
   */
  VerifiedTelemetryReg[VerifiedTelemetryReg["TelemetryStatus"] = 384] = "TelemetryStatus";
  /**
   * Read-write ms uint32_t. Specifies the interval between computing the fingerprint information.
   *
   * ```
   * const [telemetryStatusInterval] = jdunpack<[number]>(buf, "u32")
   * ```
   */

  VerifiedTelemetryReg[VerifiedTelemetryReg["TelemetryStatusInterval"] = 128] = "TelemetryStatusInterval";
  /**
   * Constant FingerprintType (uint8_t). Type of the fingerprint.
   *
   * ```
   * const [fingerprintType] = jdunpack<[VerifiedTelemetryFingerprintType]>(buf, "u8")
   * ```
   */

  VerifiedTelemetryReg[VerifiedTelemetryReg["FingerprintType"] = 385] = "FingerprintType";
  /**
   * Template Fingerprint information of a working sensor.
   *
   * ```
   * const [confidence, template] = jdunpack<[number, Uint8Array]>(buf, "u16 b")
   * ```
   */

  VerifiedTelemetryReg[VerifiedTelemetryReg["FingerprintTemplate"] = 386] = "FingerprintTemplate";
})(exports.VerifiedTelemetryReg || (exports.VerifiedTelemetryReg = {}));

exports.VerifiedTelemetryCmd = void 0;

(function (VerifiedTelemetryCmd) {
  /**
   * No args. This command will clear the template fingerprint of a sensor and collect a new template fingerprint of the attached sensor.
   */
  VerifiedTelemetryCmd[VerifiedTelemetryCmd["ResetFingerprintTemplate"] = 128] = "ResetFingerprintTemplate";
  /**
   * No args. This command will append a new template fingerprint to the `fingerprintTemplate`. Appending more fingerprints will increase the accuracy in detecting the telemetry status.
   */

  VerifiedTelemetryCmd[VerifiedTelemetryCmd["RetrainFingerprintTemplate"] = 129] = "RetrainFingerprintTemplate";
})(exports.VerifiedTelemetryCmd || (exports.VerifiedTelemetryCmd = {}));

exports.VerifiedTelemetryEvent = void 0;

(function (VerifiedTelemetryEvent) {
  /**
   * Argument: telemetry_status Status (uint8_t). The telemetry status of the device was updated.
   *
   * ```
   * const [telemetryStatus] = jdunpack<[VerifiedTelemetryStatus]>(buf, "u8")
   * ```
   */
  VerifiedTelemetryEvent[VerifiedTelemetryEvent["TelemetryStatusChange"] = 3] = "TelemetryStatusChange";
  /**
   * The fingerprint template was updated
   */

  VerifiedTelemetryEvent[VerifiedTelemetryEvent["FingerprintTemplateChange"] = 128] = "FingerprintTemplateChange";
})(exports.VerifiedTelemetryEvent || (exports.VerifiedTelemetryEvent = {})); // Service: Vibration motor


const SRV_VIBRATION_MOTOR = 0x183fc4a2;
exports.VibrationMotorReg = void 0;

(function (VibrationMotorReg) {
  /**
   * Read-write bool (uint8_t). Determines if the vibration motor responds to vibrate commands.
   *
   * ```
   * const [enabled] = jdunpack<[number]>(buf, "u8")
   * ```
   */
  VibrationMotorReg[VibrationMotorReg["Enabled"] = 1] = "Enabled";
})(exports.VibrationMotorReg || (exports.VibrationMotorReg = {}));

exports.VibrationMotorCmd = void 0;

(function (VibrationMotorCmd) {
  /**
   * Starts a sequence of vibration and pauses. To stop any existing vibration, send an empty payload.
   *
   * ```
   * const [rest] = jdunpack<[([number, number])[]]>(buf, "r: u8 u0.8")
   * const [duration, speed] = rest[0]
   * ```
   */
  VibrationMotorCmd[VibrationMotorCmd["Vibrate"] = 128] = "Vibrate";
})(exports.VibrationMotorCmd || (exports.VibrationMotorCmd = {})); // Service: Water level


const SRV_WATER_LEVEL = 0x147b62ed;
exports.WaterLevelVariant = void 0;

(function (WaterLevelVariant) {
  WaterLevelVariant[WaterLevelVariant["Resistive"] = 1] = "Resistive";
  WaterLevelVariant[WaterLevelVariant["ContactPhotoElectric"] = 2] = "ContactPhotoElectric";
  WaterLevelVariant[WaterLevelVariant["NonContactPhotoElectric"] = 3] = "NonContactPhotoElectric";
})(exports.WaterLevelVariant || (exports.WaterLevelVariant = {}));

exports.WaterLevelReg = void 0;

(function (WaterLevelReg) {
  /**
   * Read-only ratio u0.16 (uint16_t). The reported water level.
   *
   * ```
   * const [level] = jdunpack<[number]>(buf, "u0.16")
   * ```
   */
  WaterLevelReg[WaterLevelReg["Level"] = 257] = "Level";
  /**
   * Constant Variant (uint8_t). The type of physical sensor.
   *
   * ```
   * const [variant] = jdunpack<[WaterLevelVariant]>(buf, "u8")
   * ```
   */

  WaterLevelReg[WaterLevelReg["Variant"] = 263] = "Variant";
})(exports.WaterLevelReg || (exports.WaterLevelReg = {})); // Service: Weight Scale


const SRV_WEIGHT_SCALE = 0x1f4d5040;
exports.WeightScaleVariant = void 0;

(function (WeightScaleVariant) {
  WeightScaleVariant[WeightScaleVariant["Body"] = 1] = "Body";
  WeightScaleVariant[WeightScaleVariant["Food"] = 2] = "Food";
  WeightScaleVariant[WeightScaleVariant["Jewelry"] = 3] = "Jewelry";
})(exports.WeightScaleVariant || (exports.WeightScaleVariant = {}));

exports.WeightScaleReg = void 0;

(function (WeightScaleReg) {
  /**
   * Read-only kg u16.16 (uint32_t). The reported weight.
   *
   * ```
   * const [weight] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */
  WeightScaleReg[WeightScaleReg["Weight"] = 257] = "Weight";
  /**
   * Read-only kg u16.16 (uint32_t). The estimate error on the reported reading.
   *
   * ```
   * const [weightError] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */

  WeightScaleReg[WeightScaleReg["WeightError"] = 262] = "WeightError";
  /**
   * Read-write kg u16.16 (uint32_t). Calibrated zero offset error on the scale, i.e. the measured weight when nothing is on the scale.
   * You do not need to subtract that from the reading, it has already been done.
   *
   * ```
   * const [zeroOffset] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */

  WeightScaleReg[WeightScaleReg["ZeroOffset"] = 128] = "ZeroOffset";
  /**
   * Read-write u16.16 (uint32_t). Calibrated gain on the weight scale error.
   *
   * ```
   * const [gain] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */

  WeightScaleReg[WeightScaleReg["Gain"] = 129] = "Gain";
  /**
   * Constant kg u16.16 (uint32_t). Maximum supported weight on the scale.
   *
   * ```
   * const [maxWeight] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */

  WeightScaleReg[WeightScaleReg["MaxWeight"] = 261] = "MaxWeight";
  /**
   * Constant kg u16.16 (uint32_t). Minimum recommend weight on the scale.
   *
   * ```
   * const [minWeight] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */

  WeightScaleReg[WeightScaleReg["MinWeight"] = 260] = "MinWeight";
  /**
   * Constant kg u16.16 (uint32_t). Smallest, yet distinguishable change in reading.
   *
   * ```
   * const [weightResolution] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */

  WeightScaleReg[WeightScaleReg["WeightResolution"] = 264] = "WeightResolution";
  /**
   * Constant Variant (uint8_t). The type of physical scale
   *
   * ```
   * const [variant] = jdunpack<[WeightScaleVariant]>(buf, "u8")
   * ```
   */

  WeightScaleReg[WeightScaleReg["Variant"] = 263] = "Variant";
})(exports.WeightScaleReg || (exports.WeightScaleReg = {}));

exports.WeightScaleCmd = void 0;

(function (WeightScaleCmd) {
  /**
   * No args. Call this command when there is nothing on the scale. If supported, the module should save the calibration data.
   */
  WeightScaleCmd[WeightScaleCmd["CalibrateZeroOffset"] = 128] = "CalibrateZeroOffset";
  /**
   * Argument: weight g u22.10 (uint32_t). Call this command with the weight of the thing on the scale.
   *
   * ```
   * const [weight] = jdunpack<[number]>(buf, "u22.10")
   * ```
   */

  WeightScaleCmd[WeightScaleCmd["CalibrateGain"] = 129] = "CalibrateGain";
})(exports.WeightScaleCmd || (exports.WeightScaleCmd = {})); // Service: WIFI


const SRV_WIFI = 0x18aae1fa;
exports.WifiAPFlags = void 0;

(function (WifiAPFlags) {
  WifiAPFlags[WifiAPFlags["HasPassword"] = 1] = "HasPassword";
  WifiAPFlags[WifiAPFlags["WPS"] = 2] = "WPS";
  WifiAPFlags[WifiAPFlags["HasSecondaryChannelAbove"] = 4] = "HasSecondaryChannelAbove";
  WifiAPFlags[WifiAPFlags["HasSecondaryChannelBelow"] = 8] = "HasSecondaryChannelBelow";
  WifiAPFlags[WifiAPFlags["IEEE_802_11B"] = 256] = "IEEE_802_11B";
  WifiAPFlags[WifiAPFlags["IEEE_802_11A"] = 512] = "IEEE_802_11A";
  WifiAPFlags[WifiAPFlags["IEEE_802_11G"] = 1024] = "IEEE_802_11G";
  WifiAPFlags[WifiAPFlags["IEEE_802_11N"] = 2048] = "IEEE_802_11N";
  WifiAPFlags[WifiAPFlags["IEEE_802_11AC"] = 4096] = "IEEE_802_11AC";
  WifiAPFlags[WifiAPFlags["IEEE_802_11AX"] = 8192] = "IEEE_802_11AX";
  WifiAPFlags[WifiAPFlags["IEEE_802_LongRange"] = 32768] = "IEEE_802_LongRange";
})(exports.WifiAPFlags || (exports.WifiAPFlags = {}));

exports.WifiCmd = void 0;

(function (WifiCmd) {
  /**
   * Argument: results pipe (bytes). Return list of WiFi network from the last scan.
   * Scans are performed periodically while not connected (in particular, on startup and after current connection drops),
   * as well as upon `reconnect` and `scan` commands.
   *
   * ```
   * const [results] = jdunpack<[Uint8Array]>(buf, "b[12]")
   * ```
   */
  WifiCmd[WifiCmd["LastScanResults"] = 128] = "LastScanResults";
  /**
   * Automatically connect to named network if available. Also set password if network is not open.
   *
   * ```
   * const [ssid, password] = jdunpack<[string, string]>(buf, "z z")
   * ```
   */

  WifiCmd[WifiCmd["AddNetwork"] = 129] = "AddNetwork";
  /**
   * No args. Initiate a scan, wait for results, disconnect from current WiFi network if any,
   * and then reconnect (using regular algorithm, see `set_network_priority`).
   */

  WifiCmd[WifiCmd["Reconnect"] = 130] = "Reconnect";
  /**
   * Argument: ssid string (bytes). Prevent from automatically connecting to named network in future.
   * Forgetting a network resets its priority to `0`.
   *
   * ```
   * const [ssid] = jdunpack<[string]>(buf, "s")
   * ```
   */

  WifiCmd[WifiCmd["ForgetNetwork"] = 131] = "ForgetNetwork";
  /**
   * No args. Clear the list of known networks.
   */

  WifiCmd[WifiCmd["ForgetAllNetworks"] = 132] = "ForgetAllNetworks";
  /**
   * Set connection priority for a network.
   * By default, all known networks have priority of `0`.
   *
   * ```
   * const [priority, ssid] = jdunpack<[number, string]>(buf, "i16 s")
   * ```
   */

  WifiCmd[WifiCmd["SetNetworkPriority"] = 133] = "SetNetworkPriority";
  /**
   * No args. Initiate search for WiFi networks. Generates `scan_complete` event.
   */

  WifiCmd[WifiCmd["Scan"] = 134] = "Scan";
  /**
   * Argument: results pipe (bytes). Return list of known WiFi networks.
   * `flags` is currently always 0.
   *
   * ```
   * const [results] = jdunpack<[Uint8Array]>(buf, "b[12]")
   * ```
   */

  WifiCmd[WifiCmd["ListKnownNetworks"] = 135] = "ListKnownNetworks";
})(exports.WifiCmd || (exports.WifiCmd = {}));
/**
 * pipe_report Results
 * ```
 * const [flags, rssi, channel, bssid, ssid] = jdunpack<[WifiAPFlags, number, number, Uint8Array, string]>(buf, "u32 x[4] i8 u8 b[6] s[33]")
 * ```
 */

/**
 * pipe_report NetworkResults
 * ```
 * const [priority, flags, ssid] = jdunpack<[number, number, string]>(buf, "i16 i16 s")
 * ```
 */


exports.WifiReg = void 0;

(function (WifiReg) {
  /**
   * Read-write bool (uint8_t). Determines whether the WiFi radio is enabled. It starts enabled upon reset.
   *
   * ```
   * const [enabled] = jdunpack<[number]>(buf, "u8")
   * ```
   */
  WifiReg[WifiReg["Enabled"] = 1] = "Enabled";
  /**
   * Read-only bool (uint8_t). Indicates whether or not we currently have an IP address assigned.
   *
   * ```
   * const [connected] = jdunpack<[number]>(buf, "u8")
   * ```
   */

  WifiReg[WifiReg["Connected"] = 384] = "Connected";
  /**
   * Read-only bytes. 0, 4 or 16 byte buffer with the IPv4 or IPv6 address assigned to device if any.
   *
   * ```
   * const [ipAddress] = jdunpack<[Uint8Array]>(buf, "b[16]")
   * ```
   */

  WifiReg[WifiReg["IpAddress"] = 385] = "IpAddress";
  /**
   * Constant bytes. The 6-byte MAC address of the device. If a device does MAC address randomization it will have to "restart".
   *
   * ```
   * const [eui48] = jdunpack<[Uint8Array]>(buf, "b[6]")
   * ```
   */

  WifiReg[WifiReg["Eui48"] = 386] = "Eui48";
  /**
   * Read-only string (bytes). SSID of the access-point to which device is currently connected.
   * Empty string if not connected.
   *
   * ```
   * const [ssid] = jdunpack<[string]>(buf, "s[32]")
   * ```
   */

  WifiReg[WifiReg["Ssid"] = 387] = "Ssid";
  /**
   * Read-only dB int8_t. Current signal strength. Returns -128 when not connected.
   *
   * ```
   * const [rssi] = jdunpack<[number]>(buf, "i8")
   * ```
   */

  WifiReg[WifiReg["Rssi"] = 388] = "Rssi";
})(exports.WifiReg || (exports.WifiReg = {}));

exports.WifiEvent = void 0;

(function (WifiEvent) {
  /**
   * Emitted upon successful join and IP address assignment.
   */
  WifiEvent[WifiEvent["GotIp"] = 1] = "GotIp";
  /**
   * Emitted when disconnected from network.
   */

  WifiEvent[WifiEvent["LostIp"] = 2] = "LostIp";
  /**
   * A WiFi network scan has completed. Results can be read with the `last_scan_results` command.
   * The event indicates how many networks where found, and how many are considered
   * as candidates for connection.
   *
   * ```
   * const [numNetworks, numKnownNetworks] = jdunpack<[number, number]>(buf, "u16 u16")
   * ```
   */

  WifiEvent[WifiEvent["ScanComplete"] = 128] = "ScanComplete";
  /**
   * Emitted whenever the list of known networks is updated.
   */

  WifiEvent[WifiEvent["NetworksChanged"] = 129] = "NetworksChanged";
})(exports.WifiEvent || (exports.WifiEvent = {})); // Service: Wind direction


const SRV_WIND_DIRECTION = 0x186be92b;
exports.WindDirectionReg = void 0;

(function (WindDirectionReg) {
  /**
   * Read-only ° uint16_t. The direction of the wind.
   *
   * ```
   * const [windDirection] = jdunpack<[number]>(buf, "u16")
   * ```
   */
  WindDirectionReg[WindDirectionReg["WindDirection"] = 257] = "WindDirection";
  /**
   * Read-only ° uint16_t. Error on the wind direction reading
   *
   * ```
   * const [windDirectionError] = jdunpack<[number]>(buf, "u16")
   * ```
   */

  WindDirectionReg[WindDirectionReg["WindDirectionError"] = 262] = "WindDirectionError";
})(exports.WindDirectionReg || (exports.WindDirectionReg = {})); // Service: Wind speed


const SRV_WIND_SPEED = 0x1b591bbf;
exports.WindSpeedReg = void 0;

(function (WindSpeedReg) {
  /**
   * Read-only m/s u16.16 (uint32_t). The velocity of the wind.
   *
   * ```
   * const [windSpeed] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */
  WindSpeedReg[WindSpeedReg["WindSpeed"] = 257] = "WindSpeed";
  /**
   * Read-only m/s u16.16 (uint32_t). Error on the reading
   *
   * ```
   * const [windSpeedError] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */

  WindSpeedReg[WindSpeedReg["WindSpeedError"] = 262] = "WindSpeedError";
  /**
   * Constant m/s u16.16 (uint32_t). Maximum speed that can be measured by the sensor.
   *
   * ```
   * const [maxWindSpeed] = jdunpack<[number]>(buf, "u16.16")
   * ```
   */

  WindSpeedReg[WindSpeedReg["MaxWindSpeed"] = 261] = "MaxWindSpeed";
})(exports.WindSpeedReg || (exports.WindSpeedReg = {})); // Registers 0x001-0x07f - r/w common to all services
// Registers 0x080-0x0ff - r/w defined per-service
// Registers 0x100-0x17f - r/o common to all services
// Registers 0x180-0x1ff - r/o defined per-service
// Registers 0x200-0xeff - custom, defined per-service
// Registers 0xf00-0xfff - reserved for implementation, should not be on the wire


const CMD_GET_REG = 0x1000;
const CMD_SET_REG = 0x2000;
const CMD_EVENT_MASK = 0x8000;
const CMD_EVENT_CODE_MASK = 0x00ff;
const CMD_EVENT_COUNTER_POS = 8;
const CMD_EVENT_COUNTER_MASK = 0x7f;
const CMD_TOP_MASK = 0xf000;
const CMD_REG_MASK = 0x0fff;
const ACK_MIN_DELAY = 90;
const ACK_MAX_DELAY = 120; // Commands 0x000-0x07f - common to all services
// Commands 0x080-0xeff - defined per-service
// Commands 0xf00-0xfff - reserved for implementation
// enumeration data for CTRL, ad-data for other services

const CMD_ADVERTISEMENT_DATA = 0x00;
const PIPE_PORT_SHIFT = 7;
const PIPE_COUNTER_MASK = 0x001f;
const PIPE_CLOSE_MASK = 0x0020;
const PIPE_METADATA_MASK = 0x0040;
const JD_SERIAL_HEADER_SIZE = 16;
const JD_SERIAL_MAX_PAYLOAD_SIZE = 236;
const JD_SERVICE_INDEX_MASK = 0x3f;
const JD_SERVICE_INDEX_INV_MASK = 0xc0;
const JD_SERVICE_INDEX_CRC_ACK = 0x3f;
const JD_SERVICE_INDEX_PIPE = 0x3e;
const JD_SERVICE_INDEX_MAX_NORMAL = 0x30;
const JD_SERVICE_INDEX_CTRL = 0x00; // the COMMAND flag signifies that the device_identifier is the recipent
// (i.e., it's a command for the peripheral); the bit clear means device_identifier is the source
// (i.e., it's a report from peripheral or a broadcast message)

const JD_FRAME_FLAG_COMMAND = 0x01; // an ACK should be issued with CRC of this package upon reception

const JD_FRAME_FLAG_ACK_REQUESTED = 0x02; // the device_identifier contains target service class number

const JD_FRAME_FLAG_IDENTIFIER_IS_SERVICE_CLASS = 0x04;
const JD_ADVERTISEMENT_0_COUNTER_MASK = 0x0000000f;
const JD_ADVERTISEMENT_0_ACK_SUPPORTED = 0x00000100; // time withouth seeing a package to be considered "lost", 2x announce interval

const JD_DEVICE_LOST_DELAY = 1500; // time without seeing a packet to be considered "disconnected"

const JD_DEVICE_DISCONNECTED_DELAY = 5000;
const RESET_IN_TIME_US = 2000000;
const MAX_SERVICES_LENGTH = 59;
const NEW_LISTENER = "newListener";
const REMOVE_LISTENER = "removeListener";
const CONNECTION_STATE = "connectionState";
const CONNECT = "connect";
const LOST = "lost";
const FOUND = "found";
const CONNECTING = "connecting";
const DISCONNECT = "disconnect";
const DISCONNECTING = "disconnecting";
const ANNOUNCE = "announce";
const START = "start";
const RESTART = "restart";
const STOP = "stop";
const CHANGE = "change";
const EVENT = "event";
const RENDER = "render";
const REFRESH = "refresh";
const MESSAGE = "message";
const FIRMWARE_BLOBS_CHANGE = "firmwareBlobsChange";
const LATE = "late";
const GET_ATTEMPT = "getAttempt";
const SERVICE_CLIENT_ADDED = `serviceClientAdded`;
const SERVICE_CLIENT_REMOVED = `serviceClientRemoved`;
const READING_SENT = "readingSent";
const ROLE_CHANGE = "roleChange";
const ROLE_MANAGER_CHANGE = "roleManagerChange";
const SERVICE_PROVIDER_ADDED = `serviceProviderAdded`;
const SERVICE_PROVIDER_REMOVED = `serviceProviderRemoved`;
const IDENTIFY = "identify";
const IDENTIFY_DURATION = 2000;
const RESET = "reset";
const DATA = "data";
const CLOSE = "close";
const DEVICE_CONNECT = "deviceConnect";
const DEVICE_LOST = "deviceLost";
const DEVICE_FOUND = "deviceFound";
const DEVICE_DISCONNECT = "deviceDisconnect";
const DEVICE_ANNOUNCE = "deviceAnnounce";
const DEVICE_PACKET_ANNOUNCE = "devicePacketAnnounce";
const DEVICE_RESTART = "deviceRestart";
const DEVICE_CHANGE = "deviceChange";
const DEVICE_FIRMWARE_INFO = "firmwareInfo";
const DEVICE_CLEAN = "deviceClean";
const SELF_ANNOUNCE = "selfAnnounce";
const PACKET_SEND = "packetSend";
const PACKET_SEND_DISCONNECT = "packetSendDisconnect";
const PACKET_PRE_PROCESS = "packetPreProcess";
const PACKET_PROCESS = "packetProcess";
const PACKET_RECEIVE = "packetReceive";
const PACKET_RECEIVE_ANNOUNCE = "packetReceiveAnnounce";
const PACKET_EVENT = "packetEvent";
const PACKET_REPORT = "packetReport";
const PACKET_ANNOUNCE = "packetAnnounce";
const PACKET_INVALID_CRC = "packetInvalidCrc";
const PACKET_INVALID_DATA = "packetInvalidData";
const PACKET_DATA_NORMALIZE = "packetDataNormalize";
const REPORT_RECEIVE = "reportReceive";
const REPORT_UPDATE = "reportUpdate";
const COMMAND_RECEIVE = "commandReceive";
const ERROR = "error";
const TRACE = "trace";
const TIMEOUT = "timeout";
const TIMEOUT_DISCONNECT = "timeoutDisconnect";
const PROGRESS = "progress";
const PACKET_KIND_RW = "rw";
const PACKET_KIND_RO = "ro";
const PACKET_KIND_EVENT = "event";
const PACKET_KIND_ANNOUNCE = "announce";
const REGISTER_NODE_NAME = "register";
const REPORT_NODE_NAME = "report";
const CONST_NODE_NAME = "const";
const EVENT_NODE_NAME = "event";
const SERVICE_NODE_NAME = "service";
const SERVICE_MIXIN_NODE_NAME = "serviceMixin";
const DEVICE_NODE_NAME = "device";
const VIRTUAL_DEVICE_NODE_NAME = "virtualdevice";
const BUS_NODE_NAME = "bus";
const COMMAND_NODE_NAME = "command";
const FIELD_NODE_NAME = "field";
const PIPE_NODE_NAME = "pipe";
const PIPE_REPORT_NODE_NAME = "pipe_report";
const CRC_ACK_NODE_NAME = "crcAck";
const SERVICE_TEST_NODE_NAME = "serviceTest";
const REGISTER_REFRESH_TIMEOUT = 150;
const REGISTER_REFRESH_RETRY_0 = 30;
const REGISTER_REFRESH_RETRY_1 = 80;
const REGISTER_POLL_STREAMING_INTERVAL = 5000;
const REGISTER_POLL_FIRST_REPORT_INTERVAL = 400;
const REGISTER_POLL_REPORT_INTERVAL = 5001;
const REGISTER_POLL_REPORT_MAX_INTERVAL = 60000;
const REGISTER_POLL_REPORT_VOLATILE_INTERVAL = 1000;
const REGISTER_POLL_REPORT_VOLATILE_MAX_INTERVAL = 5000;
const REGISTER_OPTIONAL_POLL_COUNT = 3;
const STREAMING_DEFAULT_INTERVAL = 50;
const FLASH_MAX_DEVICES = 6;
const PING_LOGGERS_POLL = 2400;
const ROLE_MANAGER_POLL = 1500;
const REFRESH_REGISTER_POLL = 50;
const USB_TRANSPORT = "usb";
const BLUETOOTH_TRANSPORT = "bluetooth";
const SERIAL_TRANSPORT = "serial";
const PACKETIO_TRANSPORT = "packetio";
const WEBSOCKET_TRANSPORT = "web";
const META_ACK = "ACK";
const META_ACK_FAILED = "ACK_FAILED";
const META_PIPE = "PIPE";
const META_GET = "GET";
const META_TRACE = "TRACE";
const REGISTER_PRE_GET = "registerPreGet";
const TRACE_FILTER_HORIZON = 100;
const EMBED_MIN_ASPECT_RATIO = 1.22;
const BLUETOOTH_JACDAC_SERVICE = "f8530001-a97f-49f5-a554-3e373fbea2d5";
const BLUETOOTH_JACDAC_RX_CHARACTERISTIC = "f8530002-a97f-49f5-a554-3e373fbea2d5";
const BLUETOOTH_JACDAC_TX_CHARACTERISTIC = "f8530003-a97f-49f5-a554-3e373fbea2d5";
const BLUETOOTH_JACDAC_DIAG_CHARACTERISTIC = "f8530004-a97f-49f5-a554-3e373fbea2d5";
const TRANSPORT_CONNECT_RETRY_DELAY = 500;
const TRANSPORT_PULSE_TIMEOUT = 60000; // don't interfere with manual flashing of devices

const ERROR_MICROBIT_V1 = "microbit/v1-not-supported";
const ERROR_MICROBIT_UNKNOWN = "microbit/unknown-hardware-revision";
const ERROR_MICROBIT_JACDAC_MISSING = "microbit/jacdac-missing";
const ERROR_MICROBIT_INVALID_MEMORY = "microbit/invalid-memory";
const ROLE_BOUND = "roleBound";
const ROLE_UNBOUND = "roleUnbound";
const ROLE_HAS_NO_SERVICE = "roleHasNoService";
const BOUND = "bound";
const UNBOUND = "unbound";
const JACDAC_ERROR = "JacdacError";

function isMixinService(serviceClass) {
  return (serviceClass & 536870912) === 536870912;
}

function parseIntFloat(spec, w, allowFloat = false) {
  if (/^-?0x[a-f\d_]+$/i.test(w) || /^-?[\d_]+$/.test(w)) {
    const v = parseInt(w.replace(/_/g, "")); // allow for 0x3fff_ffff syntax

    if (isNaN(v)) throw new Error("can't parse int: " + w);
    return v;
  }

  if (allowFloat && /^-?\d*(\.\d*)?(e(-?)\d+)?$/.test(w)) {
    const v = parseFloat(w);
    if (isNaN(v)) throw new Error("can't parse float: " + w);
    return v;
  }

  const ww = w.split(/\./);

  if (ww.length != 2) {
    throw new Error(`expecting int or enum member here`);
  }

  const en = spec.enums[ww[0]];

  if (!en) {
    throw new Error(`${ww[0]} is not an enum type`);
  } // eslint-disable-next-line no-prototype-builtins


  if (!en.members.hasOwnProperty(ww[1])) throw new Error(`${ww[1]} is not a member of ${ww[0]}`);
  return en.members[ww[1]] || 0;
}
/* eslint-disable @typescript-eslint/no-explicit-any */


const DEVICE_IMAGE_WIDTH = 1024;
const DEVICE_IMAGE_HEIGHT = 768; // modified subset of SenML

const unitDescription = {
  "°": "angle",
  "°/s": "rotation rate",
  "°/s2": "rotation acceleration",
  m: "meter",
  kg: "kilogram",
  s: "second",
  A: "ampere",
  K: "kelvin",
  cd: "candela",
  mol: "mole",
  Hz: "hertz",
  rad: "radian",
  sr: "steradian",
  N: "newton",
  Pa: "pascal",
  J: "joule",
  W: "watt",
  C: "coulomb",
  V: "volt",
  F: "farad",
  Ohm: "ohm",
  S: "siemens",
  Wb: "weber",
  T: "tesla",
  H: "henry",
  "°C": "degrees Celsius",
  lm: "lumen",
  lx: "lux",
  Bq: "becquerel",
  Gy: "gray",
  Sv: "sievert",
  kat: "katal",
  m2: "square meter (area)",
  m3: "cubic meter (volume)",
  "m/s": "meter per second (velocity)",
  "m/s2": "meter per square second (acceleration)",
  "m3/s": "cubic meter per second (flow rate)",
  "W/m2": "watt per square meter (irradiance)",
  "cd/m2": "candela per square meter (luminance)",
  bit: "bit (information content)",
  "bit/s": "bit per second (data rate)",
  lat: "degrees latitude",
  lon: "degrees longitude",
  pH: "pH value (acidity; logarithmic quantity)",
  dB: "decibel (logarithmic quantity)",
  dBW: "decibel relative to 1 W (power level)",
  count: "1 (counter value)",
  "/": "1 (ratio e.g., value of a switch)",
  "%RH": "Percentage (Relative Humidity)",
  "%EL": "Percentage (remaining battery energy level)",
  EL: "seconds (remaining battery energy level)",
  "1/s": "1 per second (event rate)",
  "S/m": "Siemens per meter (conductivity)",
  B: "Byte (information content)",
  VA: "volt-ampere (Apparent Power)",
  VAs: "volt-ampere second (Apparent Energy)",
  var: "volt-ampere reactive (Reactive Power)",
  vars: "volt-ampere-reactive second (Reactive Energy)",
  "J/m": "joule per meter (Energy per distance)",
  "kg/m3": "kilogram per cubic meter (mass density, mass concentration)",
  "s/60°": "servo speed (time to travel 60°)",
  "kg/cm": "torque",
  hsv: "bit HSV color",
  rgb: "RGB color",
  rpm: "revolutions per minute",
  uv: "UV index",
  lux: "illuminance",
  bpm: "beats per minute",
  mcd: "micro candella",
  px: "pixel"
};
const secondaryUnitConverters = {
  ms: {
    name: "millisecond",
    unit: "s",
    scale: 1 / 1000,
    offset: 0
  },
  min: {
    name: "minute",
    unit: "s",
    scale: 60,
    offset: 0
  },
  h: {
    name: "hour",
    unit: "s",
    scale: 3600,
    offset: 0
  },
  MHz: {
    name: "megahertz",
    unit: "Hz",
    scale: 1000000,
    offset: 0
  },
  kW: {
    name: "kilowatt",
    unit: "W",
    scale: 1000,
    offset: 0
  },
  kVA: {
    name: "kilovolt-ampere",
    unit: "VA",
    scale: 1000,
    offset: 0
  },
  kvar: {
    name: "kilovar",
    unit: "var",
    scale: 1000,
    offset: 0
  },
  Ah: {
    name: "ampere-hour",
    unit: "C",
    scale: 3600,
    offset: 0
  },
  Wh: {
    name: "watt-hour",
    unit: "J",
    scale: 3600,
    offset: 0
  },
  kWh: {
    name: "kilowatt-hour",
    unit: "J",
    scale: 3600000,
    offset: 0
  },
  varh: {
    name: "var-hour",
    unit: "vars",
    scale: 3600,
    offset: 0
  },
  kvarh: {
    name: "kilovar-hour",
    unit: "vars",
    scale: 3600000,
    offset: 0
  },
  kVAh: {
    name: "kilovolt-ampere-hour",
    unit: "VAs",
    scale: 3600000,
    offset: 0
  },
  "Wh/km": {
    name: "watt-hour per kilometer",
    unit: "J/m",
    scale: 3.6,
    offset: 0
  },
  KiB: {
    name: "kibibyte",
    unit: "B",
    scale: 1024,
    offset: 0
  },
  GB: {
    name: "gigabyte",
    unit: "B",
    scale: 1.0e9,
    offset: 0
  },
  "Mbit/s": {
    name: "megabit per second",
    unit: "bit/s",
    scale: 1000000,
    offset: 0
  },
  "B/s": {
    name: "byte per second",
    unit: "bit/s",
    scale: 8,
    offset: 0
  },
  "MB/s": {
    name: "megabyte per second",
    unit: "bit/s",
    scale: 8000000,
    offset: 0
  },
  mV: {
    name: "millivolt",
    unit: "V",
    scale: 1 / 1000,
    offset: 0
  },
  mA: {
    name: "milliampere",
    unit: "A",
    scale: 1 / 1000,
    offset: 0
  },
  dBm: {
    name: "decibel (milliwatt)",
    unit: "dBW",
    scale: 1,
    offset: -30
  },
  "ug/m3": {
    name: "microgram per cubic meter",
    unit: "kg/m3",
    scale: 1.0e-9,
    offset: 0
  },
  "mm/h": {
    name: "millimeter per hour",
    unit: "m/s",
    scale: 1 / 3600000,
    offset: 0
  },
  "m/h": {
    name: "meter per hour",
    unit: "m/s",
    scale: 1 / 3600,
    offset: 0
  },
  "cm/s": {
    name: "centimeter per seconds",
    unit: "m/s",
    scale: 1 / 100,
    offset: 0
  },
  ppm: {
    name: "parts per million",
    unit: "/",
    scale: 1.0e-6,
    offset: 0
  },
  ppb: {
    name: "parts per billion",
    unit: "/",
    scale: 1.0e-9,
    offset: 0
  },
  "/100": {
    name: "percent",
    unit: "/",
    scale: 1 / 100,
    offset: 0
  },
  "%": {
    name: "percent",
    unit: "/",
    scale: 1 / 100,
    offset: 0
  },
  "/1000": {
    name: "permille",
    unit: "/",
    scale: 1 / 1000,
    offset: 0
  },
  hPa: {
    name: "hectopascal",
    unit: "Pa",
    scale: 100,
    offset: 0
  },
  mm: {
    name: "millimeter",
    unit: "m",
    scale: 1 / 1000,
    offset: 0
  },
  cm: {
    name: "centimeter",
    unit: "m",
    scale: 1 / 100,
    offset: 0
  },
  km: {
    name: "kilometer",
    unit: "m",
    scale: 1000,
    offset: 0
  },
  "km/h": {
    name: "kilometer per hour",
    unit: "m/s",
    scale: 1 / 3.6,
    offset: 0
  },
  "8ms": {
    name: "8 milliseconds",
    unit: "s",
    scale: 8 / 1000,
    offset: 0
  },
  nm: {
    name: "nanometer",
    unit: "m",
    scale: 1e-9,
    offset: 0
  },
  nT: {
    name: "nano Tesla",
    unit: "T",
    scale: 1e9,
    offset: 0
  },
  // compat with previous Jacdac versions
  frac: {
    name: "ratio",
    unit: "/",
    scale: 1,
    offset: 0
  },
  us: {
    name: "micro seconds",
    unit: "s",
    scale: 1e-6,
    offset: 0
  },
  mWh: {
    name: "micro watt-hour",
    unit: "J",
    scale: 3.6e-3,
    offset: 0
  },
  g: {
    name: "earth gravity",
    unit: "m/s2",
    scale: 9.80665,
    offset: 0
  },
  "#": {
    name: "count",
    unit: "#",
    scale: 1,
    offset: 0
  }
};
const encodings = {
  json: "JSON",
  bitset: "bitset"
};

function resolveUnit(unit) {
  if (!unit) return {
    name: "",
    scale: 1,
    offset: 1
  }; // indentifier
  // seconary unit?

  const su = secondaryUnitConverters[unit];
  if (su) return su;
  const name = unitDescription[unit];
  if (name) return {
    name,
    unit,
    scale: 1,
    offset: 0
  };
  return undefined;
}

function units() {
  const r = [];
  Object.keys(unitDescription).forEach(k => {
    r.push({
      name: k,
      description: unitDescription[k]
    });
    Object.keys(secondaryUnitConverters).filter(scd => secondaryUnitConverters[scd].unit === k).forEach(scd => r.push({
      name: scd,
      description: secondaryUnitConverters[scd].name
    }));
  });
  r.sort((l, r) => l.name.localeCompare(r.name));
  return r;
}
/* check ranges, see system.md
Registers `0x001-0x07f` - r/w common to all services
Registers `0x080-0x0ff` - r/w defined per-service
Registers `0x100-0x17f` - r/o common to all services
Registers `0x180-0x1ff` - r/o defined per-service
Registers `0x200-0xeff` - custom, defined per-service
Registers `0xf00-0xfff` - reserved for implementation, should not be seen on the wire
*/


const identifierRanges = {
  rw: [[0x001, 0x07f], [0x080, 0x0ff], [0x200, 0xeff], [0xf00, 0xfff] // impl
  ],
  ro: [[0x100, 0x17f], [0x180, 0x1ff], [0x200, 0xeff], [0xf00, 0xfff] // impl
  ],
  const: [[0x100, 0x17f], [0x180, 0x1ff], [0x200, 0xeff], [0xf00, 0xfff] // impl
  ],
  command: [[0x000, 0x07f], [0x080, 0xeff], [0xf00, 0xfff]],
  report: [[0x000, 0x07f], [0x080, 0xeff], [0xf00, 0xfff]],
  event: [[0x00, 0x7f], [0x80, 0xff]]
};

function parseServiceSpecificationMarkdownToJSON(filecontent, includes, filename = "") {
  filecontent = (filecontent || "").replace(/\r/g, "");
  const info = {
    name: "",
    status: "experimental",
    shortId: filename.replace(/\.md$/, "").replace(/.*\//, ""),
    camelName: "",
    shortName: "",
    extends: [],
    notes: {},
    classIdentifier: 0,
    enums: {},
    constants: {},
    packets: [],
    tags: []
  };
  let backticksType = "";
  let enumInfo = null;
  let packetInfo = null;
  let pipePacket = null;
  let errors = [];
  let lineNo = 0;
  let noteId = "short";
  let lastCmd;
  let packetsToDescribe;
  let nextModifier = "";
  const systemInfo = includes === null || includes === void 0 ? void 0 : includes["_system"];
  const usedIds = {};

  for (const prev of values(includes || {})) {
    if (prev.classIdentifier) usedIds[prev.classIdentifier + ""] = prev.name;
  }

  try {
    if (includes["_system"] && includes["_base"]) processInclude("_base");

    for (const line of filecontent.split(/\n/)) {
      lineNo++;
      processLine(line);
    }
  } catch (e) {
    error("exception: " + e.message);
  }

  if (errors.length) info.errors = errors;

  for (const k of Object.keys(info.notes)) info.notes[k] = normalizeMD(info.notes[k]);

  for (const v of info.packets) v.description = normalizeMD(v.description);

  if (!info.camelName) info.camelName = camelize(info.name.replace(/\s+/g, " ").replace(/[ -](.)/g, (f, l) => l.toUpperCase()).replace(/[^\w]+/g, "_"));
  if (!info.shortName) info.shortName = info.camelName;
  if (info.camelName == "system") info.classIdentifier = 536870897;else if (info.camelName == "base") info.classIdentifier = 536870899;else if (info.camelName == "sensor") info.classIdentifier = 536870898;
  if (info.shortName != "control" && !info.classIdentifier) error("identifier: not specified");
  info.packets.forEach(pkt => pkt.packFormat = packFormat(info, pkt));
  return info;

  function processLine(line) {
    if (backticksType) {
      if (line.trim() == "```") {
        backticksType = null;
        if (backticksType == "default") return;
      }
    } else {
      const m = /^```(.*)/.exec(line);

      if (m) {
        backticksType = m[1] || "default";
        if (backticksType == "default") return;
      }
    }

    const interpret = backticksType == "default" || line.slice(0, 4) == "    ";

    if (!interpret) {
      const m = /^(#+)\s*(.*)/.exec(line);

      if (m) {
        const [, hd, cont] = m;
        packetsToDescribe = null;
        const newNoteId = cont.trim().toLowerCase();

        if (hd == "#" && !info.name) {
          info.name = cont.trim();
          line = "";
        } else if (newNoteId == "registers" || newNoteId == "commands" || newNoteId == "events" || newNoteId == "examples") {
          noteId = newNoteId;
          line = "";
        } else {
          if (noteId == "short") noteId = "long"; // keep line
        }
      }

      if (packetsToDescribe) {
        for (const iface of packetsToDescribe) iface.description += line + "\n";
      } else {
        if (line || info.notes[noteId]) {
          if (!info.notes[noteId]) info.notes[noteId] = "";
          info.notes[noteId] += line + "\n";
        }
      }
    } else {
      if (packetsToDescribe && packetsToDescribe[0].description) packetsToDescribe = null;
      const expanded = line.replace(/\/\/.*/, "").replace(/[?@:=,{};]/g, s => " " + s + " ").trim();
      if (!expanded) return;
      const words = expanded.split(/\s+/);
      if (/^[;,]/.test(words[words.length - 1])) words.pop();
      let cmd = words[0]; // allow for `command = Foo.Bar` etc (ie. command is not a keyword there)

      if (words[1] == ":" || words[1] == "=") cmd = ":";

      switch (cmd) {
        case "enum":
        case "flags":
          startEnum(words);
          break;

        case "define":
          constant(words);
          break;

        case "meta":
        case "pipe":
        case "report":
        case "command":
        case "const":
        case "ro":
        case "rw":
        case "event":
        case "client":
        case "volatile":
        case "lowlevel":
        case "restricted":
          startPacket(words);
          break;

        case "}":
          if (packetInfo) {
            finishPacket();
          } else if (enumInfo) {
            enumInfo = null;
          } else {
            error("nothing to end here");
          }

          break;

        default:
          if (packetInfo) packetField(words);else if (enumInfo) enumMember(words);else metadataMember(words);
      }
    }
  }

  function finishPacket() {
    const paderr = paddingError(packetInfo);

    if (paderr) {
      packetInfo.packed = true;
      error(`${paderr} in ${packetInfo.kind} ${packetInfo.name}`);
    }

    let repeats = false;
    let hadzero = false;

    for (const p of packetInfo.fields) {
      if (hadzero) {
        error(`field ${p.name} in ${packetInfo.kind} ${packetInfo.name} follows a variable-sized field`);
        break;
      }

      if (p.startRepeats) {
        if (repeats) error(`repeats: can only be specified once; in ${packetInfo.kind} ${packetInfo.name}`);
        repeats = true;
      }

      if (p.storage == 0 && p.type != "string0") {
        if (repeats) {
          error(`variable-sized field ${p.name} in ${packetInfo.kind} ${packetInfo.name} cannot repeat`);
          break;
        }

        hadzero = true;
      }
    }

    const pid = packetInfo.identifier;
    const ranges = identifierRanges[packetInfo.kind];
    if (packetInfo.name != "set_register" && packetInfo.name != "get_register" && ranges && !ranges.some(range => range[0] <= pid && pid <= range[1])) error(`${packetInfo.name} identifier 0x${pid.toString(16)} out of range, expected in ${ranges.map(range => `[${range.map(r => `0x${r.toString(16)}`).join(", ")}]`).join(", ")}`); // additional checks for specific packets

    if (["reading_error", "min_reading", "max_reading", "reading_resolution"].indexOf(packetInfo.identifierName) > -1) {
      const regid = packetInfo.identifierName;
      if (packetInfo.fields.length > 1) error(`${regid} must be a number`);
      const reading = info.packets.find(pkt => pkt.kind === "ro" && pkt.identifierName === "reading");
      if (!reading) error(`${regid} register without a reading register`);else if (packetInfo.fields[0].unit !== reading.fields[0].unit) error(`${regid} unit (${packetInfo.fields[0].unit}) and reading unit (${reading.fields[0].unit}) must match`);
    }

    packetInfo = null;
  }

  function normalizeMD(md) {
    return md.replace(/^\s+/, "").replace(/\s+$/, "");
  }

  function checkBraces(words) {
    if (enumInfo || packetInfo) error("already in braces");

    if (words) {
      if (words[2] != "{") error(`expecting: ${words[0]} NAME {`);
    }

    enumInfo = null;
    packetInfo = null;
  }

  function forceSection(sectionId) {
    if (noteId != sectionId) {
      error(`this is only allowed in ## ${sectionId} not in ## ${noteId}`);
    }
  }

  function generalKind(k) {
    switch (k) {
      case "const":
      case "ro":
      case "rw":
        return "rw";

      default:
        return k;
    }
  }

  function startPacket(words) {
    checkBraces(null);
    let client = undefined;
    let lowLevel = undefined;
    let restricted = undefined;

    if (words[0] === "restricted") {
      restricted = true;
      words.shift();
    } else if (words[0] === "client") {
      client = true;
      words.shift();
    } else if (words[0] === "lowlevel") {
      lowLevel = true;
      words.shift();
    }

    const kindSt = words.shift();
    let kind = "command";

    if (kindSt == "meta") {
      forceSection("commands");
      let w2 = words.shift();
      if (w2 == "pipe") w2 = words.shift();
      if (w2 == "report" || w2 == "command") kind = "meta_pipe_" + w2;else error("invalid token after meta");
    } else if (kindSt == "pipe") {
      forceSection("commands");
      const w2 = words.shift();
      if (w2 == "report" || w2 == "command") kind = "pipe_" + w2;else error("invalid token after pipe");
    } else {
      kind = kindSt;
    }

    if (restricted && kind !== "command") error("restricted only applies to commands");
    let internal = undefined;

    if (words[0] === "internal") {
      internal = true;
      words.shift();
    }

    let volatile = undefined;

    if (words[0] === "volatile") {
      if (kind != "ro" && kind != "rw") error("volatile can only modify ro or rw");
      volatile = true;
      words.shift();
    }

    let name = words.shift();
    const isReport = kind == "report";

    if (isReport && lastCmd && !/^\w+$/.test(name)) {
      words.unshift(name);
      name = lastCmd.name;
    }

    packetInfo = {
      kind,
      name: normalizeName(name),
      identifier: undefined,
      description: "",
      fields: [],
      internal,
      client,
      lowLevel,
      volatile,
      restricted
    };

    if (isReport && lastCmd && name == lastCmd.name) {
      packetInfo.secondary = true;
      lastCmd.hasReport = true;
    }

    if (!packetsToDescribe) packetsToDescribe = [];
    packetsToDescribe.push(packetInfo);

    if (words[0] == "?") {
      words.shift();
      packetInfo.optional = true;
    }

    const prev = info.packets.filter(p => p.name == packetInfo.name);
    if (prev.length == 0) ;else if (prev.length == 1 && prev[0].kind == "command" && packetInfo.kind == "report") ;else {
      error(`packet redefinition ${prev.map(p => p.name).join(", ")} `);
    }

    if (/pipe/.test(kind)) {
      if (!pipePacket) error("pipe definitions can only occur after the pipe-open packet");else packetInfo.pipeType = pipePacket.pipeType;
    }

    const atat = words.indexOf("@");

    if (kind == "pipe_command" || kind == "pipe_report") {
      // no identifier
      packetInfo.identifier = 0;
    } else if (atat >= 0) {
      const w = words[atat + 1];
      let v = parseInt(w);

      if (isNaN(v)) {
        v = 0;

        if (systemInfo) {
          const systemPacket = systemInfo.packets.find(p => p.name == w);

          if (systemPacket) {
            v = systemPacket.identifier;
            packetInfo.identifierName = w;
            if (systemPacket.kind != kind) error(`kind mismatch on ${w}: ${systemPacket.kind} vs ${kind}`);
          } else error(`${w} not found in _system`);
        } else {
          error(`${w} cannot be resolved, since _system is missing`);
        }
      } // if we are accessing the reading or reading_error register, mark it volatile


      if (kind === "ro" && (v === 0x101 || v === 0x106)) packetInfo.volatile = true;
      let isUser = false;
      let isSystem = false;
      let isHigh = 0x200 <= v && v <= 0xeff;

      switch (kind) {
        case "const":
        case "ro":
          forceSection("registers");
          isSystem = 0x100 <= v && v <= 0x17f;
          isUser = 0x180 <= v && v <= 0x1ff;
          break;

        case "rw":
          forceSection("registers");
          isSystem = 0x00 <= v && v <= 0x7f;
          isUser = 0x80 <= v && v <= 0xff;
          break;

        case "report":
        case "command":
          forceSection("commands");
          isSystem = 0x00 <= v && v <= 0x7f;
          isUser = 0x80 <= v && v <= 0xff;
          isHigh = 0x100 <= v && v <= 0xeff;
          break;

        case "event":
          forceSection("events");
          isSystem = 0x00 <= v && v <= 0x7f;
          isUser = 0x80 <= v && v <= 0xff;
          break;
      }

      if (isUser) ;else if (isSystem) {
        if (!packetInfo.identifierName) warn(`${kind} @ ${toHex$1(v)} should be expressed with a name from _system.md`);
      } else if (isHigh) {
        if (!info.highCommands) warn(`${kind} @ ${toHex$1(v)} is from the extended range but 'high: 1' missing`);
      }
      packetInfo.identifier = v;
      words.splice(atat, 2);
    } else {
      if (isReport && lastCmd) packetInfo.identifier = lastCmd.identifier;else error(`@ not found at ${packetInfo.name}`);
    }

    if (info.packets.some(p => generalKind(p.kind) == generalKind(packetInfo.kind) && (!/pipe/.test(p.kind) || p.pipeType == packetInfo.pipeType) && p.identifier == packetInfo.identifier)) {
      error("packet identifier already used");
    }

    info.packets.push(packetInfo);
    if (kind == "command") lastCmd = packetInfo;else lastCmd = null;

    if (words[0] == "=" || words[0] == ":") {
      words.unshift("_");
      packetField(words);
      finishPacket();
    } else {
      const last = words.shift();

      if (last == "{") {
        if (words[0] == "...") words.shift();

        if (words[0] == "}") {
          words.shift();
          finishPacket();
        }

        if (words.length) error(`excessive tokens: ${words[0]}...`);
      } else {
        if (last === undefined && kind == "event") {
          finishPacket();
        } else {
          error("expecting '{'");
        }
      }
    }
  }

  function rangeCheck(tp, v) {
    const [storage, type, typeShift] = normalizeStorageType(tp);
    if (isNaN(v)) return v; // error already reported

    if (storage == 0) {
      error(`numeric values like ${v} not allowed for ${tp}`);
      return v;
    }

    if (v < 0 && storage > 0) {
      error(`negative values like ${v} not allowed for ${tp}`);
      return v;
    }

    if (Math.floor(v) != v && typeShift == 0) {
      error(`only integer values allowed for ${tp}; got ${v}`);
      return v;
    }

    let bits = storage < 0 ? -storage * 8 - 1 : storage * 8;
    bits -= typeShift || 0; // don't use bitshift to allow for more than 32 bits

    let max = 1;

    while (bits--) max *= 2;

    if (-v == max) ;else if (max == 1 && v == 1) ;else {
      if (Math.abs(v) >= max) {
        error(`value ${v} is out of range for ${tp}`);
        return v;
      }
    }
    return v;
  }

  function parseVal(words) {
    const eq = words.shift();
    if (eq != "=" && eq != ":") error("expecting '='");
    const val = words.shift();
    return parseIntCheck(val, true);
  }

  function constant(words) {
    if (words.length != 3) {
      error(`define syntax is "define name value" (${words.join(" ")}}`);
      return;
    }

    const name = words[1];
    const svalue = words[2];
    const hex = /^0x/.test(svalue);
    const value = hex ? parseInt(svalue, 16) : parseInt(svalue);

    if (isNaN(value)) {
      error("invalid numeric value for constant");
      return;
    }

    info.constants[name] = {
      value,
      hex
    };
  }

  function packetField(words) {
    var _a;

    if (words.length == 2 && (words[0] == "repeats" || words[0] == "segmented" || words[0] == "multi-segmented")) {
      nextModifier = words[0];
      return;
    }

    const name = normalizeName(words.shift());
    let defaultValue = undefined;
    let isOptional = undefined;
    let op = words.shift();

    if (op == "?") {
      isOptional = true;
      op = words.shift();
    }

    if (op == "=") {
      defaultValue = parseIntCheck(words.shift(), true);
      op = words.shift();
    }

    if (op != ":") error("expecting ':'");
    const tp = words.shift();
    const [storage, type, typeShift] = normalizeStorageType(tp);
    const isFloat = typeShift === null || undefined;
    let tok = words.shift();
    let unit;
    let encoding;

    if (tok != "{") {
      if (type === "string" || type === "bytes") encoding = normalizeEncoding(tok);else unit = normalizeUnit(tok);
      tok = words.shift();
    }

    if (defaultValue !== undefined) rangeCheck(tp, defaultValue);
    let shift = typeShift || undefined;

    if (unit == "/") {
      // / units should be used with ui0. data
      if (!/^(u0|i1)\.\d+$/.test(tp)) error(`fraction unit must be used with u0.yyy or i1.yyy data types (got ${tp})`);
      shift = Math.abs(storage) * 8;
      if (storage < 0) shift -= 1;
    }

    const field = {
      name,
      unit,
      encoding,
      shift,
      isFloat,
      type,
      storage,
      isSimpleType: canonicalType(storage) == type || undefined,
      defaultValue,
      isOptional,
      multiSegmented: nextModifier == "multi-segmented" || undefined,
      segmented: nextModifier == "segmented" || nextModifier == "multi-segmented" || undefined,
      startRepeats: nextModifier == "repeats" || undefined
    };
    if (!unit) delete field.unit;
    if (!encoding) delete field.encoding;

    if (tok == "{") {
      while (words.length) {
        tok = words.shift();
        if (tok == "}") break;
        tok = camelize(tok);

        switch (tok) {
          case "maxBytes":
            {
              field[tok] = rangeCheck("u8", parseVal(words));
              break;
            }

          case "typicalMin":
          case "typicalMax":
          case "absoluteMin":
          case "absoluteMax":
            {
              field[tok] = rangeCheck(tp, parseVal(words));
              break;
            }

          case "preferredInterval":
            {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              if (packetInfo[tok] !== undefined) error(`field ${tok} already set`);
              packetInfo[tok] = rangeCheck("u32", parseVal(words));
              break;
            }

          default:
            error("unknown constraint: " + tok);
            break;
        }

        if (words[0] == ",") words.shift();
      }

      if (tok == "}") tok = null;
    }

    if (tok) error(`excessive tokens at the end of member: ${tok}...`);
    if (field.typicalMin === undefined && field.typicalMax !== undefined && storage > 0) field.typicalMin = 0;
    if (field.absoluteMin === undefined && field.absoluteMax !== undefined && storage > 0) field.absoluteMin = 0;
    if (!field.storage && field.maxBytes) field.storage = field.maxBytes;

    if (/pipe/.test(type)) {
      packetInfo.pipeType = packetInfo.name;
      if (pipePacket && pipePacket.name == packetInfo.name && packetInfo.kind == "report") ;else {
        pipePacket = packetInfo;
      }
    }

    if (!field.isOptional && ((_a = packetInfo.fields[packetInfo.fields.length - 1]) === null || _a === void 0 ? void 0 : _a.isOptional)) {
      error(`all fields after an optional field have to optional`);
    }

    packetInfo.fields.push(field);
    nextModifier = undefined;
  }

  function startEnum(words) {
    checkBraces(null);
    if (words[2] != ":" || words[4] != "{") error("expecting: enum NAME : TYPE {");
    enumInfo = {
      name: normalizeName(words[1]),
      storage: normalizeStorageType(words[3])[0],
      isFlags: words[0] == "flags" || undefined,
      members: {}
    };
    if (info.enums[enumInfo.name]) error("enum redefinition");
    info.enums[enumInfo.name] = enumInfo;
  }

  function enumMember(words) {
    if (words[1] != "=" || words.length != 3) error(`expecting: FIELD_NAME = INTEGER`);
    enumInfo.members[normalizeName(words[0])] = rangeCheck(canonicalType(enumInfo.storage), parseIntCheck(words[2]));
  }

  function parseIntCheck(w, allowFloat = false) {
    try {
      return parseIntFloat(info, w, allowFloat);
    } catch (e) {
      error(e.message);
      return 0;
    }
  }

  function looksRandom(n) {
    const s = n.toString(16);
    const h = "0123456789abcdef";

    for (let i = 0; i < h.length; ++i) {
      const hh = h[i];
      if (s.indexOf(hh + hh + hh) >= 0) return false;
    }

    if (/f00d|dead|deaf|beef/.test(s)) return false;
    return true;
  }

  function genRandom() {
    for (;;) {
      const m = Math.random() * 268435455 | 268435456;
      if (looksRandom(m)) return m;
    }
  }

  function metadataMember(words) {
    if (!((words[1] == "=" || words[1] == ":") && (words[0] == "tags" || words.length == 3))) error(`expecting: FIELD_NAME = VALUE or FIELD_NAME : VALUE`);

    switch (words[0]) {
      case "extends":
        processInclude(words[2]);
        break;

      case "class":
      case "identifier":
        {
          info.classIdentifier = parseIntCheck(words[2]);
          if (info.name != "Control" && info.classIdentifier == 0) info.classIdentifier = 1;
          const gen = `how about ${toHex$1(genRandom())}`;
          if (!(info.classIdentifier == 0 || 268435457 <= info.classIdentifier && info.classIdentifier <= 536870656 || 536870913 <= info.classIdentifier && info.classIdentifier <= 12884901632)) error(`class identifier out of range; ${gen}`);
          if (!looksRandom(info.classIdentifier)) error(`class identifier doesn't look random; ${gen}`);
          if (usedIds[info.classIdentifier + ""]) error(`class identifier ${toHex$1(info.classIdentifier)} already used in ${usedIds[info.classIdentifier + ""]}; ${gen}`);
          break;
        }

      case "camel":
        info.camelName = words[2];
        break;

      case "short":
        info.shortName = words[2];
        break;

      case "high":
        info.highCommands = !!parseIntCheck(words[2]);
        break;

      case "status":
        if (["stable", "experimental", "deprecated"].indexOf(words[2]) > -1) info.status = words[2];else error("unknown status");
        break;

      case "group":
        info.group = capitalize(words.slice(2).join(" "));
        break;

      case "tags":
        {
          const tags = words.slice(2).filter(w => w != "," && w != ";");
          info.tags = info.tags.concat(tags);
          break;
        }

      default:
        error("unknown metadata field: " + words[0]);
        break;
    }
  }

  function processInclude(name) {
    if (name == "_system") return;
    const inner = includes[name];
    if (!inner) return error("include file not found: " + name);
    if (info.packets.some(pkt => !pkt.derived) || values(info.enums).some(e => !e.derived)) error("extends: only allowed on top of the .md file");
    if (inner.errors) errors = errors.concat(inner.errors);
    const innerEnums = clone(inner.enums);
    Object.keys(innerEnums).filter(k => !info.enums[k]).forEach(k => {
      const ie = innerEnums[k];
      ie.derived = name;
      info.enums[k] = ie;
    });
    const innerPackets = clone(inner.packets.filter(pkt => !info.packets.find(ipkt => ipkt.kind === pkt.kind && ipkt.identifier === pkt.identifier)));
    innerPackets.forEach(pkt => pkt.derived = name);
    info.packets = [...info.packets, ...innerPackets];
    if (inner.highCommands) info.highCommands = true;
    info.extends = inner.extends.concat([name]);
  }

  function clone(v) {
    return JSON.parse(JSON.stringify(v));
  }

  function error(msg) {
    if (!msg) msg = "syntax error";
    if (errors.some(e => e.line == lineNo && e.message == msg)) return;
    errors.push({
      file: filename,
      line: lineNo,
      message: msg
    });
  }

  function warn(msg) {
    if (info.camelName == "system") return; // no warnings in _system

    if (errors.some(e => e.line == lineNo && e.message == msg)) return;
    errors.push({
      file: filename,
      line: lineNo,
      message: msg
    });
  }

  function normalizeName(n) {
    if (!/^\w+$/.test(n)) error("expecting name here");
    if (n.length > 31) error(`name '${n}' too long`);
    return n;
  }

  function normalizeStorageType(tp) {
    if (info.enums[tp]) return [info.enums[tp].storage, tp, 0];
    if (!tp) error("expecting type here");
    const tp2 = tp.replace(/_t$/, "").toLowerCase();
    const m = /^([ui])(\d+)\.(\d+)$/.exec(tp2);

    if (m) {
      const a = parseIntCheck(m[2]);
      const b = parseIntCheck(m[3]);
      const len = a + b;
      if (!(len == 8 || len == 16 || len == 32 || len == 64)) error(`fixed point ${tp} can't be ${len} bits`);
      if (a == 0 && m[1] == "i") error(`fixed point ${tp} can't be i0.X; has to be at least i1.X`);
      return [(m[1] == "i" ? -1 : 1) * (len >> 3), tp2, b];
    }

    switch (tp2) {
      case "bool":
        return [1, tp2, 0];

      case "i8":
      case "u8":
      case "i16":
      case "u16":
      case "i32":
      case "u32":
      case "i64":
      case "u64":
        {
          let sz = parseIntCheck(tp2.replace(/^./, "")) >> 3;
          if (tp2[0] == "i") sz = -sz;
          return [sz, tp2, 0];
        }

      case "f16":
        return [2, tp2, null];

      case "f32":
        return [4, tp2, null];

      case "f64":
        return [8, tp2, null];

      case "pipe":
        return [12, tp2, 0];

      case "pipe_port":
        return [2, tp2, 0];

      case "devid":
        return [8, tp2, 0];

      case "bytes":
      case "string":
      case "string0":
        return [0, tp2, 0];

      default:
        {
          const m = /^u8\[(\d+)\]$/.exec(tp2);
          if (m) return [parseIntCheck(m[1]), tp2, 0];
          error("unknown type: " + tp + " " + tp2);
          return [4, tp2, 0];
        }
    }
  }

  function normalizeEncoding(unit) {
    return unit && encodings[unit.toLowerCase()] || undefined;
  }

  function normalizeUnit(unit) {
    if (unit === undefined || unit === null) return undefined;
    if (unitDescription[unit] || secondaryUnitConverters[unit]) return unit;
    error(`expecting unit, got '${unit}'`);
    return undefined;
  }

  function paddingError(iface) {
    let byteOffset = 0;

    for (const m of iface.fields) {
      const sz = memberSize(m);
      if (sz == 0) continue;
      const pad = sz > 4 ? 4 : sz;
      if (!/^u8\[/.test(m.type) && byteOffset % pad != 0) return `need padding of ${pad - byteOffset % pad} byte(s) before ${m.name}`;
      byteOffset += sz;
    }

    return null;
  }
}

function values(o) {
  const r = [];

  for (const k of Object.keys(o)) r.push(o[k]);

  return r;
}

function toUpper(name) {
  return name === null || name === void 0 ? void 0 : name.replace(/([a-z])([A-Z])/g, (x, a, b) => a + "_" + b).toUpperCase();
}

function toLower(name) {
  return name === null || name === void 0 ? void 0 : name.replace(/([a-z])([A-Z])/g, (x, a, b) => a + "_" + b).toLowerCase();
}

function packed(iface) {
  if (!iface.packed) return "";else return " __attribute__((packed))";
}

function cStorage(tp) {
  if (tp == 0 || [1, 2, 4, 8].indexOf(Math.abs(tp)) < 0) return "bytes";
  if (tp < 0) return `int${-tp * 8}_t`;else return `uint${tp * 8}_t`;
}

function cSharpStorage(tp) {
  if (tp == 0 || [1, 2, 4, 8].indexOf(Math.abs(tp)) < 0) return "bytes";

  switch (tp) {
    case -1:
      return "sbyte";

    case 1:
      return "byte";

    case -2:
      return "short";

    case 2:
      return "ushort";

    case -4:
      return "int";

    case 4:
      return "uint";
  }

  return `unknown({${tp})`;
}

function canonicalType(tp) {
  if (tp == 0) return "bytes";
  if (tp < 0) return `i${-tp * 8}`;else return `u${tp * 8}`;
}

function isRegister$1(k) {
  return k == "ro" || k == "rw" || k == "const";
}

function toHex$1(n) {
  if (n === undefined) return "";
  if (n < 0) return "-" + toHex$1(n);
  return "0x" + n.toString(16);
}

function unitPref(f) {
  if (!f.unit) return "";else return prettyUnit$1(f.unit) + " ";
}

function prettyUnit$1(u) {
  switch (u) {
    case "us":
      return "μs";

    case "C":
      return "°C";

    case "/":
      return "ratio";

    default:
      return u;
  }
}

function toPython(info) {
  const r = ["# Autogenerated file for " + info.name, `# Add missing from ... import const`];
  let pref = "JD_" + toUpper(info.shortName) + "_";
  if (info.shortId[0] == "_") pref = "JD_";
  if (info.shortId[0] != "_") r.push(`_JD_SERVICE_CLASS_${toUpper(info.shortName)} = const(${toHex$1(info.classIdentifier)})`);

  for (const cst in info.constants) {
    const {
      value,
      hex
    } = info.constants[cst];
    r.push(`_JD_${toUpper(cst)} = const(${hex ? value.toString() : toHex$1(value)})\n`);
  }

  for (const en of values(info.enums).filter(en => !en.derived)) {
    const enPref = pref + toUpper(en.name);

    for (const k of Object.keys(en.members)) r.push(`_${enPref}_${toUpper(k)} = const(${toHex$1(en.members[k])})`);
  }

  for (const pkt of info.packets) {
    if (pkt.derived) continue;

    if (!pkt.secondary && pkt.kind != "pipe_command" && pkt.kind != "pipe_report") {
      let inner = "CMD";
      if (isRegister$1(pkt.kind)) inner = "REG";else if (pkt.kind == "event") inner = "EV";else if (pkt.kind == "meta_pipe_command" || pkt.kind == "meta_pipe_report") inner = "PIPE";
      let val = toHex$1(pkt.identifier);

      if (pkt.identifierName) {
        // TODO find identifier and inline it
        val = "JD_" + inner + "_" + toUpper(pkt.identifierName);
      }

      const name = pref + inner + "_" + toUpper(pkt.name);
      if (name != val) r.push(`_${name} = const(${val})`);
    }
  }

  return r.join("\n");
}

function toH(info) {
  let r = "// Autogenerated C header file for " + info.name + "\n";
  const hdDef = `_JACDAC_SPEC_${toUpper(info.camelName)}_H`;
  r += `#ifndef ${hdDef}\n`;
  r += `#define ${hdDef} 1\n`;
  let pref = "JD_" + toUpper(info.shortName) + "_";
  if (info.shortId[0] == "_") pref = "JD_";
  if (info.shortId[0] != "_") r += `\n#define JD_SERVICE_CLASS_${toUpper(info.shortName)}  ${toHex$1(info.classIdentifier)}\n`;

  for (const cst in info.constants) {
    const {
      value,
      hex
    } = info.constants[cst];
    r += `#define ${pref}${toUpper(cst)} ${hex ? toHex$1(value) : value.toString()}\n`;
  }

  for (const en of values(info.enums).filter(en => !en.derived)) {
    const enPref = pref + toUpper(en.name);
    r += `\n// enum ${en.name} (${cStorage(en.storage)})\n`;

    for (const k of Object.keys(en.members)) r += "#define " + enPref + "_" + toUpper(k) + " " + toHex$1(en.members[k]) + "\n";
  }

  for (const pkt of info.packets) {
    if (pkt.derived) continue;
    const cmt = addComment(pkt);
    r += wrapComment(cmt.comment);

    if (!pkt.secondary && pkt.kind != "pipe_command" && pkt.kind != "pipe_report") {
      let inner = "CMD";
      if (isRegister$1(pkt.kind)) inner = "REG";else if (pkt.kind == "event") inner = "EV";else if (pkt.kind == "meta_pipe_command" || pkt.kind == "meta_pipe_report") inner = "PIPE";
      let val = toHex$1(pkt.identifier);
      if (pkt.identifierName) val = "JD_" + inner + "_" + toUpper(pkt.identifierName);
      const name = pref + inner + "_" + toUpper(pkt.name);
      if (name != val) r += `#define ${name} ${val}\n`;
    }

    const isMetaPipe = pkt.kind == "meta_pipe_report" || pkt.kind == "meta_pipe_command";

    if (cmt.needsStruct || isMetaPipe) {
      let tname = "jd_" + toLower(info.camelName) + "_" + toLower(pkt.name);
      if (pkt.kind == "report") tname += "_report";
      r += `typedef struct ${tname} {\n`;

      if (isMetaPipe) {
        r += `    uint32_t identifier; // ${toHex$1(pkt.identifier)}\n`;
      }

      let unaligned = "";

      for (let i = 0; i < pkt.fields.length; ++i) {
        const f = pkt.fields[i];
        let def = "";
        const cst = cStorage(f.storage);
        const sz = memberSize(f);
        if (f.type == "string" || f.type == "string0") def = `char ${f.name}[${sz}]`;else if (cst == "bytes") def = `uint8_t ${f.name}[${sz}]`;else def = `${cst} ${f.name}`; // if it's the last field and it start repeats, treat it as an array

        if (f.startRepeats && i == pkt.fields.length - 1) def += "[0]";
        def += ";";
        if (!f.isSimpleType && f.type != "devid") def += "  // " + unitPref(f) + f.type;else if (f.unit) def += " // " + prettyUnit$1(f.unit);
        r += "    " + unaligned + def + "\n";
        if (f.type == "string0") unaligned = "// ";
      }

      r += `}${packed(pkt)} ${tname}_t;\n\n`;
    }
  }

  r += "\n#endif\n";
  return r;
}

function camelize(name) {
  if (!name) return name;
  return name[0].toLowerCase() + name.slice(1).replace(/_([a-z0-9])/gi, (_, l) => l.toUpperCase());
}

function capitalize(name) {
  if (!name) return name;
  return name[0].toUpperCase() + name.slice(1);
}

function upperCamel(name) {
  name = camelize(name);
  if (!(name === null || name === void 0 ? void 0 : name.length)) return name;
  return name[0].toUpperCase() + name.slice(1);
}

function snakify(name) {
  return name === null || name === void 0 ? void 0 : name.replace(/([a-z])([A-Z])/g, (_, a, b) => a + "_" + b);
}

function dashify(name) {
  if (!name) return name;
  return snakify(name.replace(/^_+/, "")).replace(/(_|\s)+/g, "-").toLowerCase();
}

function humanify(name) {
  return name === null || name === void 0 ? void 0 : name.replace(/([a-z])([A-Z])/g, (_, a, b) => a + " " + b).replace(/(-|_)/g, " ");
}

function addComment(pkt) {
  let comment = "";
  let typeInfo = "";
  let needsStruct = false;

  if (pkt.fields.length == 0) {
    if (pkt.kind != "event") typeInfo = "No args";
  } else if (pkt.fields.length == 1 && !pkt.fields[0].startRepeats) {
    const f0 = pkt.fields[0];
    typeInfo = cStorage(f0.storage);
    if (!f0.isSimpleType) typeInfo = f0.type + " (" + typeInfo + ")";
    typeInfo = unitPref(f0) + typeInfo;
    if (f0.name != "_") typeInfo = f0.name + " " + typeInfo;
  } else {
    needsStruct = true;
  }

  if (pkt.fields.length == 1) {
    if (isRegister$1(pkt.kind)) {
      let info = "";
      if (pkt.kind == "ro") info = "Read-only";else if (pkt.kind == "const") info = "Constant";else info = "Read-write";
      if (typeInfo) typeInfo = info + " " + typeInfo;else typeInfo = info;
    } else if (typeInfo) {
      typeInfo = "Argument: " + typeInfo;
    }
  }

  if (pkt.kind == "report" && pkt.secondary) {
    comment += "Report: " + typeInfo + "\n";
  } else {
    if (pkt.description) {
      let desc = pkt.description.replace(/\n\n[^]*/, "");
      if (typeInfo) desc = typeInfo + ". " + desc;
      comment = desc + "\n" + comment;
    }
  }

  return {
    comment,
    needsStruct
  };
}

function wrapComment(comment) {
  return "\n/**\n * " + comment.replace(/\n+$/, "").replace(/\n/g, "\n * ") + "\n */\n";
}

function wrapSnippet(code) {
  if (!code) return code;
  return `
\`\`\`
${code.replace(/^\n+/, "").replace(/\n+$/, "")}
\`\`\`
`;
}

const TYPESCRIPT_STATIC_NAMESPACE = "jacdac";

function packFormatForField(info, fld, isStatic, useBooleans) {
  const sz = memberSize(fld);
  const szSuff = sz ? `[${sz}]` : ``;
  let tsType = "number";
  let fmt = "";

  if (/^[fiu]\d+(\.\d+)?$/.test(fld.type) && 1 <= sz && sz <= 8) {
    fmt = fld.type;
  } else if (/^u8\[\d*\]$/.exec(fld.type)) {
    fmt = "b" + szSuff;
  } else if (info.enums[fld.type]) {
    fmt = canonicalType(info.enums[fld.type].storage);
    tsType = upperCamel(info.camelName) + upperCamel(fld.type);
    if (isStatic) tsType = TYPESCRIPT_STATIC_NAMESPACE + "." + tsType;
  } else {
    switch (fld.type) {
      case "string":
        fmt = "s" + szSuff;
        tsType = "string";
        break;

      case "bytes":
        fmt = "b" + szSuff;
        break;

      case "string0":
        fmt = "z";
        tsType = "string";
        break;

      case "devid":
        fmt = "b[8]";
        break;

      case "pipe_port":
        fmt = "u16";
        break;

      case "pipe":
        fmt = "b[12]";
        break;

      case "bool":
        // TODO native bool support
        fmt = "u8";
        if (useBooleans) tsType = "boolean";
        break;

      default:
        return null;
    }
  }

  if (tsType == "number" && fmt && fmt[0] == "b") tsType = "Buffer";
  return {
    fmt,
    tsType
  };
}
/**
 * Generates the format to pack/unpack a data payload for this packet
 * @param pkt
 * TODO fix this
 */


function packFormat(sinfo, pkt, useBooleans) {
  var _a;

  if (pkt.packed || !((_a = pkt.fields) === null || _a === void 0 ? void 0 : _a.length)) return undefined;
  const fmt = [];

  for (const fld of pkt.fields) {
    if (fld.startRepeats) fmt.push("r:");
    const ff = packFormatForField(sinfo, fld, false, useBooleans);
    if (!ff) return undefined;
    fmt.push(ff.fmt);
  }

  return fmt.join(" ");
}

function packInfo(info, pkt, options) {
  const {
    isStatic = false,
    useBooleans = false,
    useJDOM = false
  } = options || {};
  const {
    kind
  } = pkt;
  const vars = [];
  const vartp = [];
  let fmt = "";
  let repeats;
  let reptp;

  for (let i = 0; i < pkt.fields.length; ++i) {
    const fld = pkt.fields[i];
    let isArray = "";

    if (fld.startRepeats) {
      if (i == pkt.fields.length - 1) {
        isArray = "[]";
      } else {
        fmt += "r: ";
        repeats = [];
        reptp = [];
        vars.push("rest");
      }
    }

    const varname = camelize(fld.name == "_" ? pkt.name : fld.name);
    const f0 = packFormatForField(info, fld, isStatic, useBooleans);

    if (!f0 || /(reserved|padding)/.test(fld.name)) {
      if (!f0) console.log(`${pkt.name}/${fld.name} - can't get format for '${fld.type}'`);
      fmt += `x[${memberSize(fld)}] `;
    } else {
      fmt += f0.fmt + isArray + " ";
      let tp = f0.tsType;
      if (tp == "Buffer" && !isStatic) tp = "Uint8Array";
      tp += isArray;

      if (repeats) {
        repeats.push(varname);
        reptp.push(tp);
      } else {
        vars.push(varname);
        vartp.push(tp);
      }
    }
  }

  fmt = fmt.replace(/ *$/, "");
  if (reptp) vartp.push("([" + reptp.join(", ") + "])[]");
  const pktName = camelize(pkt.name);
  let buffers = "";

  if (useJDOM) {
    if (kind === "command") {
      for (let i = 0; i < vars.length; ++i) buffers += `const ${vars[i]}: ${vartp[i]} = ...\n`;

      buffers += `await service.sendCmdPackedAsync(${capitalize(info.camelName)}Reg.${capitalize(pktName)}, [${vars.join(", ")}])\n`;
    } else if (isRegister$1(kind)) {
      buffers += "// get (register to REPORT_UPDATE event to enable background refresh)\n";
      buffers += `const ${pktName}Reg = service.register(${capitalize(info.camelName)}Reg.${capitalize(pktName)})\n`;
      buffers += `const [${vars.join(", ")}] : [${vartp.join(", ")}] = ${pktName}Reg.unpackedValue\n`;

      if (kind === "rw") {
        buffers += "// set\n";
        buffers += `await ${pktName}Reg.sendSetPackedAsync([${vars.join(", ")}])\n`;
      }
    }
  } else {
    buffers += `const [${vars.join(", ")}] = jdunpack<[${vartp.join(", ")}]>(buf, "${fmt}")\n`;
  }

  if (repeats) buffers += `const [${repeats.join(", ")}] = rest[0]\n`;
  buffers = buffers.replace(/\n*$/, "");
  return {
    buffers,
    names: vars,
    types: vartp
  };
}

function memberSize(fld) {
  return Math.abs(fld.storage);
}

function toTypescript(info, language) {
  const sts = language === "sts";
  const csharp = language === "c#";
  const useNamespace = sts || csharp;
  const indent = useNamespace ? "    " : "";
  const indent2 = indent + "    ";
  const numberkw = csharp ? "uint " : "";
  const hexkw = csharp ? "byte[]" : "";
  const enumkw = csharp ? indent + "public enum" : sts ? indent + "export const enum" : "export enum";
  const exportkw = csharp ? "public" : "export";
  const cskw = csharp ? ";" : "";
  let r = useNamespace ? `namespace ${csharp ? capitalize(TYPESCRIPT_STATIC_NAMESPACE) : TYPESCRIPT_STATIC_NAMESPACE} {\n` : "";
  r += indent + "// Service: " + info.name + "\n";

  if (csharp) {
    r += `${indent}public static class ${capitalize(info.camelName)}Constants\n${indent}{\n`;
  }

  if (info.shortId[0] != "_") {
    const name = csharp ? "ServiceClass" : `SRV_${snakify(info.camelName).toLocaleUpperCase()}`;
    r += indent + (csharp ? indent : "") + `${exportkw} const ${numberkw}${name} = ${toHex$1(info.classIdentifier)}${cskw}\n`;
  }

  const pref = upperCamel(info.camelName);

  for (const cst in info.constants) {
    const {
      value,
      hex
    } = info.constants[cst];
    r += indent + (csharp ? indent : "") + `${exportkw} const ${hex ? hexkw : numberkw}${csharp ? capitalize(camelize(cst)) : toUpper(cst)} = ${hex ? value.toString() : toHex$1(value)}${cskw}\n`;
  }

  if (csharp) {
    r += indent + `}\n`;
  }

  for (const en of values(info.enums)) {
    const enPref = pref + upperCamel(en.name);
    r += `\n${enumkw} ${enPref}${csharp ? `: ${cSharpStorage(en.storage)}` : ""} { // ${cStorage(en.storage)}\n`;

    for (const k of Object.keys(en.members)) {
      if (sts) r += indent2 + `//% block="${humanify(k).toLowerCase()}"\n`;
      r += indent2 + k + " = " + toHex$1(en.members[k]) + ",\n";
    }

    r += indent + "}\n\n";
  }

  const tsEnums = {};

  for (const pkt of info.packets) {
    if (pkt.derived) continue;
    const cmt = addComment(pkt);
    const pack = pkt.fields.length ? packInfo(info, pkt, {
      isStatic: sts,
      useBooleans: false
    }).buffers : "";
    let inner = "Cmd";
    if (isRegister$1(pkt.kind)) inner = "Reg";else if (pkt.kind == "event") inner = "Event";else if (pkt.kind == "meta_pipe_command" || pkt.kind == "meta_pipe_report") inner = "PipeCmd";else if (pkt.kind == "pipe_command" || pkt.kind == "pipe_report") inner = "info";
    let text = "";
    let meta = "";

    if (pkt.secondary || inner == "info") {
      if (pack) text = wrapComment(`${pkt.kind} ${upperCamel(pkt.name)}${pkt.client ? "" : wrapSnippet(pack)}`);
    } else {
      const val = toHex$1(pkt.identifier);

      if (sts && pkt.kind === "event") {
        meta = `//% block="${snakify(pkt.name).replace(/_/g, " ")}"\n`;
      }

      text = `${wrapComment(cmt.comment + (pkt.client ? "" : wrapSnippet(pack))) + meta}${upperCamel(pkt.name)} = ${val},\n`;
    }

    if (text) tsEnums[inner] = (tsEnums[inner] || "") + text; // don't line const strings in makecode,
    // they don't get dropped efficiently
  }

  for (const k of Object.keys(tsEnums)) {
    if (k == "info") r += tsEnums[k].replace(/^/gm, indent) + "\n\n";else {
      const inner = tsEnums[k].replace(/^\n+/, "").replace(/\n$/, "").replace(/\n/g, "\n    " + indent);
      r += `${enumkw} ${pref}${k} {\n    ${indent}${inner}\n${indent}}\n\n`;
    }
  }

  if (useNamespace) r += "}\n";
  return r.replace(/ *$/gm, "");
}

function generateDeviceSpecificationId(dev) {
  return escapeDeviceIdentifier(dev.company) + "-" + escapeDeviceNameIdentifier(dev.name) + (dev.designIdentifier || "") + (dev.version ? `v${dev.version.toLowerCase().replace(/^v/, "").replace(/\./g, "")}` : "").toLowerCase();
}

function normalizeDeviceSpecification(dev) {
  var _a; // reorder fields


  const clone = {
    id: generateDeviceSpecificationId(dev),
    name: dev.name,
    company: dev.company,
    description: dev.description,
    repo: dev.repo,
    link: dev.link,
    services: dev.services,
    productIdentifiers: dev.productIdentifiers,
    transport: (_a = dev.transport) === null || _a === void 0 ? void 0 : _a.toLowerCase(),
    tags: dev.tags,
    firmwares: dev.firmwares,
    version: dev.version ? dev.version.replace(/^v/, "") : undefined,
    designIdentifier: dev.designIdentifier
  };
  if (dev.status !== undefined) clone.status = dev.status;
  return clone;
}

function escapeDeviceIdentifier(text) {
  if (!text) text = "";
  const escaped = text.trim().toLowerCase().replace(/([^a-z0-9_-])+/gi, "-").replace(/\./g, "") // routing does not like dots
  .replace(/^-+/, "").replace(/-+$/, "");
  const id = snakify(escaped);
  return id;
}

function escapeDeviceNameIdentifier(text) {
  return escapeDeviceIdentifier(text).replace(/-/g, "");
}

function converters() {
  return {
    json: j => JSON.stringify(j, null, 2),
    c: toH,
    ts: j => toTypescript(j, "ts"),
    sts: j => toTypescript(j, "sts"),
    cs: j => toTypescript(j, "c#"),
    py: j => toPython(j)
    /*
    "cpp": toHPP,
    */

  };
}

function isNumericType(field) {
  const tp = field.type;
  return !field.startRepeats && /^[uif]\d+(\.\d+)?$/.test(tp) && tp != "pipe_port" && tp != "bool";
}
/**
 * Various flags to control the runtime environment
 * @category Runtime
 */


class Flags {}
/**
 * Enables additional logging and diagnostics
 */


Flags.diagnostics = false;
/**
 * Trace who and what generates packets
 */

Flags.trace = false;
/**
 * Enables/disabled WebUSB
 */

Flags.webUSB = true;
/**
 * Enables/disabled WebSerial
 */

Flags.webSerial = true;
/**
 * Enables/disables WebBLE
 */

Flags.webBluetooth = false;

function throwError(msg, cancel) {
  const e = new Error(msg);
  if (cancel) // eslint-disable-next-line @typescript-eslint/no-explicit-any
    e.__cancel = true;
  throw e;
}

function isCancelError(e) {
  var _a; // eslint-disable-next-line @typescript-eslint/no-explicit-any


  return !!((_a = e) === null || _a === void 0 ? void 0 : _a.__cancel);
}

function setAckError(e) {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  if (e) e.__ack = true;
}

function isAckError(e) {
  var _a; // eslint-disable-next-line @typescript-eslint/no-explicit-any


  return !!((_a = e) === null || _a === void 0 ? void 0 : _a.__ack);
}

function delay(millis, value) {
  return new Promise(resolve => setTimeout(() => resolve(value), millis));
}

function memcpy(trg, trgOff, src, srcOff, len) {
  if (srcOff === void 0) srcOff = 0;
  if (len === void 0) len = src.length - srcOff;

  for (let i = 0; i < len; ++i) trg[trgOff + i] = src[srcOff + i];
}

function strcmp(a, b) {
  if (a == b) return 0;
  if (a < b) return -1;else return 1;
}

function bufferEq(a, b, offset = 0) {
  if (a == b) return true;
  if (!a || !b || a.length != b.length) return false;

  for (let i = offset; i < a.length; ++i) {
    if (a[i] != b[i]) return false;
  }

  return true;
}

function hash(buf, bits) {
  bits |= 0;
  if (bits < 1) return 0;
  const h = fnv1(buf);
  if (bits >= 32) return h >>> 0;else return ((h ^ h >>> bits) & (1 << bits) - 1) >>> 0;
}

function idiv(a, b) {
  return (a | 0) / (b | 0) | 0;
}

function fnv1(data) {
  let h = 0x811c9dc5;

  for (let i = 0; i < data.length; ++i) {
    h = Math.imul(h, 0x1000193) ^ data[i];
  }

  return h;
}

function crc(p) {
  let crc = 0xffff;

  for (let i = 0; i < p.length; ++i) {
    const data = p[i];
    let x = crc >> 8 ^ data;
    x ^= x >> 4;
    crc = crc << 8 ^ x << 12 ^ x << 5 ^ x;
    crc &= 0xffff;
  }

  return crc;
}

function ALIGN(n) {
  return n + 3 & ~3;
} // this will take lower 8 bits from each character


function stringToUint8Array(input) {
  const len = input.length;
  const res = new Uint8Array(len);

  for (let i = 0; i < len; ++i) res[i] = input.charCodeAt(i) & 0xff;

  return res;
}

function uint8ArrayToString(input) {
  const len = input.length;
  let res = "";

  for (let i = 0; i < len; ++i) res += String.fromCharCode(input[i]);

  return res;
}

function fromUTF8(binstr) {
  if (!binstr) return ""; // escape function is deprecated

  let escaped = "";

  for (let i = 0; i < binstr.length; ++i) {
    const k = binstr.charCodeAt(i) & 0xff;

    if (k == 37 || k > 0x7f) {
      escaped += "%" + k.toString(16);
    } else {
      escaped += binstr.charAt(i);
    }
  } // decodeURIComponent does the actual UTF8 decoding


  return decodeURIComponent(escaped);
}

function toUTF8(str, cesu8) {
  let res = "";
  if (!str) return res;

  for (let i = 0; i < str.length; ++i) {
    let code = str.charCodeAt(i);
    if (code <= 0x7f) res += str.charAt(i);else if (code <= 0x7ff) {
      res += String.fromCharCode(0xc0 | code >> 6, 0x80 | code & 0x3f);
    } else {
      if (!cesu8 && 0xd800 <= code && code <= 0xdbff) {
        const next = str.charCodeAt(++i);
        if (!isNaN(next)) code = 0x10000 + (code - 0xd800 << 10) + (next - 0xdc00);
      }

      if (code <= 0xffff) res += String.fromCharCode(0xe0 | code >> 12, 0x80 | code >> 6 & 0x3f, 0x80 | code & 0x3f);else res += String.fromCharCode(0xf0 | code >> 18, 0x80 | code >> 12 & 0x3f, 0x80 | code >> 6 & 0x3f, 0x80 | code & 0x3f);
    }
  }

  return res;
}
/** @internal */


class PromiseBuffer {
  constructor() {
    this.waiting = [];
    this.available = [];
  }

  drain() {
    for (const f of this.waiting) {
      f(new Error("Promise Buffer Reset"));
    }

    this.waiting = [];
    this.available = [];
  }

  pushError(v) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    this.push(v);
  }

  push(v) {
    const f = this.waiting.shift();
    if (f) f(v);else this.available.push(v);
  }

  shiftAsync(timeout = 0) {
    if (this.available.length > 0) {
      const v = this.available.shift();
      if (v instanceof Error) return Promise.reject(v);else return Promise.resolve(v);
    } else return new Promise((resolve, reject) => {
      const f = v => {
        if (v instanceof Error) reject(v);else resolve(v);
      };

      this.waiting.push(f);

      if (timeout > 0) {
        delay(timeout).then(() => {
          const idx = this.waiting.indexOf(f);

          if (idx >= 0) {
            this.waiting.splice(idx, 1);
            reject(new Error("Timeout"));
          }
        });
      }
    });
  }

}
/** @internal */


class PromiseQueue {
  constructor() {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    this.promises = {};
  }

  enqueue(id, f) {
    return new Promise((resolve, reject) => {
      let arr = this.promises[id];

      if (!arr) {
        arr = this.promises[id] = [];
      }

      const cleanup = () => {
        arr.shift();
        if (arr.length == 0) delete this.promises[id];else arr[0]();
      };

      arr.push(() => f().then(v => {
        cleanup();
        resolve(v);
      }, err => {
        cleanup();
        reject(err);
      }));
      if (arr.length == 1) arr[0]();
    });
  }

}

function rgbToHtmlColor(rgb) {
  return `#${("000000" + rgb.toString(16)).slice(-6)}`;
}

function toFullHex(n) {
  return "0x" + n.map(id => ("000000000" + id.toString(16)).slice(-8)).join("");
}

function toHex(bytes) {
  if (!bytes) return undefined;
  let r = "";

  for (let i = 0; i < bytes.length; ++i) r += ("0" + bytes[i].toString(16)).slice(-2);

  return r;
}

function fromHex(hex) {
  const r = new Uint8Array(hex.length >> 1);

  for (let i = 0; i < hex.length; i += 2) r[i >> 1] = parseInt(hex.slice(i, i + 2), 16);

  return r;
}

function isSet(v) {
  return v !== null && v !== undefined;
}

function toArray(a) {
  const r = new Array(a.length);

  for (let i = 0; i < a.length; ++i) r[i] = a[i];

  return r;
}

function hexNum(n) {
  if (isNaN(n)) return undefined;
  if (n < 0) return "-" + hexNum(-n);
  return "0x" + n.toString(16);
}

function write32(buf, pos, v) {
  buf[pos + 0] = v >> 0 & 0xff;
  buf[pos + 1] = v >> 8 & 0xff;
  buf[pos + 2] = v >> 16 & 0xff;
  buf[pos + 3] = v >> 24 & 0xff;
}

function write16(buf, pos, v) {
  buf[pos + 0] = v >> 0 & 0xff;
  buf[pos + 1] = v >> 8 & 0xff;
}

function read32(buf, pos) {
  return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
}

function read16(buf, pos) {
  return buf[pos] | buf[pos + 1] << 8;
}

function encodeU32LE(words) {
  const r = new Uint8Array(words.length * 4);

  for (let i = 0; i < words.length; ++i) write32(r, i * 4, words[i]);

  return r;
}

function decodeU32LE(buf) {
  const res = [];

  for (let i = 0; i < buf.length; i += 4) res.push(read32(buf, i));

  return res;
}

function isBufferEmpty(data) {
  if (!data) return true;
  const n = data.length;

  for (let i = 0; i < n; ++i) {
    if (data[i]) return false;
  }

  return true;
}

function bufferToString(buf) {
  return fromUTF8(uint8ArrayToString(buf));
}

function stringToBuffer(str) {
  return stringToUint8Array(toUTF8(str));
}

function bufferConcat(a, b) {
  const r = new Uint8Array(a.length + b.length);
  r.set(a, 0);
  r.set(b, a.length);
  return r;
}

function bufferConcatMany(bufs) {
  let sz = 0;

  for (const buf of bufs) sz += buf.length;

  const r = new Uint8Array(sz);
  sz = 0;

  for (const buf of bufs) {
    r.set(buf, sz);
    sz += buf.length;
  }

  return r;
}

function arrayConcatMany(arrs) {
  if (!arrs) return undefined; // weed out empty array

  arrs = arrs.filter(a => !!(a === null || a === void 0 ? void 0 : a.length));
  let sz = 0;

  for (const buf of arrs) sz += buf.length;

  const r = new Array(sz);
  sz = 0;

  for (const arr of arrs) {
    for (let i = 0; i < arr.length; ++i) r[i + sz] = arr[i];

    sz += arr.length;
  }

  return r;
}

function jsonCopyFrom(trg, src) {
  const v = clone(src);

  for (const k of Object.keys(src)) {
    trg[k] = v[k];
  }
}

function assert(cond, msg = "Assertion failed", // eslint-disable-next-line @typescript-eslint/no-explicit-any
debugData) {
  if (!cond) {
    if (debugData) console.debug(`assertion filed ${msg}`, debugData);
    if (Flags.diagnostics) // eslint-disable-next-line no-debugger
      debugger;
    throw new Error(msg);
  }
}

function flatClone(obj) {
  if (obj == null) return null; // eslint-disable-next-line @typescript-eslint/no-explicit-any

  const r = {};
  Object.keys(obj).forEach(k => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    r[k] = obj[k];
  });
  return r;
}

function clone(v) {
  if (v == null) return null;
  return JSON.parse(JSON.stringify(v));
}

function throttle(handler, delay) {
  let enableCall = true;
  return function () {
    if (!enableCall) return;
    enableCall = false;
    handler();
    setTimeout(() => enableCall = true, delay);
  };
}

function signal() {
  let resolve;
  return {
    signalled: new Promise(r => {
      resolve = r;
    }),
    signal: () => resolve(true)
  };
}

function readBlobToUint8Array(blob) {
  if (blob.arrayBuffer) {
    return blob.arrayBuffer().then(data => new Uint8Array(data));
  }

  return new Promise((resolve, reject) => {
    const fileReader = new FileReader();

    fileReader.onload = () => {
      resolve(new Uint8Array(fileReader.result));
    };

    fileReader.onerror = e => {
      console.log(e);
      reject(e);
    };

    try {
      fileReader.readAsArrayBuffer(blob);
    } catch (e) {
      reject(e);
    }
  });
}

function readBlobToText(blob) {
  if (blob.text) {
    return blob.text();
  }

  return new Promise((resolve, reject) => {
    const fileReader = new FileReader();

    fileReader.onload = () => resolve(fileReader.result);

    fileReader.onerror = e => {
      console.log(e);
      reject(e);
    };

    try {
      fileReader.readAsText(blob);
    } catch (e) {
      reject(e);
    }
  });
}

function debounce(handler, delay) {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  let timeOutId;
  return function () {
    if (timeOutId) {
      clearTimeout(timeOutId);
    }

    timeOutId = setTimeout(async () => {
      handler();
    }, delay);
  };
}

function debounceAsync(handler, delay) {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  let timeOutId;
  return function () {
    if (timeOutId) {
      clearTimeout(timeOutId);
    }

    timeOutId = setTimeout(async () => {
      await handler();
    }, delay);
  };
}

function JSONTryParse(src) {
  if (src === undefined || src === null) return src;

  try {
    return JSON.parse(src);
  } catch (e) {
    return undefined;
  }
}

function roundWithPrecision(x, digits) {
  digits = digits | 0; // invalid digits input

  if (digits <= 0) return Math.round(x);
  if (x == 0) return 0;
  let r = 0;

  while (r == 0 && digits < 21) {
    const d = Math.pow(10, digits++);
    r = Math.round(x * d + Number.EPSILON) / d;
  }

  return r;
}

function randomRange(min, max) {
  return Math.round(Math.random() * (max - min) + min);
}

function unique(values) {
  return Array.from(new Set(values).keys());
}

function uniqueMap(values, id, converter) {
  const r = {};

  for (let i = 0; i < values.length; ++i) {
    const value = values[i];
    const idv = id(value);

    if (!r[idv]) {
      r[idv] = value;
    }
  }

  return Object.values(r).map(converter);
}

function toMap(a, keyConverter, valueConverter) {
  const m = {};
  if (a) for (let i = 0; i < a.length; ++i) {
    const key = keyConverter(a[i], i);
    if (key === undefined || key === null) continue;
    m[key] = valueConverter(a[i], i);
  }
  return m;
}

function ellipseJoin(values, maxChars, ellipse = "...") {
  let r = "";

  for (let i = 0; i < values.length && r.length < maxChars; ++i) {
    if (r) r += ", ";
    r += values[i];
  }

  if (r.length > maxChars) return r.slice(0, maxChars) + ellipse;else return r;
}

function arrayShuffle(a) {
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }

  return a;
}

function uniqueName(names, name, separator = "") {
  if (names.indexOf(name) < 0) return name; // allocate names

  let count = 2;

  while (names.indexOf(`${name}${separator}${count}`) > -1) count++;

  return `${name}${separator}${count}`;
}

function groupBy(list, key) {
  if (!list) return {};
  const r = {};
  list.forEach(item => {
    const k = key(item);
    const a = r[k] || (r[k] = []);
    a.push(item);
  });
  return r;
}

function pick(...values) {
  return values === null || values === void 0 ? void 0 : values.find(x => x !== undefined);
}
/**
 * Applies filters and returns array of [yays, nays]
 * @param values
 * @param condition
 */


function splitFilter(values, condition) {
  const yays = [];
  const nays = [];
  const n = values.length;

  for (let i = 0; i < n; ++i) {
    const v = values[i];
    if (condition(v)) yays.push(v);else nays.push(v);
  }

  return [yays, nays];
}

function range(end) {
  return Array(end).fill(0).map((_, i) => i);
}

function toggleBit(data, bitindex) {
  // find bit to flip
  let byte = data[bitindex >> 3];
  const bit = bitindex % 8;
  const on = 1 === (byte >> bit & 1); // flip bit

  if (on) {
    byte &= ~(1 << bit);
  } else {
    byte |= 1 << bit;
  } // save


  data[bitindex >> 3] = byte;
}
/** @internal */


exports.NumberFormat = void 0;

(function (NumberFormat) {
  NumberFormat[NumberFormat["Int8LE"] = 1] = "Int8LE";
  NumberFormat[NumberFormat["UInt8LE"] = 2] = "UInt8LE";
  NumberFormat[NumberFormat["Int16LE"] = 3] = "Int16LE";
  NumberFormat[NumberFormat["UInt16LE"] = 4] = "UInt16LE";
  NumberFormat[NumberFormat["Int32LE"] = 5] = "Int32LE";
  NumberFormat[NumberFormat["Int8BE"] = 6] = "Int8BE";
  NumberFormat[NumberFormat["UInt8BE"] = 7] = "UInt8BE";
  NumberFormat[NumberFormat["Int16BE"] = 8] = "Int16BE";
  NumberFormat[NumberFormat["UInt16BE"] = 9] = "UInt16BE";
  NumberFormat[NumberFormat["Int32BE"] = 10] = "Int32BE";
  NumberFormat[NumberFormat["UInt32LE"] = 11] = "UInt32LE";
  NumberFormat[NumberFormat["UInt32BE"] = 12] = "UInt32BE";
  NumberFormat[NumberFormat["Float32LE"] = 13] = "Float32LE";
  NumberFormat[NumberFormat["Float64LE"] = 14] = "Float64LE";
  NumberFormat[NumberFormat["Float32BE"] = 15] = "Float32BE";
  NumberFormat[NumberFormat["Float64BE"] = 16] = "Float64BE";
  NumberFormat[NumberFormat["UInt64LE"] = 17] = "UInt64LE";
  NumberFormat[NumberFormat["UInt64BE"] = 18] = "UInt64BE";
  NumberFormat[NumberFormat["Int64LE"] = 19] = "Int64LE";
  NumberFormat[NumberFormat["Int64BE"] = 20] = "Int64BE";
})(exports.NumberFormat || (exports.NumberFormat = {}));

function fmtInfoCore(fmt) {
  switch (fmt) {
    case exports.NumberFormat.Int8LE:
      return -1;

    case exports.NumberFormat.UInt8LE:
      return 1;

    case exports.NumberFormat.Int16LE:
      return -2;

    case exports.NumberFormat.UInt16LE:
      return 2;

    case exports.NumberFormat.Int32LE:
      return -4;

    case exports.NumberFormat.UInt32LE:
      return 4;

    case exports.NumberFormat.Int64LE:
      return -8;

    case exports.NumberFormat.UInt64LE:
      return 8;

    case exports.NumberFormat.Int8BE:
      return -10;

    case exports.NumberFormat.UInt8BE:
      return 10;

    case exports.NumberFormat.Int16BE:
      return -20;

    case exports.NumberFormat.UInt16BE:
      return 20;

    case exports.NumberFormat.Int32BE:
      return -40;

    case exports.NumberFormat.UInt32BE:
      return 40;

    case exports.NumberFormat.Int64BE:
      return -80;

    case exports.NumberFormat.UInt64BE:
      return 80;

    case exports.NumberFormat.Float32LE:
      return 4;

    case exports.NumberFormat.Float32BE:
      return 40;

    case exports.NumberFormat.Float64LE:
      return 8;

    case exports.NumberFormat.Float64BE:
      return 80;

    default:
      throw new Error("unknown format");
  }
}

function fmtInfo(fmt) {
  let size = fmtInfoCore(fmt);
  let signed = false;

  if (size < 0) {
    signed = true;
    size = -size;
  }

  let swap = false;

  if (size >= 10) {
    swap = true;
    size /= 10;
  }

  let isFloat = false;

  switch (fmt) {
    case exports.NumberFormat.Float32LE:
    case exports.NumberFormat.Float32BE:
    case exports.NumberFormat.Float64LE:
    case exports.NumberFormat.Float64BE:
      isFloat = true;
      break;
  }

  return {
    size,
    signed,
    swap,
    isFloat
  };
}
/**
 * Get the size in bytes of specified number format.
 */


function sizeOfNumberFormat(format) {
  switch (format) {
    case exports.NumberFormat.Int8LE:
    case exports.NumberFormat.UInt8LE:
    case exports.NumberFormat.Int8BE:
    case exports.NumberFormat.UInt8BE:
      return 1;

    case exports.NumberFormat.Int16LE:
    case exports.NumberFormat.UInt16LE:
    case exports.NumberFormat.Int16BE:
    case exports.NumberFormat.UInt16BE:
      return 2;

    case exports.NumberFormat.Int32LE:
    case exports.NumberFormat.Int32BE:
    case exports.NumberFormat.UInt32BE:
    case exports.NumberFormat.UInt32LE:
    case exports.NumberFormat.Float32BE:
    case exports.NumberFormat.Float32LE:
      return 4;

    case exports.NumberFormat.UInt64BE:
    case exports.NumberFormat.Int64BE:
    case exports.NumberFormat.UInt64LE:
    case exports.NumberFormat.Int64LE:
    case exports.NumberFormat.Float64BE:
    case exports.NumberFormat.Float64LE:
      return 8;
  }

  return 0;
}

function getNumber(buf, fmt, offset) {
  switch (fmt) {
    case exports.NumberFormat.UInt8BE:
    case exports.NumberFormat.UInt8LE:
      return buf[offset];

    case exports.NumberFormat.Int8BE:
    case exports.NumberFormat.Int8LE:
      return buf[offset] << 24 >> 24;

    case exports.NumberFormat.UInt16LE:
      return read16(buf, offset);

    case exports.NumberFormat.Int16LE:
      return read16(buf, offset) << 16 >> 16;

    case exports.NumberFormat.UInt32LE:
      return read32(buf, offset);

    case exports.NumberFormat.Int32LE:
      return read32(buf, offset) >> 0;

    case exports.NumberFormat.UInt64LE:
      return read32(buf, offset) + read32(buf, offset + 4) * 0x100000000;

    case exports.NumberFormat.Int64LE:
      return read32(buf, offset) + (read32(buf, offset + 4) >> 0) * 0x100000000;

    default:
      {
        const inf = fmtInfo(fmt);

        if (inf.isFloat) {
          const arr = new Uint8Array(inf.size);

          for (let i = 0; i < inf.size; ++i) {
            arr[i] = buf[offset + i];
          }

          if (inf.swap) arr.reverse();
          if (inf.size == 4) return new Float32Array(arr.buffer)[0];else return new Float64Array(arr.buffer)[0];
        }

        throw new Error("unsupported fmt:" + fmt);
      }
  }
}

function setNumber(buf, fmt, offset, r) {
  const inf = fmtInfo(fmt);

  if (inf.isFloat) {
    const arr = new Uint8Array(inf.size);
    if (inf.size == 4) new Float32Array(arr.buffer)[0] = r;else new Float64Array(arr.buffer)[0] = r;
    if (inf.swap) arr.reverse();

    for (let i = 0; i < inf.size; ++i) {
      buf[offset + i] = arr[i];
    }

    return;
  }

  for (let i = 0; i < inf.size; ++i) {
    const off = !inf.swap ? offset + i : offset + inf.size - i - 1;
    buf[off] = r & 0xff;
    r >>= 8;
  }
}

function uintOfBuffer(data) {
  let fmt;

  switch (data.length) {
    case 0:
    case 1:
      fmt = exports.NumberFormat.UInt8LE;
      break;

    case 2:
    case 3:
      fmt = exports.NumberFormat.UInt16LE;
      break;

    default:
      fmt = exports.NumberFormat.UInt32LE;
      break;
  }

  return getNumber(data, fmt, 0);
}

function intOfBuffer(data) {
  let fmt;

  switch (data.length) {
    case 0:
    case 1:
      fmt = exports.NumberFormat.Int8LE;
      break;

    case 2:
    case 3:
      fmt = exports.NumberFormat.Int16LE;
      break;

    default:
      fmt = exports.NumberFormat.Int32LE;
      break;
  }

  return getNumber(data, fmt, 0);
}

function bufferToArray(data, fmt) {
  const res = [];
  const sz = sizeOfNumberFormat(fmt);

  for (let off = 0; off <= data.length - sz; off += sz) res.push(getNumber(data, fmt, off));

  return res;
}

function concatBufferArray(chunks) {
  let sz = 0;

  for (const ch of chunks) sz += ch.length;

  const r = new Uint8Array(sz);
  sz = 0;

  for (const ch of chunks) {
    r.set(ch, sz);
    sz += ch.length;
  }

  return r;
}

var serviceSpecificationData = [{
  name: "Common registers and commands",
  status: "experimental",
  shortId: "_system",
  camelName: "system",
  shortName: "system",
  "extends": [],
  notes: {
    short: "This file describes common register and command codes.\n\nThese are defined in ranges separate from the per-service ones.\nNo service actually derives from this file, but services can include packets\ndefined here.\nTheir code is listed as say `@ intensity` and not `@ 0x01` (the spectool enforces that).",
    commands: "Command codes are subdivided as follows:\n* Commands `0x000-0x07f` - common to all services\n* Commands `0x080-0xeff` - defined per-service\n* Commands `0xf00-0xfff` - reserved for implementation\n\nCommands follow.",
    registers: "Register codes are subdivided as follows:\n* Registers `0x001-0x07f` - r/w common to all services\n* Registers `0x080-0x0ff` - r/w defined per-service\n* Registers `0x100-0x17f` - r/o common to all services\n* Registers `0x180-0x1ff` - r/o defined per-service\n* Registers `0x200-0xeff` - custom, defined per-service\n* Registers `0xf00-0xfff` - reserved for implementation, should not be seen on the wire\n\nThe types listed are typical. Check spec for particular service for exact type,\nand a service-specific name for a register (eg. `value` could be `pulse_length`).\nAll registers default to `0` unless otherwise indicated.",
    events: "Events codes are 8-bit and are subdivided as follows:\n* Events `0x00-0x7f` - common to all services\n* Events `0x80-0xff` - defined per-service"
  },
  classIdentifier: 536870897,
  enums: {
    ReadingThreshold: {
      name: "ReadingThreshold",
      storage: 1,
      members: {
        Neutral: 1,
        Inactive: 2,
        Active: 3
      }
    },
    StatusCodes: {
      name: "StatusCodes",
      storage: 2,
      members: {
        Ready: 0,
        Initializing: 1,
        Calibrating: 2,
        Sleeping: 3,
        WaitingForInput: 4,
        CalibrationNeeded: 100
      }
    }
  },
  constants: {
    announce_interval: {
      value: 500,
      hex: false
    }
  },
  packets: [{
    kind: "command",
    name: "announce",
    identifier: 0,
    description: "Enumeration data for control service; service-specific advertisement data otherwise.\nControl broadcasts it automatically every ``announce_interval``ms, but other service have to be queried to provide it.",
    fields: [],
    hasReport: true
  }, {
    kind: "report",
    name: "announce",
    identifier: 0,
    description: "Enumeration data for control service; service-specific advertisement data otherwise.\nControl broadcasts it automatically every ``announce_interval``ms, but other service have to be queried to provide it.",
    fields: [],
    secondary: true
  }, {
    kind: "command",
    name: "get_register",
    identifier: 4096,
    description: "Registers number `N` is fetched by issuing command `0x1000 | N`.\nThe report format is the same as the format of the register.",
    fields: [],
    hasReport: true
  }, {
    kind: "report",
    name: "get_register",
    identifier: 4096,
    description: "Registers number `N` is fetched by issuing command `0x1000 | N`.\nThe report format is the same as the format of the register.",
    fields: [],
    secondary: true
  }, {
    kind: "command",
    name: "set_register",
    identifier: 8192,
    description: "Registers number `N` is set by issuing command `0x2000 | N`, with the format\nthe same as the format of the register.",
    fields: []
  }, {
    kind: "report",
    name: "event",
    identifier: 1,
    description: "Event from sensor or a broadcast service.",
    fields: [{
      name: "event_id",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }, {
      name: "event_argument",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    packFormat: "u32 u32"
  }, {
    kind: "command",
    name: "calibrate",
    identifier: 2,
    description: "Request to calibrate a sensor. The report indicates the calibration is done.",
    fields: [],
    hasReport: true
  }, {
    kind: "report",
    name: "calibrate",
    identifier: 2,
    description: "Request to calibrate a sensor. The report indicates the calibration is done.",
    fields: [],
    secondary: true
  }, {
    kind: "rw",
    name: "intensity",
    identifier: 1,
    description: "This is either binary on/off (0 or non-zero), or can be gradual (eg. brightness of an RGB LED strip).",
    fields: [{
      name: "_",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    packFormat: "u32"
  }, {
    kind: "rw",
    name: "value",
    identifier: 2,
    description: "The primary value of actuator (eg. servo pulse length, or motor duty cycle).",
    fields: [{
      name: "_",
      type: "i32",
      storage: -4,
      isSimpleType: true
    }],
    packFormat: "i32"
  }, {
    kind: "const",
    name: "min_value",
    identifier: 272,
    description: "The lowest value that can be reported for the value register.",
    fields: [{
      name: "_",
      type: "i32",
      storage: -4,
      isSimpleType: true
    }],
    packFormat: "i32"
  }, {
    kind: "const",
    name: "max_value",
    identifier: 273,
    description: "The highest value that can be reported for the value register.",
    fields: [{
      name: "_",
      type: "i32",
      storage: -4,
      isSimpleType: true
    }],
    packFormat: "i32"
  }, {
    kind: "rw",
    name: "max_power",
    identifier: 7,
    description: "Limit the power drawn by the service, in mA.",
    fields: [{
      name: "_",
      unit: "mA",
      type: "u16",
      storage: 2,
      isSimpleType: true,
      defaultValue: 500,
      typicalMax: 500,
      typicalMin: 0
    }],
    packFormat: "u16"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    packFormat: "u8"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100
    }],
    packFormat: "u32"
  }, {
    kind: "ro",
    name: "reading",
    identifier: 257,
    description: "Read-only value of the sensor, also reported in streaming.",
    fields: [{
      name: "_",
      type: "i32",
      storage: -4,
      isSimpleType: true
    }],
    volatile: true,
    packFormat: "i32"
  }, {
    kind: "const",
    name: "min_reading",
    identifier: 260,
    description: "The lowest value that can be reported by the sensor.",
    fields: [{
      name: "_",
      type: "i32",
      storage: -4,
      isSimpleType: true
    }],
    packFormat: "i32"
  }, {
    kind: "const",
    name: "max_reading",
    identifier: 261,
    description: "The highest value that can be reported by the sensor.",
    fields: [{
      name: "_",
      type: "i32",
      storage: -4,
      isSimpleType: true
    }],
    packFormat: "i32"
  }, {
    kind: "ro",
    name: "reading_error",
    identifier: 262,
    description: "The real value of whatever is measured is between `reading - reading_error` and `reading + reading_error`. It should be computed from the internal state of the sensor. This register is often, but not always `const`. If the register value is modified,\nsend a report in the same frame of the ``reading`` report.",
    fields: [{
      name: "_",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    volatile: true,
    packFormat: "u32"
  }, {
    kind: "const",
    name: "reading_resolution",
    identifier: 264,
    description: "Smallest, yet distinguishable change in reading.",
    fields: [{
      name: "_",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    packFormat: "u32"
  }, {
    kind: "rw",
    name: "inactive_threshold",
    identifier: 5,
    description: "Threshold when reading data gets inactive and triggers a ``inactive``.",
    fields: [{
      name: "_",
      type: "i32",
      storage: -4,
      isSimpleType: true
    }],
    packFormat: "i32"
  }, {
    kind: "rw",
    name: "active_threshold",
    identifier: 6,
    description: "Thresholds when reading data gets active and triggers a ``active`` event.",
    fields: [{
      name: "_",
      type: "i32",
      storage: -4,
      isSimpleType: true
    }],
    packFormat: "i32"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    packFormat: "u32"
  }, {
    kind: "const",
    name: "variant",
    identifier: 263,
    description: "The hardware variant of the service.\nFor services which support this, there's an enum defining the meaning.",
    fields: [{
      name: "_",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    packFormat: "u32"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet.",
    fields: [{
      name: "code",
      type: "StatusCodes",
      storage: 2
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    packFormat: "u16 u16"
  }, {
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    packFormat: "s"
  }, {
    kind: "event",
    name: "active",
    identifier: 1,
    description: "Notifies that the service has been activated (eg. button pressed, network connected, etc.)",
    fields: []
  }, {
    kind: "event",
    name: "inactive",
    identifier: 2,
    description: "Notifies that the service has been dis-activated.",
    fields: []
  }, {
    kind: "event",
    name: "change",
    identifier: 3,
    description: "Notifies that the some state of the service changed.",
    fields: []
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "StatusCodes",
      storage: 2
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    packFormat: "u16 u16"
  }, {
    kind: "event",
    name: "neutral",
    identifier: 7,
    description: "Notifies that the threshold is back between ``low`` and ``high``.",
    fields: []
  }],
  tags: []
}, {
  name: "Base service",
  status: "experimental",
  shortId: "_base",
  camelName: "base",
  shortName: "base",
  "extends": [],
  notes: {
    short: "Base class for all services."
  },
  classIdentifier: 536870899,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16"
  }],
  tags: []
}, {
  name: "Sensor",
  status: "experimental",
  shortId: "_sensor",
  camelName: "sensor",
  shortName: "sensor",
  "extends": ["_base"],
  notes: {
    short: "Base class for sensors."
  },
  classIdentifier: 536870898,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32"
  }],
  tags: []
}, {
  name: "Accelerometer",
  status: "experimental",
  shortId: "accelerometer",
  camelName: "accelerometer",
  shortName: "accelerometer",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "A 3-axis accelerometer.",
    long: "## Orientation\n\nAn accelerometer module should translate acceleration values as follows:\n\n| Orientation           \t| X value (g) \t| Y value (g) \t| Z value (g) \t|\n|-----------------------\t|-------------\t|-------------\t|-------------\t|\n| Module lying flat     \t| 0           \t| 0           \t| -1          \t|\n| Module on left edge   \t| -1          \t| 0           \t| 0           \t|\n| Module on bottom edge \t| 0           \t| 1           \t| 0           \t|\n\nWe recommend an orientation marking on the PCB so that users can mount modules without having to experiment with the device. Left/bottom can be determined by assuming text on silk runs left-to-right.",
    events: "All events are debounced."
  },
  classIdentifier: 521405449,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "forces",
    identifier: 257,
    description: "Indicates the current forces acting on accelerometer.",
    fields: [{
      name: "x",
      unit: "g",
      shift: 20,
      type: "i12.20",
      storage: -4
    }, {
      name: "y",
      unit: "g",
      shift: 20,
      type: "i12.20",
      storage: -4
    }, {
      name: "z",
      unit: "g",
      shift: 20,
      type: "i12.20",
      storage: -4
    }],
    volatile: true,
    identifierName: "reading",
    packFormat: "i12.20 i12.20 i12.20"
  }, {
    kind: "ro",
    name: "forces_error",
    identifier: 262,
    description: "Error on the reading value.",
    fields: [{
      name: "_",
      unit: "g",
      shift: 20,
      type: "i12.20",
      storage: -4
    }],
    volatile: true,
    optional: true,
    identifierName: "reading_error",
    packFormat: "i12.20"
  }, {
    kind: "rw",
    name: "max_force",
    identifier: 128,
    description: "Configures the range forces detected.\nRead-back after setting to get current value.",
    fields: [{
      name: "_",
      unit: "g",
      shift: 20,
      type: "i12.20",
      storage: -4
    }],
    optional: true,
    packFormat: "i12.20"
  }, {
    kind: "event",
    name: "tilt_up",
    identifier: 129,
    description: "Emitted when accelerometer is tilted in the given direction.",
    fields: []
  }, {
    kind: "event",
    name: "tilt_down",
    identifier: 130,
    description: "Emitted when accelerometer is tilted in the given direction.",
    fields: []
  }, {
    kind: "event",
    name: "tilt_left",
    identifier: 131,
    description: "Emitted when accelerometer is tilted in the given direction.",
    fields: []
  }, {
    kind: "event",
    name: "tilt_right",
    identifier: 132,
    description: "Emitted when accelerometer is tilted in the given direction.",
    fields: []
  }, {
    kind: "event",
    name: "face_up",
    identifier: 133,
    description: "Emitted when accelerometer is laying flat in the given direction.",
    fields: []
  }, {
    kind: "event",
    name: "face_down",
    identifier: 134,
    description: "Emitted when accelerometer is laying flat in the given direction.",
    fields: []
  }, {
    kind: "event",
    name: "freefall",
    identifier: 135,
    description: "Emitted when total force acting on accelerometer is much less than 1g.",
    fields: []
  }, {
    kind: "event",
    name: "shake",
    identifier: 139,
    description: "Emitted when forces change violently a few times.",
    fields: []
  }, {
    kind: "event",
    name: "force_2g",
    identifier: 140,
    description: "Emitted when force in any direction exceeds given threshold.",
    fields: []
  }, {
    kind: "event",
    name: "force_3g",
    identifier: 136,
    description: "Emitted when force in any direction exceeds given threshold.",
    fields: []
  }, {
    kind: "event",
    name: "force_6g",
    identifier: 137,
    description: "Emitted when force in any direction exceeds given threshold.",
    fields: []
  }, {
    kind: "event",
    name: "force_8g",
    identifier: 138,
    description: "Emitted when force in any direction exceeds given threshold.",
    fields: []
  }],
  tags: ["C"],
  group: "Movement"
}, {
  name: "Arcade Gamepad",
  status: "deprecated",
  shortId: "arcadegamepad",
  camelName: "arcadeGamepad",
  shortName: "arcadeGamepad",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "This service is deprecated in favor or `joystick`; it is currently used by the micro:bit Arcade smart shield though.\nA gamepad with direction and action buttons for one player.\nIf a device has multiple controllers, it should have multiple gamepad services, using consecutive service identifiers."
  },
  classIdentifier: 501915758,
  enums: {
    Button: {
      name: "Button",
      storage: 1,
      members: {
        Left: 1,
        Up: 2,
        Right: 3,
        Down: 4,
        A: 5,
        B: 6,
        Menu: 7,
        Select: 8,
        Reset: 9,
        Exit: 10
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "buttons",
    identifier: 257,
    description: "Indicates which buttons are currently active (pressed).\n`pressure` should be `0xff` for digital buttons, and proportional for analog ones.",
    fields: [{
      name: "button",
      type: "Button",
      storage: 1,
      startRepeats: true
    }, {
      name: "pressure",
      unit: "/",
      shift: 8,
      type: "u0.8",
      storage: 1
    }],
    volatile: true,
    identifierName: "reading",
    packFormat: "r: u8 u0.8"
  }, {
    kind: "const",
    name: "available_buttons",
    identifier: 384,
    description: "Indicates number of players supported and which buttons are present on the controller.",
    fields: [{
      name: "button",
      type: "Button",
      storage: 1,
      startRepeats: true
    }],
    packFormat: "r: u8"
  }, {
    kind: "event",
    name: "down",
    identifier: 1,
    description: "Emitted when button goes from inactive to active.",
    fields: [{
      name: "button",
      type: "Button",
      storage: 1
    }],
    identifierName: "active",
    packFormat: "u8"
  }, {
    kind: "event",
    name: "up",
    identifier: 2,
    description: "Emitted when button goes from active to inactive.",
    fields: [{
      name: "button",
      type: "Button",
      storage: 1
    }],
    identifierName: "inactive",
    packFormat: "u8"
  }],
  tags: [],
  group: "Button"
}, {
  name: "Arcade sound",
  status: "experimental",
  shortId: "arcadesound",
  camelName: "arcadeSound",
  shortName: "arcadeSound",
  "extends": ["_base"],
  notes: {
    short: "A sound playing device.\n\nThis is typically run over an SPI connection, not regular single-wire JACDAC."
  },
  classIdentifier: 533083654,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "command",
    name: "play",
    identifier: 128,
    description: "Play samples, which are single channel, signed 16-bit little endian values.",
    fields: [{
      name: "samples",
      type: "bytes",
      storage: 0,
      isSimpleType: true
    }],
    packFormat: "b"
  }, {
    kind: "rw",
    name: "sample_rate",
    identifier: 128,
    description: "Get or set playback sample rate (in samples per second).\nIf you set it, read it back, as the value may be rounded up or down.",
    fields: [{
      name: "_",
      unit: "Hz",
      shift: 10,
      type: "u22.10",
      storage: 4,
      defaultValue: 44100
    }],
    packFormat: "u22.10"
  }, {
    kind: "const",
    name: "buffer_size",
    identifier: 384,
    description: "The size of the internal audio buffer.",
    fields: [{
      name: "_",
      unit: "B",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    packFormat: "u32"
  }, {
    kind: "ro",
    name: "buffer_pending",
    identifier: 385,
    description: "How much data is still left in the buffer to play.\nClients should not send more data than `buffer_size - buffer_pending`,\nbut can keep the `buffer_pending` as low as they want to ensure low latency\nof audio playback.",
    fields: [{
      name: "_",
      unit: "B",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    packFormat: "u32"
  }],
  tags: []
}, {
  name: "Azure IoT Hub Health",
  status: "experimental",
  shortId: "azureiothubhealth",
  camelName: "azureIotHubHealth",
  shortName: "azureIotHubHealth",
  "extends": ["_base"],
  notes: {
    short: "Health and diagnostics information about the Azure Iot Hub connection."
  },
  classIdentifier: 342028028,
  enums: {
    ConnectionStatus: {
      name: "ConnectionStatus",
      storage: 2,
      members: {
        Connected: 1,
        Disconnected: 2,
        Connecting: 3,
        Disconnecting: 4
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "ro",
    name: "hub_name",
    identifier: 384,
    description: "Something like `my-iot-hub.azure-devices.net`; empty string when not properly configured",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    packFormat: "s"
  }, {
    kind: "ro",
    name: "hub_device_id",
    identifier: 385,
    description: "Device identifier in Azure Iot Hub",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    packFormat: "s"
  }, {
    kind: "ro",
    name: "connection_status",
    identifier: 386,
    description: "Indicates the status of connection. A message beyond the [0..3] range represents an HTTP error code.",
    fields: [{
      name: "_",
      type: "ConnectionStatus",
      storage: 2
    }],
    packFormat: "u16"
  }, {
    kind: "command",
    name: "connect",
    identifier: 129,
    description: "Starts a connection to the IoT hub service",
    fields: []
  }, {
    kind: "command",
    name: "disconnect",
    identifier: 130,
    description: "Starts disconnecting from the IoT hub service",
    fields: []
  }, {
    kind: "command",
    name: "set_connection_string",
    identifier: 134,
    description: "Restricted command to override the existing connection string to the Azure IoT Hub.",
    fields: [{
      name: "connection_string",
      type: "string",
      storage: 0
    }],
    restricted: true,
    packFormat: "s"
  }, {
    kind: "event",
    name: "connection_status_change",
    identifier: 3,
    description: "Raised when the connection status changes",
    fields: [{
      name: "connection_status",
      type: "ConnectionStatus",
      storage: 2
    }],
    identifierName: "change",
    packFormat: "u16"
  }],
  tags: [],
  group: "Iot"
}, {
  name: "Barcode reader",
  status: "experimental",
  shortId: "barcodereader",
  camelName: "barcodeReader",
  shortName: "barcodeReader",
  "extends": ["_base"],
  notes: {
    short: "A device that reads various barcodes, like QR codes. For the web, see [BarcodeDetector](https://developer.mozilla.org/en-US/docs/Web/API/BarcodeDetector)."
  },
  classIdentifier: 477339244,
  enums: {
    Format: {
      name: "Format",
      storage: 1,
      members: {
        Aztec: 1,
        Code128: 2,
        Code39: 3,
        Code93: 4,
        Codabar: 5,
        DataMatrix: 6,
        Ean13: 8,
        Ean8: 9,
        ITF: 10,
        Pdf417: 11,
        QrCode: 12,
        UpcA: 13,
        UpcE: 14
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "enabled",
    identifier: 1,
    description: "Turns on or off the detection of barcodes.",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1
    }],
    identifierName: "intensity",
    packFormat: "u8"
  }, {
    kind: "const",
    name: "formats",
    identifier: 384,
    description: "Reports the list of supported barcode formats, as documented in https://developer.mozilla.org/en-US/docs/Web/API/Barcode_Detection_API.",
    fields: [{
      name: "format",
      type: "Format",
      storage: 1,
      startRepeats: true
    }],
    optional: true,
    packFormat: "r: u8"
  }, {
    kind: "event",
    name: "detect",
    identifier: 1,
    description: "Raised when a bar code is detected and decoded. If the reader detects multiple codes, it will issue multiple events.\nIn case of numeric barcodes, the `data` field should contain the ASCII (which is the same as UTF8 in that case) representation of the number.",
    fields: [{
      name: "format",
      type: "Format",
      storage: 1
    }, {
      name: "data",
      type: "string",
      storage: 0
    }],
    identifierName: "active",
    packFormat: "u8 s"
  }],
  tags: []
}, {
  name: "Barometer",
  status: "experimental",
  shortId: "barometer",
  camelName: "barometer",
  shortName: "barometer",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "A sensor measuring air pressure of outside environment.",
    registers: "Default streaming interval is 1s."
  },
  classIdentifier: 504462570,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "pressure",
    identifier: 257,
    description: "The air pressure.",
    fields: [{
      name: "_",
      unit: "hPa",
      shift: 10,
      type: "u22.10",
      storage: 4,
      absoluteMin: 300,
      absoluteMax: 1100,
      typicalMin: 940,
      typicalMax: 1040
    }],
    volatile: true,
    identifierName: "reading",
    preferredInterval: 60000,
    packFormat: "u22.10"
  }, {
    kind: "ro",
    name: "pressure_error",
    identifier: 262,
    description: "The real pressure is between `pressure - pressure_error` and `pressure + pressure_error`.",
    fields: [{
      name: "_",
      unit: "hPa",
      shift: 10,
      type: "u22.10",
      storage: 4
    }],
    volatile: true,
    identifierName: "reading_error",
    packFormat: "u22.10"
  }],
  tags: ["8bit"],
  group: "Environment"
}, {
  name: "bit:radio",
  status: "experimental",
  shortId: "bitradio",
  camelName: "bitRadio",
  shortName: "bitRadio",
  "extends": ["_base"],
  notes: {
    short: "Support for sending and receiving packets using the [Bit Radio protocol](https://github.com/microsoft/pxt-common-packages/blob/master/libs/radio/docs/reference/radio.md), typically used between micro:bit devices."
  },
  classIdentifier: 449414863,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "enabled",
    identifier: 1,
    description: "Turns on/off the radio antenna.",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1
    }],
    identifierName: "intensity",
    packFormat: "u8"
  }, {
    kind: "rw",
    name: "group",
    identifier: 128,
    description: "Group used to filter packets",
    fields: [{
      name: "_",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    packFormat: "u8"
  }, {
    kind: "rw",
    name: "transmission_power",
    identifier: 129,
    description: "Antenna power to increase or decrease range.",
    fields: [{
      name: "_",
      type: "u8",
      storage: 1,
      isSimpleType: true,
      defaultValue: 6,
      absoluteMin: 1,
      absoluteMax: 7
    }],
    packFormat: "u8"
  }, {
    kind: "rw",
    name: "frequency_band",
    identifier: 130,
    description: "Change the transmission and reception band of the radio to the given channel.",
    fields: [{
      name: "_",
      type: "u8",
      storage: 1,
      isSimpleType: true,
      defaultValue: 7,
      absoluteMax: 83,
      absoluteMin: 0
    }],
    packFormat: "u8"
  }, {
    kind: "command",
    name: "send_string",
    identifier: 128,
    description: "Sends a string payload as a radio message, maximum 18 characters.",
    fields: [{
      name: "message",
      type: "string",
      storage: 0
    }],
    packFormat: "s"
  }, {
    kind: "command",
    name: "send_number",
    identifier: 129,
    description: "Sends a double precision number payload as a radio message",
    fields: [{
      name: "value",
      isFloat: true,
      type: "f64",
      storage: 8
    }],
    packFormat: "f64"
  }, {
    kind: "command",
    name: "send_value",
    identifier: 130,
    description: "Sends a double precision number and a name payload as a radio message",
    fields: [{
      name: "value",
      isFloat: true,
      type: "f64",
      storage: 8
    }, {
      name: "name",
      type: "string",
      storage: 0
    }],
    packFormat: "f64 s"
  }, {
    kind: "command",
    name: "send_buffer",
    identifier: 131,
    description: "Sends a payload of bytes as a radio message",
    fields: [{
      name: "data",
      type: "bytes",
      storage: 0,
      isSimpleType: true
    }],
    packFormat: "b"
  }, {
    kind: "report",
    name: "string_received",
    identifier: 144,
    description: "Raised when a string packet is received",
    fields: [{
      name: "time",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }, {
      name: "device_serial_number",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }, {
      name: "rssi",
      unit: "dB",
      type: "i8",
      storage: -1,
      isSimpleType: true
    }, {
      name: "padding",
      type: "u8[1]",
      storage: 1
    }, {
      name: "message",
      type: "string",
      storage: 0
    }],
    packFormat: "u32 u32 i8 b[1] s"
  }, {
    kind: "report",
    name: "number_received",
    identifier: 145,
    description: "Raised when a number packet is received",
    fields: [{
      name: "time",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }, {
      name: "device_serial_number",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }, {
      name: "rssi",
      unit: "dB",
      type: "i8",
      storage: -1,
      isSimpleType: true
    }, {
      name: "padding",
      type: "u8[3]",
      storage: 3
    }, {
      name: "value",
      isFloat: true,
      type: "f64",
      storage: 8
    }, {
      name: "name",
      type: "string",
      storage: 0
    }],
    packFormat: "u32 u32 i8 b[3] f64 s"
  }, {
    kind: "report",
    name: "buffer_received",
    identifier: 146,
    description: "Raised when a buffer packet is received",
    fields: [{
      name: "time",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }, {
      name: "device_serial_number",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }, {
      name: "rssi",
      unit: "dB",
      type: "i8",
      storage: -1,
      isSimpleType: true
    }, {
      name: "padding",
      type: "u8[1]",
      storage: 1
    }, {
      name: "data",
      type: "bytes",
      storage: 0,
      isSimpleType: true
    }],
    packFormat: "u32 u32 i8 b[1] b"
  }],
  tags: []
}, {
  name: "Bootloader",
  status: "experimental",
  shortId: "bootloader",
  camelName: "bootloader",
  shortName: "bootloader",
  "extends": ["_base"],
  notes: {
    short: "Allows flashing (reprogramming) devices over Jacdac."
  },
  classIdentifier: 536516936,
  enums: {
    "Error": {
      name: "Error",
      storage: 4,
      members: {
        NoError: 0,
        PacketTooSmall: 1,
        OutOfFlashableRange: 2,
        InvalidPageOffset: 3,
        NotPageAligned: 4
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "command",
    name: "info",
    identifier: 0,
    description: "The `service_class` is always `0x1ffa9948`. The `product_identifer` identifies the kind of firmware\nthat \"fits\" this device.",
    fields: [],
    identifierName: "announce",
    hasReport: true
  }, {
    kind: "report",
    name: "info",
    identifier: 0,
    description: "The `service_class` is always `0x1ffa9948`. The `product_identifer` identifies the kind of firmware\nthat \"fits\" this device.",
    fields: [{
      name: "service_class",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }, {
      name: "page_size",
      unit: "B",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }, {
      name: "flashable_size",
      unit: "B",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }, {
      name: "product_identifer",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    secondary: true,
    packFormat: "u32 u32 u32 u32"
  }, {
    kind: "command",
    name: "set_session",
    identifier: 129,
    description: "The flashing server should generate a random id, and use this command to set it.",
    fields: [{
      name: "session_id",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    hasReport: true,
    packFormat: "u32"
  }, {
    kind: "report",
    name: "set_session",
    identifier: 129,
    description: "The flashing server should generate a random id, and use this command to set it.",
    fields: [{
      name: "session_id",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    secondary: true,
    packFormat: "u32"
  }, {
    kind: "command",
    name: "page_data",
    identifier: 128,
    description: "Use to send flashing data. A physical page is split into `chunk_max + 1` chunks, where `chunk_no = 0 ... chunk_max`.\nEach chunk is stored at `page_address + page_offset`. `page_address` has to be equal in all chunks,\nand is included in response.\nOnly the last chunk causes writing to flash and elicits response.\n\nErrors not listed are also possible. Errors larger than `0xffff` indicate de-synchronization on chunk numbers.",
    fields: [{
      name: "page_address",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }, {
      name: "page_offset",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "chunk_no",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "chunk_max",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "session_id",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }, {
      name: "reserved0",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }, {
      name: "reserved1",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }, {
      name: "reserved2",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }, {
      name: "reserved3",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }, {
      name: "page_data",
      type: "bytes",
      storage: 208,
      isSimpleType: true,
      maxBytes: 208
    }],
    hasReport: true,
    packFormat: "u32 u16 u8 u8 u32 u32 u32 u32 u32 b[208]"
  }, {
    kind: "report",
    name: "page_data",
    identifier: 128,
    description: "Use to send flashing data. A physical page is split into `chunk_max + 1` chunks, where `chunk_no = 0 ... chunk_max`.\nEach chunk is stored at `page_address + page_offset`. `page_address` has to be equal in all chunks,\nand is included in response.\nOnly the last chunk causes writing to flash and elicits response.\n\nErrors not listed are also possible. Errors larger than `0xffff` indicate de-synchronization on chunk numbers.",
    fields: [{
      name: "session_id",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }, {
      name: "page_error",
      type: "Error",
      storage: 4
    }, {
      name: "page_address",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    secondary: true,
    packFormat: "u32 u32 u32"
  }],
  tags: ["C"]
}, {
  name: "Button",
  status: "experimental",
  shortId: "button",
  camelName: "button",
  shortName: "button",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "A push-button, which returns to inactive position when not operated anymore."
  },
  classIdentifier: 343122531,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "pressure",
    identifier: 257,
    description: "Indicates the pressure state of the button, where ``0`` is open.",
    fields: [{
      name: "_",
      unit: "/",
      shift: 16,
      type: "u0.16",
      storage: 2
    }],
    lowLevel: true,
    volatile: true,
    identifierName: "reading",
    packFormat: "u0.16"
  }, {
    kind: "const",
    name: "analog",
    identifier: 384,
    description: "Indicates if the button provides analog ``pressure`` readings.",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1
    }],
    optional: true,
    packFormat: "u8"
  }, {
    kind: "ro",
    name: "pressed",
    identifier: 385,
    description: "Determines if the button is pressed currently.\n\nIf the event ``down`` is observed, ``pressed`` is true; if ``up`` or ``hold`` are observed, ``pressed`` is false.\nTo initialize, wait for any event or timeout to ``pressed`` is true after 750ms (1.5x hold time).",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1
    }],
    client: true,
    packFormat: "u8"
  }, {
    kind: "event",
    name: "down",
    identifier: 1,
    description: "Emitted when button goes from inactive to active.",
    fields: [],
    identifierName: "active"
  }, {
    kind: "event",
    name: "up",
    identifier: 2,
    description: "Emitted when button goes from active to inactive. The 'time' parameter \nrecords the amount of time between the down and up events.",
    fields: [{
      name: "time",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    identifierName: "inactive",
    packFormat: "u32"
  }, {
    kind: "event",
    name: "hold",
    identifier: 129,
    description: "Emitted when the press time is greater than 500ms, and then at least every 500ms \nas long as the button remains pressed. The 'time' parameter records the the amount of time\nthat the button has been held (since the down event).",
    fields: [{
      name: "time",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    packFormat: "u32"
  }],
  tags: ["C", "8bit", "padauk"],
  group: "Button"
}, {
  name: "Buzzer",
  status: "experimental",
  shortId: "buzzer",
  camelName: "buzzer",
  shortName: "buzzer",
  "extends": ["_base"],
  notes: {
    short: "A simple buzzer."
  },
  classIdentifier: 458731991,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "volume",
    identifier: 1,
    description: "The volume (duty cycle) of the buzzer.",
    fields: [{
      name: "_",
      unit: "/",
      shift: 8,
      type: "u0.8",
      storage: 1,
      defaultValue: 1
    }],
    identifierName: "intensity",
    packFormat: "u0.8"
  }, {
    kind: "command",
    name: "play_tone",
    identifier: 128,
    description: "Play a PWM tone with given period and duty for given duration.\nThe duty is scaled down with `volume` register.\nTo play tone at frequency `F` Hz and volume `V` (in `0..1`) you will want\nto send `P = 1000000 / F` and `D = P * V / 2`.",
    fields: [{
      name: "period",
      unit: "us",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "duty",
      unit: "us",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "duration",
      unit: "ms",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    lowLevel: true,
    packFormat: "u16 u16 u16"
  }, {
    kind: "command",
    name: "play_note",
    identifier: 129,
    description: "Play a note at the given frequency and volume.",
    fields: [{
      name: "frequency",
      unit: "Hz",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "volume",
      unit: "/",
      shift: 16,
      type: "u0.16",
      storage: 2
    }, {
      name: "duration",
      unit: "ms",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    client: true,
    packFormat: "u16 u0.16 u16"
  }],
  tags: ["C", "8bit"],
  group: "Sound"
}, {
  name: "Capacitive Button",
  status: "experimental",
  shortId: "capacitivebutton",
  camelName: "capacitiveButton",
  shortName: "capacitiveButton",
  "extends": ["_base"],
  notes: {
    short: "A configuration service for a capacitive push-button."
  },
  classIdentifier: 677752265,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "threshold",
    identifier: 6,
    description: "Indicates the threshold for ``up`` events.",
    fields: [{
      name: "_",
      unit: "/",
      shift: 16,
      type: "u0.16",
      storage: 2
    }],
    identifierName: "active_threshold",
    packFormat: "u0.16"
  }, {
    kind: "command",
    name: "calibrate",
    identifier: 2,
    description: "Request to calibrate the capactive. When calibration is requested, the device expects that no object is touching the button. \nThe report indicates the calibration is done.",
    fields: [],
    identifierName: "calibrate",
    hasReport: true
  }, {
    kind: "report",
    name: "calibrate",
    identifier: 2,
    description: "Request to calibrate the capactive. When calibration is requested, the device expects that no object is touching the button. \nThe report indicates the calibration is done.",
    fields: [],
    secondary: true
  }],
  tags: ["8bit"],
  group: "Button"
}, {
  name: "Character Screen",
  status: "experimental",
  shortId: "characterscreen",
  camelName: "characterScreen",
  shortName: "characterScreen",
  "extends": ["_base"],
  notes: {
    short: "A screen that displays characters."
  },
  classIdentifier: 523748714,
  enums: {
    Variant: {
      name: "Variant",
      storage: 1,
      members: {
        LCD: 1,
        OLED: 2,
        Braille: 3
      }
    },
    TextDirection: {
      name: "TextDirection",
      storage: 1,
      members: {
        LeftToRight: 1,
        RightToLeft: 2
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "message",
    identifier: 2,
    description: "Text to show. Use `\\n` to break lines.",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    lowLevel: true,
    identifierName: "value",
    packFormat: "s"
  }, {
    kind: "rw",
    name: "brightness",
    identifier: 1,
    description: "Brightness of the screen. `0` means off.",
    fields: [{
      name: "_",
      unit: "/",
      shift: 8,
      type: "u0.8",
      storage: 1
    }],
    optional: true,
    identifierName: "intensity",
    packFormat: "u0.8"
  }, {
    kind: "const",
    name: "variant",
    identifier: 263,
    description: "Describes the type of character LED screen.",
    fields: [{
      name: "_",
      type: "Variant",
      storage: 1
    }],
    optional: true,
    identifierName: "variant",
    packFormat: "u8"
  }, {
    kind: "rw",
    name: "text_direction",
    identifier: 130,
    description: "Specifies the RTL or LTR direction of the text.",
    fields: [{
      name: "_",
      type: "TextDirection",
      storage: 1
    }],
    optional: true,
    packFormat: "u8"
  }, {
    kind: "const",
    name: "rows",
    identifier: 384,
    description: "Gets the number of rows.",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    packFormat: "u8"
  }, {
    kind: "const",
    name: "columns",
    identifier: 385,
    description: "Gets the number of columns.",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    packFormat: "u8"
  }, {
    kind: "command",
    name: "set_line",
    identifier: 128,
    description: "Overrides the content of a single line at a 0-based index.",
    fields: [{
      name: "index",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "message",
      type: "string",
      storage: 0
    }],
    packFormat: "u16 s"
  }, {
    kind: "command",
    name: "clear",
    identifier: 129,
    description: "Clears all text from the display.",
    fields: []
  }],
  tags: [],
  group: "Display"
}, {
  name: "Color",
  status: "experimental",
  shortId: "color",
  camelName: "color",
  shortName: "color",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "Senses RGB colors"
  },
  classIdentifier: 372299111,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "color",
    identifier: 257,
    description: "Detected color in the RGB color space.",
    fields: [{
      name: "red",
      unit: "/",
      shift: 16,
      type: "u0.16",
      storage: 2
    }, {
      name: "green",
      unit: "/",
      shift: 16,
      type: "u0.16",
      storage: 2
    }, {
      name: "blue",
      unit: "/",
      shift: 16,
      type: "u0.16",
      storage: 2
    }],
    volatile: true,
    identifierName: "reading",
    packFormat: "u0.16 u0.16 u0.16"
  }],
  tags: ["8bit"],
  group: "Imaging"
}, {
  name: "Compass",
  status: "experimental",
  shortId: "compass",
  camelName: "compass",
  shortName: "compass",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "A sensor that measures the heading."
  },
  classIdentifier: 364362175,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "heading",
    identifier: 257,
    description: "The heading with respect to the magnetic north.",
    fields: [{
      name: "_",
      unit: "°",
      shift: 16,
      type: "u16.16",
      storage: 4,
      absoluteMin: 0,
      absoluteMax: 359
    }],
    volatile: true,
    identifierName: "reading",
    preferredInterval: 1000,
    packFormat: "u16.16"
  }, {
    kind: "rw",
    name: "enabled",
    identifier: 1,
    description: "Turn on or off the sensor. Turning on the sensor may start a calibration sequence.",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1
    }],
    identifierName: "intensity",
    packFormat: "u8"
  }, {
    kind: "ro",
    name: "heading_error",
    identifier: 262,
    description: "Error on the heading reading",
    fields: [{
      name: "_",
      unit: "°",
      shift: 16,
      type: "u16.16",
      storage: 4
    }],
    volatile: true,
    optional: true,
    identifierName: "reading_error",
    packFormat: "u16.16"
  }, {
    kind: "command",
    name: "calibrate",
    identifier: 2,
    description: "Starts a calibration sequence for the compass.",
    fields: [],
    identifierName: "calibrate"
  }],
  tags: []
}, {
  name: "Control",
  status: "experimental",
  shortId: "control",
  camelName: "control",
  shortName: "control",
  "extends": ["_base"],
  notes: {
    short: "Control service is always service index `0`.\nIt handles actions common to all services on a device.\n\nNote: some of the optional features (including `flood_ping`, `mcu_temperature`, and all string registers)\nare not implemented in `8bit` version."
  },
  classIdentifier: 0,
  enums: {
    AnnounceFlags: {
      name: "AnnounceFlags",
      storage: 2,
      isFlags: true,
      members: {
        RestartCounterSteady: 15,
        RestartCounter1: 1,
        RestartCounter2: 2,
        RestartCounter4: 4,
        RestartCounter8: 8,
        StatusLightNone: 0,
        StatusLightMono: 16,
        StatusLightRgbNoFade: 32,
        StatusLightRgbFade: 48,
        SupportsACK: 256,
        SupportsBroadcast: 512,
        SupportsFrames: 1024,
        IsClient: 2048
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "command",
    name: "services",
    identifier: 0,
    description: "The `restart_counter` is computed from the `flags & RestartCounterSteady`, starts at `0x1` and increments by one until it reaches `0xf`, then it stays at `0xf`.\nIf this number ever goes down, it indicates that the device restarted.\n`service_class` indicates class identifier for each service index (service index `0` is always control, so it's\nskipped in this enumeration).\n`packet_count` indicates the number of packets sent by the current device since last announce,\nincluding the current announce packet (it is always 0 if this feature is not supported).\nThe command form can be used to induce report, which is otherwise broadcast every 500ms.",
    fields: [],
    identifierName: "announce",
    hasReport: true
  }, {
    kind: "report",
    name: "services",
    identifier: 0,
    description: "The `restart_counter` is computed from the `flags & RestartCounterSteady`, starts at `0x1` and increments by one until it reaches `0xf`, then it stays at `0xf`.\nIf this number ever goes down, it indicates that the device restarted.\n`service_class` indicates class identifier for each service index (service index `0` is always control, so it's\nskipped in this enumeration).\n`packet_count` indicates the number of packets sent by the current device since last announce,\nincluding the current announce packet (it is always 0 if this feature is not supported).\nThe command form can be used to induce report, which is otherwise broadcast every 500ms.",
    fields: [{
      name: "flags",
      type: "AnnounceFlags",
      storage: 2
    }, {
      name: "packet_count",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "reserved",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "service_class",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      startRepeats: true
    }],
    secondary: true,
    packFormat: "u16 u8 u8 r: u32"
  }, {
    kind: "command",
    name: "noop",
    identifier: 128,
    description: "Do nothing. Always ignored. Can be used to test ACKs.",
    fields: []
  }, {
    kind: "command",
    name: "identify",
    identifier: 129,
    description: "Blink the status LED (262ms on, 262ms off, four times, with the blue LED) or otherwise draw user's attention to device with no status light. \nFor devices with status light (this can be discovered in the announce flags), the client should\nsend the sequence of status light command to generate the identify animation.",
    fields: [],
    optional: true
  }, {
    kind: "command",
    name: "reset",
    identifier: 130,
    description: "Reset device. ACK may or may not be sent.",
    fields: [],
    optional: true
  }, {
    kind: "command",
    name: "flood_ping",
    identifier: 131,
    description: "The device will respond `num_responses` times, as fast as it can, setting the `counter` field in the report\nto `start_counter`, then `start_counter + 1`, ..., and finally `start_counter + num_responses - 1`.\nThe `dummy_payload` is `size` bytes long and contains bytes `0, 1, 2, ...`.",
    fields: [{
      name: "num_responses",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }, {
      name: "start_counter",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }, {
      name: "size",
      unit: "B",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    optional: true,
    hasReport: true,
    packFormat: "u32 u32 u8"
  }, {
    kind: "report",
    name: "flood_ping",
    identifier: 131,
    description: "The device will respond `num_responses` times, as fast as it can, setting the `counter` field in the report\nto `start_counter`, then `start_counter + 1`, ..., and finally `start_counter + num_responses - 1`.\nThe `dummy_payload` is `size` bytes long and contains bytes `0, 1, 2, ...`.",
    fields: [{
      name: "counter",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }, {
      name: "dummy_payload",
      type: "bytes",
      storage: 0,
      isSimpleType: true
    }],
    secondary: true,
    packFormat: "u32 b"
  }, {
    kind: "command",
    name: "set_status_light",
    identifier: 132,
    description: "Initiates a color transition of the status light from its current color to the one specified.\nThe transition will complete in about `512 / speed` frames\n(each frame is currently 100ms, so speed of `51` is about 1 second and `26` 0.5 second).\nAs a special case, if speed is `0` the transition is immediate.\nIf MCU is not capable of executing transitions, it can consider `speed` to be always `0`.\nIf a monochrome LEDs is fitted, the average value of ``red``, ``green``, ``blue`` is used.\nIf intensity of a monochrome LED cannot be controlled, any value larger than `0` should be considered\non, and `0` (for all three channels) should be considered off.",
    fields: [{
      name: "to_red",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "to_green",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "to_blue",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "speed",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    packFormat: "u8 u8 u8 u8"
  }, {
    kind: "command",
    name: "proxy",
    identifier: 133,
    description: "Force client device into proxy mode.",
    fields: [],
    optional: true
  }, {
    kind: "rw",
    name: "reset_in",
    identifier: 128,
    description: "When set to value other than `0`, it asks the device to reset after specified number of microseconds.\nThis is typically used to implement watchdog functionality, where a brain device sets `reset_in` to\nsay 1.6s every 0.5s.",
    fields: [{
      name: "_",
      unit: "us",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    packFormat: "u32"
  }, {
    kind: "const",
    name: "device_description",
    identifier: 384,
    description: "Identifies the type of hardware (eg., ACME Corp. Servo X-42 Rev C)",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    packFormat: "s"
  }, {
    kind: "const",
    name: "product_identifier",
    identifier: 385,
    description: "A numeric code for the string above; used to identify firmware images and devices.",
    fields: [{
      name: "_",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      absoluteMin: 805306368,
      absoluteMax: 1073741823
    }],
    optional: true,
    packFormat: "u32"
  }, {
    kind: "const",
    name: "bootloader_product_identifier",
    identifier: 388,
    description: "Typically the same as `product_identifier` unless device was flashed by hand; the bootloader will respond to that code.",
    fields: [{
      name: "_",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      absoluteMin: 805306368,
      absoluteMax: 1073741823
    }],
    optional: true,
    packFormat: "u32"
  }, {
    kind: "const",
    name: "firmware_version",
    identifier: 389,
    description: "A string describing firmware version; typically semver.",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    packFormat: "s"
  }, {
    kind: "ro",
    name: "mcu_temperature",
    identifier: 386,
    description: "MCU temperature in degrees Celsius (approximate).",
    fields: [{
      name: "_",
      unit: "°C",
      type: "i16",
      storage: -2,
      isSimpleType: true,
      typicalMin: -10,
      typicalMax: 150
    }],
    volatile: true,
    optional: true,
    preferredInterval: 60000,
    packFormat: "i16"
  }, {
    kind: "ro",
    name: "uptime",
    identifier: 390,
    description: "Number of microseconds since boot.",
    fields: [{
      name: "_",
      unit: "us",
      type: "u64",
      storage: 8,
      isSimpleType: true
    }],
    volatile: true,
    optional: true,
    preferredInterval: 60000,
    packFormat: "u64"
  }],
  tags: ["C", "8bit"]
}, {
  name: "Dimmer",
  status: "experimental",
  shortId: "dimmer",
  camelName: "dimmer",
  shortName: "dimmer",
  "extends": ["_base"],
  notes: {
    short: "A light or fan controller that dims the current on a line."
  },
  classIdentifier: 531637829,
  enums: {
    Variant: {
      name: "Variant",
      storage: 1,
      members: {
        Light: 1,
        Fan: 2,
        Pump: 3
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "intensity",
    identifier: 1,
    description: "The intensity of the current. Set to ``0`` to turn off completely the current.",
    fields: [{
      name: "_",
      unit: "/",
      shift: 16,
      type: "u0.16",
      storage: 2
    }],
    identifierName: "intensity",
    packFormat: "u0.16"
  }, {
    kind: "const",
    name: "variant",
    identifier: 263,
    description: "The type of physical device",
    fields: [{
      name: "_",
      type: "Variant",
      storage: 1
    }],
    optional: true,
    identifierName: "variant",
    packFormat: "u8"
  }],
  tags: []
}, {
  name: "Distance",
  status: "experimental",
  shortId: "distance",
  camelName: "distance",
  shortName: "distance",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "A sensor that determines the distance of an object without any physical contact involved."
  },
  classIdentifier: 337275786,
  enums: {
    Variant: {
      name: "Variant",
      storage: 1,
      members: {
        Ultrasonic: 1,
        Infrared: 2,
        LiDAR: 3,
        Laser: 4
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "distance",
    identifier: 257,
    description: "Current distance from the object",
    fields: [{
      name: "_",
      unit: "m",
      shift: 16,
      type: "u16.16",
      storage: 4,
      typicalMin: 0.02,
      typicalMax: 4
    }],
    volatile: true,
    identifierName: "reading",
    packFormat: "u16.16"
  }, {
    kind: "const",
    name: "min_range",
    identifier: 260,
    description: "Minimum measurable distance",
    fields: [{
      name: "_",
      unit: "m",
      shift: 16,
      type: "u16.16",
      storage: 4
    }],
    optional: true,
    identifierName: "min_reading",
    packFormat: "u16.16"
  }, {
    kind: "const",
    name: "max_range",
    identifier: 261,
    description: "Maximum measurable distance",
    fields: [{
      name: "_",
      unit: "m",
      shift: 16,
      type: "u16.16",
      storage: 4
    }],
    optional: true,
    identifierName: "max_reading",
    packFormat: "u16.16"
  }, {
    kind: "const",
    name: "variant",
    identifier: 263,
    description: "Determines the type of sensor used.",
    fields: [{
      name: "_",
      type: "Variant",
      storage: 1
    }],
    optional: true,
    identifierName: "variant",
    packFormat: "u8"
  }],
  tags: ["8bit"]
}, {
  name: "DMX",
  status: "experimental",
  shortId: "dmx",
  camelName: "dmx",
  shortName: "dmx",
  "extends": ["_base"],
  notes: {
    short: "A service that can send DMX512-A packets with limited size. This service is designed to allow tinkering with a few DMX devices, but only allows 235 channels. More about DMX at https://en.wikipedia.org/wiki/DMX512."
  },
  classIdentifier: 298814469,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "enabled",
    identifier: 1,
    description: "Determines if the DMX bridge is active",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1
    }],
    identifierName: "intensity",
    packFormat: "u8"
  }, {
    kind: "command",
    name: "send",
    identifier: 128,
    description: "Send a DMX packet, up to 236bytes long, including the start code.",
    fields: [{
      name: "channels",
      type: "bytes",
      storage: 0,
      isSimpleType: true
    }],
    packFormat: "b"
  }],
  tags: []
}, {
  name: "Dot Matrix",
  status: "experimental",
  shortId: "dotmatrix",
  camelName: "dotMatrix",
  shortName: "dotMatrix",
  "extends": ["_base"],
  notes: {
    short: "A rectangular dot matrix display, made of monochrome LEDs or Braille pins."
  },
  classIdentifier: 286070091,
  enums: {
    Variant: {
      name: "Variant",
      storage: 1,
      members: {
        LED: 1,
        Braille: 2
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "dots",
    identifier: 2,
    description: "The state of the screen where dot on/off state is\nstored as a bit, column by column. The column should be byte aligned.",
    fields: [{
      name: "_",
      type: "bytes",
      storage: 0,
      isSimpleType: true
    }],
    identifierName: "value",
    packFormat: "b"
  }, {
    kind: "rw",
    name: "brightness",
    identifier: 1,
    description: "Reads the general brightness of the display, brightness for LEDs. `0` when the screen is off.",
    fields: [{
      name: "_",
      unit: "/",
      shift: 8,
      type: "u0.8",
      storage: 1
    }],
    optional: true,
    identifierName: "intensity",
    packFormat: "u0.8"
  }, {
    kind: "const",
    name: "rows",
    identifier: 385,
    description: "Number of rows on the screen",
    fields: [{
      name: "_",
      unit: "#",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    packFormat: "u16"
  }, {
    kind: "const",
    name: "columns",
    identifier: 386,
    description: "Number of columns on the screen",
    fields: [{
      name: "_",
      unit: "#",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    packFormat: "u16"
  }, {
    kind: "const",
    name: "variant",
    identifier: 263,
    description: "Describes the type of matrix used.",
    fields: [{
      name: "_",
      type: "Variant",
      storage: 1
    }],
    optional: true,
    identifierName: "variant",
    packFormat: "u8"
  }],
  tags: [],
  group: "Display"
}, {
  name: "Equivalent CO₂",
  status: "experimental",
  shortId: "eco2",
  camelName: "eCO2",
  shortName: "eCO2",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "Measures equivalent CO₂ levels."
  },
  classIdentifier: 379362758,
  enums: {
    Variant: {
      name: "Variant",
      storage: 1,
      members: {
        VOC: 1,
        NDIR: 2
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "e_CO2",
    identifier: 257,
    description: "Equivalent CO₂ (eCO₂) readings.",
    fields: [{
      name: "_",
      unit: "ppm",
      shift: 10,
      type: "u22.10",
      storage: 4,
      typicalMin: 400,
      typicalMax: 8192
    }],
    volatile: true,
    identifierName: "reading",
    preferredInterval: 1000,
    packFormat: "u22.10"
  }, {
    kind: "ro",
    name: "e_CO2_error",
    identifier: 262,
    description: "Error on the reading value.",
    fields: [{
      name: "_",
      unit: "ppm",
      shift: 10,
      type: "u22.10",
      storage: 4
    }],
    volatile: true,
    identifierName: "reading_error",
    packFormat: "u22.10"
  }, {
    kind: "const",
    name: "min_e_CO2",
    identifier: 260,
    description: "Minimum measurable value",
    fields: [{
      name: "_",
      unit: "ppm",
      shift: 10,
      type: "u22.10",
      storage: 4
    }],
    optional: true,
    identifierName: "min_reading",
    packFormat: "u22.10"
  }, {
    kind: "const",
    name: "max_e_CO2",
    identifier: 261,
    description: "Minimum measurable value",
    fields: [{
      name: "_",
      unit: "ppm",
      shift: 10,
      type: "u22.10",
      storage: 4
    }],
    optional: true,
    identifierName: "max_reading",
    packFormat: "u22.10"
  }, {
    kind: "const",
    name: "conditioning_period",
    identifier: 384,
    description: "Time required to achieve good sensor stability before measuring after long idle period.",
    fields: [{
      name: "_",
      unit: "s",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    optional: true,
    packFormat: "u32"
  }, {
    kind: "const",
    name: "variant",
    identifier: 263,
    description: "Type of physical sensor and capabilities.",
    fields: [{
      name: "_",
      type: "Variant",
      storage: 1
    }],
    optional: true,
    identifierName: "variant",
    packFormat: "u8"
  }],
  tags: ["8bit"],
  group: "Environment"
}, {
  name: "Flex",
  status: "experimental",
  shortId: "flex",
  camelName: "flex",
  shortName: "flex",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "A bending or deflection sensor."
  },
  classIdentifier: 524797638,
  enums: {
    Variant: {
      name: "Variant",
      storage: 1,
      members: {
        Linear22Inch: 1,
        Linear45Inch: 2
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "bending",
    identifier: 257,
    description: "The relative position of the slider.",
    fields: [{
      name: "_",
      unit: "/",
      shift: 16,
      type: "u0.16",
      storage: 2
    }],
    volatile: true,
    identifierName: "reading",
    packFormat: "u0.16"
  }, {
    kind: "const",
    name: "variant",
    identifier: 263,
    description: "Specifies the physical layout of the flex sensor.",
    fields: [{
      name: "_",
      type: "Variant",
      storage: 1
    }],
    optional: true,
    identifierName: "variant",
    packFormat: "u8"
  }],
  tags: ["C", "8bit"],
  group: "Slider"
}, {
  name: "Gyroscope",
  status: "experimental",
  shortId: "gyroscope",
  camelName: "gyroscope",
  shortName: "gyroscope",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "A 3-axis gyroscope."
  },
  classIdentifier: 505087730,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "rotation_rates",
    identifier: 257,
    description: "Indicates the current forces acting on accelerometer.",
    fields: [{
      name: "x",
      unit: "°/s",
      shift: 20,
      type: "i12.20",
      storage: -4
    }, {
      name: "y",
      unit: "°/s",
      shift: 20,
      type: "i12.20",
      storage: -4
    }, {
      name: "z",
      unit: "°/s",
      shift: 20,
      type: "i12.20",
      storage: -4
    }],
    volatile: true,
    identifierName: "reading",
    packFormat: "i12.20 i12.20 i12.20"
  }, {
    kind: "ro",
    name: "rotation_rates_error",
    identifier: 262,
    description: "Error on the reading value.",
    fields: [{
      name: "_",
      unit: "°/s",
      shift: 20,
      type: "i12.20",
      storage: -4
    }],
    volatile: true,
    optional: true,
    identifierName: "reading_error",
    packFormat: "i12.20"
  }, {
    kind: "rw",
    name: "max_rate",
    identifier: 128,
    description: "Configures the range of range of rotation rates.",
    fields: [{
      name: "_",
      unit: "°/s",
      shift: 20,
      type: "i12.20",
      storage: -4
    }],
    optional: true,
    packFormat: "i12.20"
  }],
  tags: [],
  group: "Movement"
}, {
  name: "Heart Rate",
  status: "experimental",
  shortId: "heartrate",
  camelName: "heartRate",
  shortName: "heartRate",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "A sensor approximating the heart rate. \n\n\n**Jacdac is NOT suitable for medical devices and should NOT be used in any kind of device to diagnose or treat any medical conditions.**"
  },
  classIdentifier: 376204740,
  enums: {
    Variant: {
      name: "Variant",
      storage: 1,
      members: {
        Finger: 1,
        Chest: 2,
        Wrist: 3,
        Pump: 4,
        WebCam: 5
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "heart_rate",
    identifier: 257,
    description: "The estimated heart rate.",
    fields: [{
      name: "_",
      unit: "bpm",
      shift: 16,
      type: "u16.16",
      storage: 4,
      typicalMin: 30,
      typicalMax: 200
    }],
    volatile: true,
    identifierName: "reading",
    preferredInterval: 1000,
    packFormat: "u16.16"
  }, {
    kind: "ro",
    name: "heart_rate_error",
    identifier: 262,
    description: "The estimated error on the reported sensor data.",
    fields: [{
      name: "_",
      unit: "bpm",
      shift: 16,
      type: "u16.16",
      storage: 4
    }],
    volatile: true,
    optional: true,
    identifierName: "reading_error",
    packFormat: "u16.16"
  }, {
    kind: "const",
    name: "variant",
    identifier: 263,
    description: "The type of physical sensor",
    fields: [{
      name: "_",
      type: "Variant",
      storage: 1
    }],
    optional: true,
    identifierName: "variant",
    packFormat: "u8"
  }],
  tags: ["8bit"],
  group: "Biometric"
}, {
  name: "HID Adapter",
  status: "experimental",
  shortId: "hidadapter",
  camelName: "hidAdapter",
  shortName: "hidAdapter",
  "extends": ["_base"],
  notes: {
    short: "A service for configuring how Jacdac device map to HID input events. Users can have multiple configurations and swap between them by writing to `current_configuration`."
  },
  classIdentifier: 509040821,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "num_configurations",
    identifier: 128,
    description: "The number of configurations stored on the server.",
    fields: [{
      name: "_",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    packFormat: "u8"
  }, {
    kind: "rw",
    name: "current_configuration",
    identifier: 129,
    description: "The current configuration the server is using.",
    fields: [{
      name: "_",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    packFormat: "u8"
  }, {
    kind: "command",
    name: "get_configuration",
    identifier: 128,
    description: "Retrieves a configuration stored on the server. If the configuration does not exist, an empty report will be returned",
    fields: [{
      name: "results",
      type: "pipe",
      storage: 12
    }, {
      name: "configuration_number",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    pipeType: "get_configuration",
    packFormat: "b[12] u8"
  }, {
    kind: "pipe_report",
    name: "configuration",
    identifier: 0,
    description: "Retrieves a configuration stored on the server. If the configuration does not exist, an empty report will be returned",
    fields: [{
      name: "configuration_number",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "binding_index",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "padding",
      type: "u8[2]",
      storage: 2
    }, {
      name: "device_id",
      type: "u64",
      storage: 8,
      isSimpleType: true
    }, {
      name: "service_class",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }, {
      name: "trigger_value",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }, {
      name: "trigger_context",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "service_index",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "selector",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "modifiers",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    pipeType: "get_configuration",
    packFormat: "u8 u8 b[2] u64 u32 u32 u8 u8 u16 u16"
  }, {
    kind: "command",
    name: "set_binding",
    identifier: 130,
    description: "Stores the given binding on the server. If a binding exists at this index, the new binding will replace it.",
    fields: [{
      name: "configuration_number",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "binding_index",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "padding",
      type: "u8[2]",
      storage: 2
    }, {
      name: "device_id",
      type: "u64",
      storage: 8,
      isSimpleType: true
    }, {
      name: "service_class",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }, {
      name: "trigger_value",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }, {
      name: "trigger_context",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "service_index",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "selector",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "modifiers",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    packFormat: "u8 u8 b[2] u64 u32 u32 u8 u8 u16 u16"
  }, {
    kind: "command",
    name: "clear_binding",
    identifier: 131,
    description: "Clears a specific binding stored on the device.",
    fields: [{
      name: "configuration_number",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "binding_index",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    packFormat: "u8 u8"
  }, {
    kind: "command",
    name: "clear_configuration",
    identifier: 132,
    description: "Clears a specific configuration stored on the device.",
    fields: [{
      name: "configuration_number",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    packFormat: "u8"
  }, {
    kind: "command",
    name: "clear",
    identifier: 133,
    description: "Clears all configurations and bindings stored on the device.",
    fields: []
  }, {
    kind: "event",
    name: "changed",
    identifier: 3,
    description: "Event that notifies clients that the server has swapped to a new configuration or changed key bindings.",
    fields: [],
    identifierName: "change"
  }],
  tags: []
}, {
  name: "HID Keyboard",
  status: "experimental",
  shortId: "hidkeyboard",
  camelName: "hidKeyboard",
  shortName: "hidKeyboard",
  "extends": ["_base"],
  notes: {
    short: "Control a HID keyboard. \n\nThe codes for the key (selectors) is defined in the [HID Keyboard\nspecification](https://usb.org/sites/default/files/hut1_21.pdf), chapter 10 Keyboard/Keypad Page, page 81.\nModifiers are in page 87.\n\nThe device keeps tracks of the key state and is able to clear it all with the clear command."
  },
  classIdentifier: 414210922,
  enums: {
    Modifiers: {
      name: "Modifiers",
      storage: 1,
      isFlags: true,
      members: {
        None: 0,
        LeftControl: 1,
        LeftShift: 2,
        LeftAlt: 4,
        LeftGUI: 8,
        RightControl: 16,
        RightShift: 32,
        RightAlt: 64,
        RightGUI: 128
      }
    },
    Action: {
      name: "Action",
      storage: 1,
      members: {
        Press: 0,
        Up: 1,
        Down: 2
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "command",
    name: "key",
    identifier: 128,
    description: "Presses a key or a sequence of keys down.",
    fields: [{
      name: "selector",
      type: "u16",
      storage: 2,
      isSimpleType: true,
      startRepeats: true
    }, {
      name: "modifiers",
      type: "Modifiers",
      storage: 1
    }, {
      name: "action",
      type: "Action",
      storage: 1
    }],
    lowLevel: true,
    packFormat: "r: u16 u8 u8"
  }, {
    kind: "command",
    name: "clear",
    identifier: 129,
    description: "Clears all pressed keys.",
    fields: []
  }],
  tags: ["8bit"]
}, {
  name: "HID Mouse",
  status: "experimental",
  shortId: "hidmouse",
  camelName: "hidMouse",
  shortName: "hidMouse",
  "extends": ["_base"],
  notes: {
    short: "Controls a HID mouse."
  },
  classIdentifier: 411425820,
  enums: {
    Button: {
      name: "Button",
      storage: 2,
      isFlags: true,
      members: {
        Left: 1,
        Right: 2,
        Middle: 4
      }
    },
    ButtonEvent: {
      name: "ButtonEvent",
      storage: 1,
      members: {
        Up: 1,
        Down: 2,
        Click: 3,
        DoubleClick: 4
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "command",
    name: "set_button",
    identifier: 128,
    description: "Sets the up/down state of one or more buttons.\nA ``Click`` is the same as ``Down`` followed by ``Up`` after 100ms.\nA ``DoubleClick`` is two clicks with ``150ms`` gap between them (that is, ``100ms`` first click, ``150ms`` gap, ``100ms`` second click).",
    fields: [{
      name: "buttons",
      type: "Button",
      storage: 2
    }, {
      name: "event",
      type: "ButtonEvent",
      storage: 1
    }],
    packFormat: "u16 u8"
  }, {
    kind: "command",
    name: "move",
    identifier: 129,
    description: "Moves the mouse by the distance specified.\nIf the time is positive, it specifies how long to make the move.",
    fields: [{
      name: "dx",
      unit: "#",
      type: "i16",
      storage: -2,
      isSimpleType: true
    }, {
      name: "dy",
      unit: "#",
      type: "i16",
      storage: -2,
      isSimpleType: true
    }, {
      name: "time",
      unit: "ms",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    packFormat: "i16 i16 u16"
  }, {
    kind: "command",
    name: "wheel",
    identifier: 130,
    description: "Turns the wheel up or down. Positive if scrolling up.\nIf the time is positive, it specifies how long to make the move.",
    fields: [{
      name: "dy",
      unit: "#",
      type: "i16",
      storage: -2,
      isSimpleType: true
    }, {
      name: "time",
      unit: "ms",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    packFormat: "i16 u16"
  }],
  tags: ["8bit"]
}, {
  name: "Humidity",
  status: "experimental",
  shortId: "humidity",
  camelName: "humidity",
  shortName: "humidity",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "A sensor measuring humidity of outside environment.",
    registers: "Default streaming interval is 1s."
  },
  classIdentifier: 382210232,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "humidity",
    identifier: 257,
    description: "The relative humidity in percentage of full water saturation.",
    fields: [{
      name: "_",
      unit: "%RH",
      shift: 10,
      type: "u22.10",
      storage: 4,
      typicalMax: 100,
      typicalMin: 0
    }],
    volatile: true,
    identifierName: "reading",
    preferredInterval: 5000,
    packFormat: "u22.10"
  }, {
    kind: "ro",
    name: "humidity_error",
    identifier: 262,
    description: "The real humidity is between `humidity - humidity_error` and `humidity + humidity_error`.",
    fields: [{
      name: "_",
      unit: "%RH",
      shift: 10,
      type: "u22.10",
      storage: 4
    }],
    volatile: true,
    identifierName: "reading_error",
    packFormat: "u22.10"
  }, {
    kind: "const",
    name: "min_humidity",
    identifier: 260,
    description: "Lowest humidity that can be reported.",
    fields: [{
      name: "_",
      unit: "%RH",
      shift: 10,
      type: "u22.10",
      storage: 4,
      defaultValue: 0
    }],
    identifierName: "min_reading",
    packFormat: "u22.10"
  }, {
    kind: "const",
    name: "max_humidity",
    identifier: 261,
    description: "Highest humidity that can be reported.",
    fields: [{
      name: "_",
      unit: "%RH",
      shift: 10,
      type: "u22.10",
      storage: 4,
      defaultValue: 100
    }],
    identifierName: "max_reading",
    packFormat: "u22.10"
  }],
  tags: ["C", "8bit"],
  group: "Environment"
}, {
  name: "Illuminance",
  status: "experimental",
  shortId: "illuminance",
  camelName: "illuminance",
  shortName: "illuminance",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "Detects the amount of light falling onto a given surface area.\n\nNote that this is different from *luminance*, the amount of light that passes through, emits from, or reflects off an object."
  },
  classIdentifier: 510577394,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "light",
    identifier: 257,
    description: "The amount of illuminance, as lumens per square metre.",
    fields: [{
      name: "_",
      unit: "lux",
      shift: 10,
      type: "u22.10",
      storage: 4,
      typicalMax: 100000,
      typicalMin: 0
    }],
    volatile: true,
    identifierName: "reading",
    packFormat: "u22.10"
  }, {
    kind: "ro",
    name: "light_error",
    identifier: 262,
    description: "Error on the reported sensor value.",
    fields: [{
      name: "_",
      unit: "lux",
      shift: 10,
      type: "u22.10",
      storage: 4
    }],
    volatile: true,
    optional: true,
    identifierName: "reading_error",
    packFormat: "u22.10"
  }],
  tags: ["8bit", "padauk"],
  group: "Imaging"
}, {
  name: "Indexed screen",
  status: "experimental",
  shortId: "indexedscreen",
  camelName: "indexedScreen",
  shortName: "indexedScreen",
  "extends": ["_base"],
  notes: {
    short: "A screen with indexed colors.\n\nThis is often run over an SPI connection, not regular single-wire JACDAC."
  },
  classIdentifier: 385496805,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "command",
    name: "start_update",
    identifier: 129,
    description: "Sets the update window for subsequent `set_pixels` commands.",
    fields: [{
      name: "x",
      unit: "px",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "y",
      unit: "px",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "width",
      unit: "px",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "height",
      unit: "px",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    packFormat: "u16 u16 u16 u16"
  }, {
    kind: "command",
    name: "set_pixels",
    identifier: 131,
    description: "Set pixels in current window, according to current palette.\nEach \"line\" of data is aligned to a byte.",
    fields: [{
      name: "pixels",
      type: "bytes",
      storage: 0,
      isSimpleType: true
    }],
    packFormat: "b"
  }, {
    kind: "rw",
    name: "brightness",
    identifier: 1,
    description: "Set backlight brightness.\nIf set to `0` the display may go to sleep.",
    fields: [{
      name: "_",
      unit: "/",
      shift: 8,
      type: "u0.8",
      storage: 1
    }],
    identifierName: "intensity",
    packFormat: "u0.8"
  }, {
    kind: "rw",
    name: "palette",
    identifier: 128,
    description: "The current palette.\nThe color entry repeats `1 << bits_per_pixel` times.\nThis register may be write-only.",
    fields: [{
      name: "blue",
      type: "u8",
      storage: 1,
      isSimpleType: true,
      startRepeats: true
    }, {
      name: "green",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "red",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "padding",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    packFormat: "r: u8 u8 u8 u8"
  }, {
    kind: "const",
    name: "bits_per_pixel",
    identifier: 384,
    description: "Determines the number of palette entries.\nTypical values are 1, 2, 4, or 8.",
    fields: [{
      name: "_",
      unit: "bit",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    packFormat: "u8"
  }, {
    kind: "const",
    name: "width",
    identifier: 385,
    description: "Screen width in \"natural\" orientation.",
    fields: [{
      name: "_",
      unit: "px",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    packFormat: "u16"
  }, {
    kind: "const",
    name: "height",
    identifier: 386,
    description: "Screen height in \"natural\" orientation.",
    fields: [{
      name: "_",
      unit: "px",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    packFormat: "u16"
  }, {
    kind: "rw",
    name: "width_major",
    identifier: 129,
    description: "If true, consecutive pixels in the \"width\" direction are sent next to each other (this is typical for graphics cards).\nIf false, consecutive pixels in the \"height\" direction are sent next to each other.\nFor embedded screen controllers, this is typically true iff `width < height`\n(in other words, it's only true for portrait orientation screens).\nSome controllers may allow the user to change this (though the refresh order may not be optimal then).\nThis is independent of the `rotation` register.",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1
    }],
    packFormat: "u8"
  }, {
    kind: "rw",
    name: "up_sampling",
    identifier: 130,
    description: "Every pixel sent over wire is represented by `up_sampling x up_sampling` square of physical pixels.\nSome displays may allow changing this (which will also result in changes to `width` and `height`).\nTypical values are 1 and 2.",
    fields: [{
      name: "_",
      unit: "px",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    packFormat: "u8"
  }, {
    kind: "rw",
    name: "rotation",
    identifier: 131,
    description: "Possible values are 0, 90, 180 and 270 only.\nWrite to this register do not affect `width` and `height` registers,\nand may be ignored by some screens.",
    fields: [{
      name: "_",
      unit: "°",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    packFormat: "u16"
  }],
  tags: []
}, {
  name: "Infrastructure",
  status: "experimental",
  shortId: "infrastructure",
  camelName: "infrastructure",
  shortName: "infrastructure",
  "extends": ["_base"],
  notes: {
    short: "A service that tags a device as purely infrastructure device.\n\n\nA Jacdac user interface can ignore any device that hosts this service."
  },
  classIdentifier: 504728043,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }],
  tags: []
}, {
  name: "Joystick",
  status: "experimental",
  shortId: "joystick",
  camelName: "joystick",
  shortName: "joystick",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "A two axis directional joystick"
  },
  classIdentifier: 277836886,
  enums: {
    Buttons: {
      name: "Buttons",
      storage: 4,
      isFlags: true,
      members: {
        Left: 1,
        Up: 2,
        Right: 4,
        Down: 8,
        A: 16,
        B: 32,
        Menu: 64,
        Select: 128,
        Reset: 256,
        Exit: 512,
        X: 1024,
        Y: 2048
      }
    },
    Variant: {
      name: "Variant",
      storage: 1,
      members: {
        Thumb: 1,
        ArcadeBall: 2,
        ArcadeStick: 3,
        Gamepad: 4
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "direction",
    identifier: 257,
    description: "If the joystick is analog, the directional buttons should be \"simulated\", based on joystick position\n(`Left` is `{ x = -1, y = 0 }`, `Up` is `{ x = 0, y = -1}`).\nIf the joystick is digital, then each direction will read as either `-1`, `0`, or `1` (in fixed representation).\nThe primary button on the joystick is `A`.",
    fields: [{
      name: "buttons",
      type: "Buttons",
      storage: 4
    }, {
      name: "x",
      unit: "/",
      shift: 15,
      type: "i1.15",
      storage: -2
    }, {
      name: "y",
      unit: "/",
      shift: 15,
      type: "i1.15",
      storage: -2
    }],
    volatile: true,
    identifierName: "reading",
    packFormat: "u32 i1.15 i1.15"
  }, {
    kind: "const",
    name: "variant",
    identifier: 263,
    description: "The type of physical joystick.",
    fields: [{
      name: "_",
      type: "Variant",
      storage: 1
    }],
    optional: true,
    identifierName: "variant",
    packFormat: "u8"
  }, {
    kind: "const",
    name: "buttons_available",
    identifier: 384,
    description: "Indicates a bitmask of the buttons that are mounted on the joystick.\nIf the `Left`/`Up`/`Right`/`Down` buttons are marked as available here, the joystick is digital.\nEven when marked as not available, they will still be simulated based on the analog joystick.",
    fields: [{
      name: "_",
      type: "Buttons",
      storage: 4
    }],
    packFormat: "u32"
  }, {
    kind: "event",
    name: "buttons_changed",
    identifier: 3,
    description: "Emitted whenever the state of buttons changes.",
    fields: [{
      name: "buttons",
      type: "Buttons",
      storage: 4
    }],
    identifierName: "change",
    packFormat: "u32"
  }],
  tags: ["8bit", "padauk"],
  group: "Button"
}, {
  name: "LED",
  status: "experimental",
  shortId: "led",
  camelName: "led",
  shortName: "led",
  "extends": ["_base"],
  notes: {
    short: "A controller for 1 or more monochrome or RGB LEDs connected in parallel."
  },
  classIdentifier: 506480888,
  enums: {
    Variant: {
      name: "Variant",
      storage: 1,
      members: {
        ThroughHole: 1,
        SMD: 2,
        Power: 3,
        Bead: 4
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "command",
    name: "animate",
    identifier: 128,
    description: "This has the same semantics as `set_status_light` in the control service.",
    fields: [{
      name: "to_red",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "to_green",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "to_blue",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "speed",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    packFormat: "u8 u8 u8 u8"
  }, {
    kind: "ro",
    name: "color",
    identifier: 384,
    description: "The current color of the LED.",
    fields: [{
      name: "red",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "green",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "blue",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    packFormat: "u8 u8 u8"
  }, {
    kind: "rw",
    name: "max_power",
    identifier: 7,
    description: "Limit the power drawn by the light-strip (and controller).",
    fields: [{
      name: "_",
      unit: "mA",
      type: "u16",
      storage: 2,
      isSimpleType: true,
      defaultValue: 100
    }],
    optional: true,
    identifierName: "max_power",
    packFormat: "u16"
  }, {
    kind: "const",
    name: "led_count",
    identifier: 387,
    description: "If known, specifies the number of LEDs in parallel on this device.",
    fields: [{
      name: "_",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    packFormat: "u16"
  }, {
    kind: "const",
    name: "wave_length",
    identifier: 385,
    description: "If monochrome LED, specifies the wave length of the LED.",
    fields: [{
      name: "_",
      unit: "nm",
      type: "u16",
      storage: 2,
      isSimpleType: true,
      typicalMin: 365,
      typicalMax: 885
    }],
    optional: true,
    packFormat: "u16"
  }, {
    kind: "const",
    name: "luminous_intensity",
    identifier: 386,
    description: "The luminous intensity of the LED, at full value, in micro candella.",
    fields: [{
      name: "_",
      unit: "mcd",
      type: "u16",
      storage: 2,
      isSimpleType: true,
      typicalMin: 10,
      typicalMax: 5000
    }],
    optional: true,
    packFormat: "u16"
  }, {
    kind: "const",
    name: "variant",
    identifier: 263,
    description: "The physical type of LED.",
    fields: [{
      name: "_",
      type: "Variant",
      storage: 1
    }],
    optional: true,
    identifierName: "variant",
    packFormat: "u8"
  }],
  tags: ["8bit", "padauk"],
  group: "Light"
}, {
  name: "LED Pixel",
  status: "experimental",
  shortId: "ledpixel",
  camelName: "ledPixel",
  shortName: "ledPixel",
  "extends": ["_base"],
  notes: {
    short: "A controller for strips of individually controlled RGB LEDs.",
    long: "## Light programs\n\nRealistically, with 1 mbit Jacdac, we can transmit under 2k of data per animation frame (at 20fps).\nIf transmitting raw data that would be around 500 pixels, which is not enough for many\ninstallations and it would completely clog the network.\n\nThus, light service defines a domain-specific language for describing light animations\nand efficiently transmitting them over wire.\n\nLight commands are not Jacdac commands.\nLight commands are efficiently encoded as sequences of bytes and typically sent as payload\nof `run` command.\n\nDefinitions:\n* `P` - position in the strip\n* `R` - number of repetitions of the command\n* `N` - number of pixels affected by the command\n* `C` - single color designation\n* `C+` - sequence of color designations\n\nUpdate modes:\n* `0` - replace\n* `1` - add RGB\n* `2` - subtract RGB\n* `3` - multiply RGB (by c/128); each pixel value will change by at least 1\n\nProgram commands:\n* `0xD0: setall C+` - set all pixels in current range to given color pattern\n* `0xD1: fade C+` - set pixels in current range to colors between colors in sequence\n* `0xD2: fadehsv C+` - similar to `fade()`, but colors are specified and faded in HSV\n* `0xD3: rotfwd K` - rotate (shift) pixels by `K` positions away from the connector\n* `0xD4: rotback K` - same, but towards the connector\n* `0xD5: show M=50` - send buffer to strip and wait `M` milliseconds\n* `0xD6: range P=0 N=length W=1 S=0` - range from pixel `P`, `N` pixels long\n  (currently unsupported: every `W` pixels skip `S` pixels)\n* `0xD7: mode K=0` - set update mode\n* `0xD8: tmpmode K=0` - set update mode for next command only\n* `0xCF: setone P C` - set one pixel at `P` (in current range) to given color\n* `mult V` - macro to multiply current range by given value (float)\n\nA number `k` is encoded as follows:\n* `0 <= k < 128` -> `k`\n* `128 <= k < 16383` -> `0x80 | (k >> 8), k & 0xff`\n* bigger and negative numbers are not supported\n\nThus, bytes `0xC0-0xFF` are free to use for commands.\n\nFormats:\n* `0xC1, R, G, B` - single color parameter\n* `0xC2, R0, G0, B0, R1, G1, B1` - two color parameter\n* `0xC3, R0, G0, B0, R1, G1, B1, R2, G2, B2` - three color parameter\n* `0xC0, N, R0, G0, B0, ..., R(N-1), G(N-1), B(N-1)` - `N` color parameter\n* `0xCF, <number>, R, G, B` - `set1` special format\n\nCommands are encoded as command byte, followed by parameters in the order\nfrom the command definition.\n\nThe `setone()` command has irregular encoding to save space - it is byte `0xCF` followed by encoded\nnumber, and followed by 3 bytes of color."
  },
  classIdentifier: 309264608,
  enums: {
    LightType: {
      name: "LightType",
      storage: 1,
      members: {
        WS2812B_GRB: 0,
        APA102: 16,
        SK9822: 17
      }
    },
    Variant: {
      name: "Variant",
      storage: 1,
      members: {
        Strip: 1,
        Ring: 2,
        Stick: 3,
        Jewel: 4,
        Matrix: 5
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "brightness",
    identifier: 1,
    description: "Set the luminosity of the strip.\nAt `0` the power to the strip is completely shut down.",
    fields: [{
      name: "_",
      unit: "/",
      shift: 8,
      type: "u0.8",
      storage: 1,
      defaultValue: 0.05
    }],
    identifierName: "intensity",
    packFormat: "u0.8"
  }, {
    kind: "ro",
    name: "actual_brightness",
    identifier: 384,
    description: "This is the luminosity actually applied to the strip.\nMay be lower than `brightness` if power-limited by the `max_power` register.\nIt will rise slowly (few seconds) back to `brightness` is limits are no longer required.",
    fields: [{
      name: "_",
      unit: "/",
      shift: 8,
      type: "u0.8",
      storage: 1
    }],
    packFormat: "u0.8"
  }, {
    kind: "rw",
    name: "light_type",
    identifier: 128,
    description: "Specifies the type of light strip connected to controller.\nControllers which are sold with lights should default to the correct type\nand could not allow change.",
    fields: [{
      name: "_",
      type: "LightType",
      storage: 1
    }],
    packFormat: "u8"
  }, {
    kind: "rw",
    name: "num_pixels",
    identifier: 129,
    description: "Specifies the number of pixels in the strip.\nControllers which are sold with lights should default to the correct length\nand could not allow change. Increasing length at runtime leads to ineffective use of memory and may lead to controller reboot.",
    fields: [{
      name: "_",
      unit: "#",
      type: "u16",
      storage: 2,
      isSimpleType: true,
      defaultValue: 15
    }],
    packFormat: "u16"
  }, {
    kind: "rw",
    name: "num_columns",
    identifier: 131,
    description: "If the LED pixel strip is a matrix, specifies the number of columns. Otherwise, a square shape is assumed. Controllers which are sold with lights should default to the correct length\nand could not allow change. Increasing length at runtime leads to ineffective use of memory and may lead to controller reboot.",
    fields: [{
      name: "_",
      unit: "#",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    packFormat: "u16"
  }, {
    kind: "rw",
    name: "max_power",
    identifier: 7,
    description: "Limit the power drawn by the light-strip (and controller).",
    fields: [{
      name: "_",
      unit: "mA",
      type: "u16",
      storage: 2,
      isSimpleType: true,
      defaultValue: 200
    }],
    identifierName: "max_power",
    packFormat: "u16"
  }, {
    kind: "const",
    name: "max_pixels",
    identifier: 385,
    description: "The maximum supported number of pixels.\nAll writes to `num_pixels` are clamped to `max_pixels`.",
    fields: [{
      name: "_",
      unit: "#",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    packFormat: "u16"
  }, {
    kind: "rw",
    name: "num_repeats",
    identifier: 130,
    description: "How many times to repeat the program passed in `run` command.\nShould be set before the `run` command.\nSetting to `0` means to repeat forever.",
    fields: [{
      name: "_",
      unit: "#",
      type: "u16",
      storage: 2,
      isSimpleType: true,
      defaultValue: 1
    }],
    packFormat: "u16"
  }, {
    kind: "const",
    name: "variant",
    identifier: 263,
    description: "Specifies the shape of the light strip.",
    fields: [{
      name: "_",
      type: "Variant",
      storage: 1
    }],
    optional: true,
    identifierName: "variant",
    packFormat: "u8"
  }, {
    kind: "command",
    name: "run",
    identifier: 129,
    description: "Run the given light \"program\". See service description for details.",
    fields: [{
      name: "program",
      type: "bytes",
      storage: 0,
      isSimpleType: true
    }],
    packFormat: "b"
  }],
  tags: ["C"],
  group: "Light"
}, {
  name: "Light level",
  status: "experimental",
  shortId: "lightlevel",
  camelName: "lightLevel",
  shortName: "lightLevel",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "A sensor that measures luminosity level."
  },
  classIdentifier: 400333340,
  enums: {
    Variant: {
      name: "Variant",
      storage: 1,
      members: {
        PhotoResistor: 1,
        LEDMatrix: 2,
        Ambient: 3
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "light_level",
    identifier: 257,
    description: "Detect light level",
    fields: [{
      name: "_",
      unit: "/",
      shift: 16,
      type: "u0.16",
      storage: 2
    }],
    volatile: true,
    identifierName: "reading",
    packFormat: "u0.16"
  }, {
    kind: "const",
    name: "variant",
    identifier: 263,
    description: "The type of physical sensor.",
    fields: [{
      name: "_",
      type: "Variant",
      storage: 1
    }],
    optional: true,
    identifierName: "variant",
    packFormat: "u8"
  }],
  tags: ["8bit", "padauk"],
  group: "Imaging"
}, {
  name: "Logger",
  status: "experimental",
  shortId: "logger",
  camelName: "logger",
  shortName: "logger",
  "extends": ["_base"],
  notes: {
    short: "A service which can report messages to the bus."
  },
  classIdentifier: 316415946,
  enums: {
    Priority: {
      name: "Priority",
      storage: 1,
      members: {
        Debug: 0,
        Log: 1,
        Warning: 2,
        "Error": 3,
        Silent: 4
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "min_priority",
    identifier: 128,
    description: "Messages with level lower than this won't be emitted. The default setting may vary.\nLoggers should revert this to their default setting if the register has not been\nupdated in 3000ms, and also keep the lowest setting they have seen in the last 1500ms.\nThus, clients should write this register every 1000ms and ignore messages which are\ntoo verbose for them.",
    fields: [{
      name: "_",
      type: "Priority",
      storage: 1,
      defaultValue: 1
    }],
    packFormat: "u8"
  }, {
    kind: "report",
    name: "debug",
    identifier: 128,
    description: "Report a message.",
    fields: [{
      name: "message",
      type: "string",
      storage: 0
    }],
    packFormat: "s"
  }, {
    kind: "report",
    name: "log",
    identifier: 129,
    description: "Report a message.",
    fields: [{
      name: "message",
      type: "string",
      storage: 0
    }],
    packFormat: "s"
  }, {
    kind: "report",
    name: "warn",
    identifier: 130,
    description: "Report a message.",
    fields: [{
      name: "message",
      type: "string",
      storage: 0
    }],
    packFormat: "s"
  }, {
    kind: "report",
    name: "error",
    identifier: 131,
    description: "Report a message.",
    fields: [{
      name: "message",
      type: "string",
      storage: 0
    }],
    packFormat: "s"
  }],
  tags: ["C"]
}, {
  name: "Magnetometer",
  status: "experimental",
  shortId: "magnetomer",
  camelName: "magnetometer",
  shortName: "magnetometer",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "A 3-axis magnetometer."
  },
  classIdentifier: 318935176,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "forces",
    identifier: 257,
    description: "Indicates the current magnetic field on magnetometer.\nFor reference: `1 mgauss` is `100 nT` (and `1 gauss` is `100 000 nT`).",
    fields: [{
      name: "x",
      unit: "nT",
      type: "i32",
      storage: -4,
      isSimpleType: true
    }, {
      name: "y",
      unit: "nT",
      type: "i32",
      storage: -4,
      isSimpleType: true
    }, {
      name: "z",
      unit: "nT",
      type: "i32",
      storage: -4,
      isSimpleType: true
    }],
    volatile: true,
    identifierName: "reading",
    packFormat: "i32 i32 i32"
  }, {
    kind: "ro",
    name: "forces_error",
    identifier: 262,
    description: "Error on the readings.",
    fields: [{
      name: "_",
      unit: "nT",
      type: "i32",
      storage: -4,
      isSimpleType: true
    }],
    volatile: true,
    optional: true,
    identifierName: "reading_error",
    packFormat: "i32"
  }, {
    kind: "command",
    name: "calibrate",
    identifier: 2,
    description: "Forces a calibration sequence where the user/device\nmight have to rotate to be calibrated.",
    fields: [],
    identifierName: "calibrate"
  }],
  tags: []
}, {
  name: "Matrix Keypad",
  status: "experimental",
  shortId: "matrixkeypad",
  camelName: "matrixKeypad",
  shortName: "matrixKeypad",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "A matrix of buttons connected as a keypad"
  },
  classIdentifier: 319172040,
  enums: {
    Variant: {
      name: "Variant",
      storage: 1,
      members: {
        Membrane: 1,
        Keyboard: 2,
        Elastomer: 3,
        ElastomerLEDPixel: 4
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "pressed",
    identifier: 257,
    description: "The coordinate of the button currently pressed. Keys are zero-indexed from left to right, top to bottom:\n``row = index / columns``, ``column = index % columns``.",
    fields: [{
      name: "index",
      type: "u8",
      storage: 1,
      isSimpleType: true,
      startRepeats: true
    }],
    volatile: true,
    identifierName: "reading",
    packFormat: "r: u8"
  }, {
    kind: "const",
    name: "rows",
    identifier: 384,
    description: "Number of rows in the matrix",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    packFormat: "u8"
  }, {
    kind: "const",
    name: "columns",
    identifier: 385,
    description: "Number of columns in the matrix",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    packFormat: "u8"
  }, {
    kind: "const",
    name: "labels",
    identifier: 386,
    description: "The characters printed on the keys if any, in indexing sequence.",
    fields: [{
      name: "label",
      type: "string0",
      storage: 0,
      startRepeats: true
    }],
    optional: true,
    packFormat: "r: z"
  }, {
    kind: "const",
    name: "variant",
    identifier: 263,
    description: "The type of physical keypad. If the variant is ``ElastomerLEDPixel``\nand the next service on the device is a ``LEDPixel`` service, it is considered\nas the service controlling the LED pixel on the keypad.",
    fields: [{
      name: "_",
      type: "Variant",
      storage: 1
    }],
    optional: true,
    identifierName: "variant",
    packFormat: "u8"
  }, {
    kind: "event",
    name: "down",
    identifier: 1,
    description: "Emitted when a key, at the given index, goes from inactive (`pressed == 0`) to active.",
    fields: [{
      name: "_",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    identifierName: "active",
    packFormat: "u8"
  }, {
    kind: "event",
    name: "up",
    identifier: 2,
    description: "Emitted when a key, at the given index, goes from active (`pressed == 1`) to inactive.",
    fields: [{
      name: "_",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    identifierName: "inactive",
    packFormat: "u8"
  }, {
    kind: "event",
    name: "click",
    identifier: 128,
    description: "Emitted together with `up` when the press time was not longer than 500ms.",
    fields: [{
      name: "_",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    packFormat: "u8"
  }, {
    kind: "event",
    name: "long_click",
    identifier: 129,
    description: "Emitted together with `up` when the press time was more than 500ms.",
    fields: [{
      name: "_",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    packFormat: "u8"
  }],
  tags: [],
  group: "Button"
}, {
  name: "Microphone",
  status: "experimental",
  shortId: "microphone",
  camelName: "microphone",
  shortName: "microphone",
  "extends": ["_base"],
  notes: {
    short: "A single-channel microphone."
  },
  classIdentifier: 289254534,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "command",
    name: "sample",
    identifier: 129,
    description: "The samples will be streamed back over the `samples` pipe.\nIf `num_samples` is `0`, streaming will only stop when the pipe is closed.\nOtherwise the specified number of samples is streamed.\nSamples are sent as `i16`.",
    fields: [{
      name: "samples",
      type: "pipe",
      storage: 12
    }, {
      name: "num_samples",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    pipeType: "sample",
    packFormat: "b[12] u32"
  }, {
    kind: "rw",
    name: "sampling_period",
    identifier: 128,
    description: "Get or set microphone sampling period.\nSampling rate is `1_000_000 / sampling_period Hz`.",
    fields: [{
      name: "_",
      unit: "us",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    packFormat: "u32"
  }],
  tags: [],
  group: "Sound"
}, {
  name: "MIDI output",
  status: "experimental",
  shortId: "midioutput",
  camelName: "midiOutput",
  shortName: "midiOutput",
  "extends": ["_base"],
  notes: {
    short: "A MIDI output device."
  },
  classIdentifier: 444894423,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "enabled",
    identifier: 1,
    description: "Opens or closes the port to the MIDI device",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1
    }],
    identifierName: "intensity",
    packFormat: "u8"
  }, {
    kind: "command",
    name: "clear",
    identifier: 128,
    description: "Clears any pending send data that has not yet been sent from the MIDIOutput's queue.",
    fields: []
  }, {
    kind: "command",
    name: "send",
    identifier: 129,
    description: "Enqueues the message to be sent to the corresponding MIDI port",
    fields: [{
      name: "data",
      type: "bytes",
      storage: 0,
      isSimpleType: true
    }],
    packFormat: "b"
  }],
  tags: [],
  group: "Sound"
}, {
  name: "Model Runner",
  status: "experimental",
  shortId: "modelrunner",
  camelName: "modelRunner",
  shortName: "modelRunner",
  "extends": ["_base"],
  notes: {
    short: "Runs machine learning models.\n\nOnly models with a single input tensor and a single output tensor are supported at the moment.\nInput is provided by Sensor Aggregator service on the same device.\nMultiple instances of this service may be present, if more than one model format is supported by a device."
  },
  classIdentifier: 336566904,
  enums: {
    ModelFormat: {
      name: "ModelFormat",
      storage: 4,
      members: {
        TFLite: 860636756,
        ML4F: 809963362,
        EdgeImpulseCompiled: 810961221
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "command",
    name: "set_model",
    identifier: 128,
    description: "Open pipe for streaming in the model. The size of the model has to be declared upfront.\nThe model is streamed over regular pipe data packets.\nThe format supported by this instance of the service is specified in `format` register.\nWhen the pipe is closed, the model is written all into flash, and the device running the service may reset.",
    fields: [{
      name: "model_size",
      unit: "B",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    hasReport: true,
    packFormat: "u32"
  }, {
    kind: "report",
    name: "set_model",
    identifier: 128,
    description: "Open pipe for streaming in the model. The size of the model has to be declared upfront.\nThe model is streamed over regular pipe data packets.\nThe format supported by this instance of the service is specified in `format` register.\nWhen the pipe is closed, the model is written all into flash, and the device running the service may reset.",
    fields: [{
      name: "model_port",
      type: "pipe_port",
      storage: 2
    }],
    secondary: true,
    pipeType: "set_model",
    packFormat: "u16"
  }, {
    kind: "command",
    name: "predict",
    identifier: 129,
    description: "Open channel that can be used to manually invoke the model. When enough data is sent over the `inputs` pipe, the model is invoked,\nand results are send over the `outputs` pipe.",
    fields: [{
      name: "outputs",
      type: "pipe",
      storage: 12
    }],
    pipeType: "predict",
    hasReport: true,
    packFormat: "b[12]"
  }, {
    kind: "report",
    name: "predict",
    identifier: 129,
    description: "Open channel that can be used to manually invoke the model. When enough data is sent over the `inputs` pipe, the model is invoked,\nand results are send over the `outputs` pipe.",
    fields: [{
      name: "inputs",
      type: "pipe_port",
      storage: 2
    }],
    secondary: true,
    pipeType: "predict",
    packFormat: "u16"
  }, {
    kind: "rw",
    name: "auto_invoke_every",
    identifier: 128,
    description: "When register contains `N > 0`, run the model automatically every time new `N` samples are collected.\nModel may be run less often if it takes longer to run than `N * sampling_interval`.\nThe `outputs` register will stream its value after each run.\nThis register is not stored in flash.",
    fields: [{
      name: "_",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    packFormat: "u16"
  }, {
    kind: "ro",
    name: "outputs",
    identifier: 257,
    description: "Results of last model invocation as `float32` array.",
    fields: [{
      name: "output",
      isFloat: true,
      type: "f32",
      storage: 4,
      startRepeats: true
    }],
    volatile: true,
    identifierName: "reading",
    packFormat: "r: f32"
  }, {
    kind: "ro",
    name: "input_shape",
    identifier: 384,
    description: "The shape of the input tensor.",
    fields: [{
      name: "dimension",
      type: "u16",
      storage: 2,
      isSimpleType: true,
      startRepeats: true
    }],
    packFormat: "r: u16"
  }, {
    kind: "ro",
    name: "output_shape",
    identifier: 385,
    description: "The shape of the output tensor.",
    fields: [{
      name: "dimension",
      type: "u16",
      storage: 2,
      isSimpleType: true,
      startRepeats: true
    }],
    packFormat: "r: u16"
  }, {
    kind: "ro",
    name: "last_run_time",
    identifier: 386,
    description: "The time consumed in last model execution.",
    fields: [{
      name: "_",
      unit: "us",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    packFormat: "u32"
  }, {
    kind: "ro",
    name: "allocated_arena_size",
    identifier: 387,
    description: "Number of RAM bytes allocated for model execution.",
    fields: [{
      name: "_",
      unit: "B",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    packFormat: "u32"
  }, {
    kind: "ro",
    name: "model_size",
    identifier: 388,
    description: "The size of the model in bytes.",
    fields: [{
      name: "_",
      unit: "B",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    packFormat: "u32"
  }, {
    kind: "ro",
    name: "last_error",
    identifier: 389,
    description: "Textual description of last error when running or loading model (if any).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    packFormat: "s"
  }, {
    kind: "const",
    name: "format",
    identifier: 390,
    description: "The type of ML models supported by this service.\n`TFLite` is flatbuffer `.tflite` file.\n`ML4F` is compiled machine code model for Cortex-M4F.\nThe format is typically present as first or second little endian word of model file.",
    fields: [{
      name: "_",
      type: "ModelFormat",
      storage: 4
    }],
    packFormat: "u32"
  }, {
    kind: "const",
    name: "format_version",
    identifier: 391,
    description: "A version number for the format.",
    fields: [{
      name: "_",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    packFormat: "u32"
  }, {
    kind: "const",
    name: "parallel",
    identifier: 392,
    description: "If present and true this service can run models independently of other\ninstances of this service on the device.",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1
    }],
    optional: true,
    packFormat: "u8"
  }],
  tags: []
}, {
  name: "Motion",
  status: "experimental",
  shortId: "motion",
  camelName: "motion",
  shortName: "motion",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "A sensor, typically PIR, that detects object motion within a certain range"
  },
  classIdentifier: 293185353,
  enums: {
    Variant: {
      name: "Variant",
      storage: 1,
      members: {
        PIR: 1
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "moving",
    identifier: 257,
    description: "Reports is movement is currently detected by the sensor.",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1
    }],
    volatile: true,
    identifierName: "reading",
    preferredInterval: 1000,
    packFormat: "u8"
  }, {
    kind: "const",
    name: "max_distance",
    identifier: 384,
    description: "Maximum distance where objects can be detected.",
    fields: [{
      name: "_",
      unit: "m",
      shift: 16,
      type: "u16.16",
      storage: 4
    }],
    optional: true,
    packFormat: "u16.16"
  }, {
    kind: "const",
    name: "angle",
    identifier: 385,
    description: "Opening of the field of view",
    fields: [{
      name: "_",
      unit: "°",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    packFormat: "u16"
  }, {
    kind: "const",
    name: "variant",
    identifier: 263,
    description: "Type of physical sensor",
    fields: [{
      name: "_",
      type: "Variant",
      storage: 1
    }],
    optional: true,
    identifierName: "variant",
    packFormat: "u8"
  }, {
    kind: "event",
    name: "movement",
    identifier: 1,
    description: "A movement was detected.",
    fields: [],
    identifierName: "active"
  }],
  tags: ["8bit"],
  group: "Movement"
}, {
  name: "Motor",
  status: "experimental",
  shortId: "motor",
  camelName: "motor",
  shortName: "motor",
  "extends": ["_base"],
  notes: {
    short: "A bi-directional DC motor."
  },
  classIdentifier: 385895640,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "duty",
    identifier: 2,
    description: "PWM duty cycle of the motor. Use negative/positive values to run the motor forwards and backwards.\nPositive is recommended to be clockwise rotation and negative counterclockwise. A duty of ``0`` \nwhile ``enabled`` acts as brake.",
    fields: [{
      name: "_",
      unit: "/",
      shift: 15,
      type: "i1.15",
      storage: -2
    }],
    identifierName: "value",
    packFormat: "i1.15"
  }, {
    kind: "rw",
    name: "enabled",
    identifier: 1,
    description: "Turn the power to the motor on/off.",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1
    }],
    identifierName: "intensity",
    packFormat: "u8"
  }, {
    kind: "const",
    name: "load_torque",
    identifier: 384,
    description: "Torque required to produce the rated power of an electrical motor at load speed.",
    fields: [{
      name: "_",
      unit: "kg/cm",
      shift: 16,
      type: "u16.16",
      storage: 4
    }],
    optional: true,
    packFormat: "u16.16"
  }, {
    kind: "const",
    name: "load_speed",
    identifier: 385,
    description: "Revolutions per minute of the motor under full load.",
    fields: [{
      name: "_",
      unit: "rpm",
      shift: 16,
      type: "u16.16",
      storage: 4
    }],
    optional: true,
    packFormat: "u16.16"
  }],
  tags: ["C", "8bit"]
}, {
  name: "Multitouch",
  status: "experimental",
  shortId: "multitouch",
  camelName: "multitouch",
  shortName: "multitouch",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "A capacitive touch sensor with multiple inputs.",
    events: "Most events include the channel number of the input."
  },
  classIdentifier: 416636459,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "capacity",
    identifier: 257,
    description: "Capacitance of channels. The capacitance is continuously calibrated, and a value of `0` indicates\nno touch, wheres a value of around `100` or more indicates touch.\nIt's best to ignore this (unless debugging), and use events.",
    fields: [{
      name: "capacitance",
      type: "i32",
      storage: -4,
      isSimpleType: true,
      startRepeats: true
    }],
    volatile: true,
    identifierName: "reading",
    packFormat: "r: i32"
  }, {
    kind: "event",
    name: "touch",
    identifier: 1,
    description: "Emitted when an input is touched.",
    fields: [{
      name: "channel",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    identifierName: "active",
    packFormat: "u32"
  }, {
    kind: "event",
    name: "release",
    identifier: 2,
    description: "Emitted when an input is no longer touched.",
    fields: [{
      name: "channel",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    identifierName: "inactive",
    packFormat: "u32"
  }, {
    kind: "event",
    name: "tap",
    identifier: 128,
    description: "Emitted when an input is briefly touched. TODO Not implemented.",
    fields: [{
      name: "channel",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    packFormat: "u32"
  }, {
    kind: "event",
    name: "long_press",
    identifier: 129,
    description: "Emitted when an input is touched for longer than 500ms. TODO Not implemented.",
    fields: [{
      name: "channel",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    packFormat: "u32"
  }, {
    kind: "event",
    name: "swipe_pos",
    identifier: 144,
    description: "Emitted when input channels are successively touched in order of increasing channel numbers.",
    fields: []
  }, {
    kind: "event",
    name: "swipe_neg",
    identifier: 145,
    description: "Emitted when input channels are successively touched in order of decreasing channel numbers.",
    fields: []
  }],
  tags: [],
  group: "Button"
}, {
  name: "Potentiometer",
  status: "experimental",
  shortId: "potentiometer",
  camelName: "potentiometer",
  shortName: "potentiometer",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "A slider or rotary potentiometer."
  },
  classIdentifier: 522667846,
  enums: {
    Variant: {
      name: "Variant",
      storage: 1,
      members: {
        Slider: 1,
        Rotary: 2
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "position",
    identifier: 257,
    description: "The relative position of the slider.",
    fields: [{
      name: "_",
      unit: "/",
      shift: 16,
      type: "u0.16",
      storage: 2
    }],
    volatile: true,
    identifierName: "reading",
    packFormat: "u0.16"
  }, {
    kind: "const",
    name: "variant",
    identifier: 263,
    description: "Specifies the physical layout of the potentiometer.",
    fields: [{
      name: "_",
      type: "Variant",
      storage: 1
    }],
    optional: true,
    identifierName: "variant",
    packFormat: "u8"
  }],
  tags: ["C", "8bit"],
  group: "Slider"
}, {
  name: "Power",
  status: "experimental",
  shortId: "power",
  camelName: "power",
  shortName: "power",
  "extends": ["_base"],
  notes: {
    short: "A power-provider service.",
    long: "## Power negotiation protocol\n\nThe purpose of the power negotiation is to ensure that there is no more than ~900mA\ndelivered to the power rail.\nThis is realized by limiting the number of enabled power provider services to one.\n\nNote, that it's also possible to have low-current power providers,\nwhich are limited to 100mA and do not run a power provider service.\nThese are **not** accounted for in the power negotiation protocol.\n\nPower providers can have multiple _channels_, typically multiple Jacdac ports on the provider.\nEach channel can be limited to 900mA separately.\nIn normal operation, the data lines of each channels are connected together.\nThe ground lines are always connected together.\nMulti-channel power providers are also called _powered hubs_.\n\nWhile channels have separate current limits, there's nothing to prevent the user\nfrom joining two or more channels outside of the provider using a passive hub.\nThis would allow more than 900mA of current to be drawn, resulting in cables or components\ngetting hot and/or malfunctioning.\nThus, the power negotiation protocol seeks to detect situations where\nmultiple channels of power provider(s) are bridged together\nand shut down all but one of the channels involved.\n\nThe protocol is built around the power providers periodically sending specially crafted\n`shutdown` commands in broadcast mode.\nNote that this is unusual - services typically only send reports.\n\nThe `shutdown` commands can be reliably identified based on their first half (more details below).\nWhen a power provider starts receiving a `shutdown` command, it needs to take\nsteps to identify which of its channels the command is coming from.\nThis is typically realized with analog switches between data lines of channels.\nThe channel which received the `shutdown` command is then shut down.\nNote that in the case a single-channel provider any received `shutdown` command will cause a shut down.\n\nA multi-channel provider needs to also identify when a `shutdown` command it sent from one channel\nis received on any of its other channels and shut down one of the involved channels.\n\nIt is also possible to build a _data bridge_ device, with two or more ports.\nIt passes through all data except for `shutdown` commands,\nbut **does not** connect the power lines.\n\n### Protocol details\n\nThe `shutdown` commands follow a very narrow format:\n* they need to be the only packet in the frame (and thus we can also call them `shutdown` frames)\n* the second word of `device_id` needs to be set to `0xAA_AA_AA_AA` (alternating 0 and 1)\n* the service index is set to `0x3d`\n* the CRC is therefore fixed\n* therefore, the packet can be recognized by reading the first 8 bytes (total length is 16 bytes)\n\nThe exact byte structure of `shutdown` command is:\n`15 59 04 05 5A C9 A4 1F AA AA AA AA 00 3D 80 00`\n\nThere is one power service per channel.\nA multi-channel power provider can be implemented as one device with multiple services (typically with one MCU),\nor many devices with one service each (typically multiple MCUs).\nThe first option is preferred as it fixes the order of channels,\nbut the second option may be cheaper to implement.\n\nAfter queuing a `shutdown` command, the service enters a grace period\nuntil the report has been sent on the wire.\nDuring the grace period incoming `shutdown` commands are ignored.\n\n* Upon reset, a power service enables itself, and then only after 0-300ms (random)\n  sends the first `shutdown` command\n* Every enabled power service emits `shutdown` commands every 400-600ms (random; first few packets can be even sent more often)\n* If an enabled power service sees a `shutdown` command from somebody else,\n  it disables itself (unless in grace period)\n* If a disabled power service sees no `shutdown` command for more than ~1200ms, it enables itself\n  (this is when the previous power source is unplugged or otherwise malfunctions)\n* If a power service has been disabled for around 10s, it enables itself.\n\nAdditionally:\n* While the `allowed` register is set to `0`, the service will not enable itself (nor send `shutdown` commands)\n* When a current overdraw is detected, the service stop providing power and enters `Overload` state for around 2 seconds,\n  while still sending `shutdown` commands.\n\n### Client notes\n\nIf a client hears a `shutdown` command it just means it's on a branch of the\nnetwork with a (high) power provider.\nAs clients (brains) typically do not consume much current (as opposed to, say, servos),\nthe `shutdown` commands are typically irrelevant to them.\n\nFor power monitoring, the `power_status_changed` event (and possibly `power_status` register)\ncan be used.\nIn particular, user interfaces may alert the user to `Overload` status.\nThe `Overprovision` status is generally considered normal (eg. when two multi-channel power providers are linked together).\n\n### Server implementation notes\n\n#### An MCU per channel\n\nEvery channel has:\n* a cheap 8-bit MCU (eg., PMS150C)\n* a current limiter with latching circuit\n* an analog switch\n\nThe MCU is connected to data line of the channel.\nThe switch joins the data line of the channel with internal data bus, common to all channels.\nBoth the switch and the limiter are controlled by the MCU.\nThe latching circuit on the limiter shuts it down immediately on current overdraw.\n\nDuring reception, after the beginning of `shutdown` frame is detected,\nthe switch is opened for a brief period.\nIf the `shutdown` frame is received correctly, it means it was on MCU's channel.\n\n#### A dedicated MCU for multiple channels\n\nEvery channel has:\n* a current limiter with latching circuit\n* an analog switch\n* a wiggle-detection line connecting the MCU to data line of the channel\n\nThe MCU here needs at least 4 pins per channel.\nSwitches and limiters are set up like in the configuration above.\nThe Jacdac data line of the MCU is connected to internal data bus.\n\nWhile a Jacdac packet is being received, the MCU keeps checking if it is a \nbeginning of the `shutdown` frame.\nIf that is the case, it opens all switches and checks which one(s) of the channel\ndata lines wiggle (via the wiggle lines; this can be done with EXTI latches).\nThe one(s) that wiggle received the `shutdown` frame and need to be disabled.\n\nAlso, while sending the `shutdown` frames itself, it needs to be done separately\nfor each channel, with all the other switches open.\nIf during that operation we detect wiggle on other channels, then we have detected\na loop, and the respective channels needs to be disabled.\n\n#### A brain-integrated power supply\n\nHere, there's only one channel of power and we don't have hard real time requirements,\nso user-programmable brain can control it.\nThere is no need for analog switch or wiggle-detection line,\nbut the current limiter with latching circuit is still needed.\n\nThere is nothing special to do during reception of `shutdown` packet.\nWhen it is received, the current limiter should just be disabled.\n\nIdeally, exception/hard-fault handlers on the MCU should also disable the\ncurrent limiter.\nSimilarly, the limiter should be disabled while the MCU is in bootloader mode,\nor otherwise unaware of the power negotiation protocol. \n\n### Rationale for the grace period\n\nConsider the following scenario:\n\n* device A queues `shutdown` command for sending\n* A receives external `shutdown` packet from B (thus disabling A)\n* the A `shutdown` command is sent from the queue (thus eventually disabling B)\n\nTo avoid that, we make sure that at the precise instant when `shutdown` command is sent,\nthe power is enabled (and thus will stay enabled until another `shutdown` command arrives).\nThis could be achieved by inspecting the enable bit, aftering acquiring the line\nand before starting UART transmission, however that would require breaking abstraction layers.\nSo instead, we never disable the service, while the `shutdown` packet is queued.\nThis may lead to delays in disabling power services, but these should be limited due to the\nrandom nature of the `shutdown` packet spacing.\n\n### Rationale for timings\n\nThe initial 0-300ms delay is set to spread out the `shutdown` periods of power services,\nto minimize collisions.\nThe `shutdown` periods are randomized 400-600ms, instead of a fixed 500ms used for regular\nservices, for the same reason.\n\nThe 1200ms period is set so that droping two `shutdown` packets in a row\nfrom the current provider will not cause power switch, while missing 3 will.\n\nThe 50-60s power switch period is arbitrary, but chosen to limit amount of switching between supplies,\nwhile keeping it short enough for user to notice any problems such switching may cause."
  },
  classIdentifier: 530893146,
  enums: {
    PowerStatus: {
      name: "PowerStatus",
      storage: 1,
      members: {
        Disallowed: 0,
        Powering: 1,
        Overload: 2,
        Overprovision: 3
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "allowed",
    identifier: 1,
    description: "Can be used to completely disable the service.\nWhen allowed, the service may still not be providing power, see \n`power_status` for the actual current state.",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1,
      defaultValue: 1
    }],
    identifierName: "intensity",
    packFormat: "u8"
  }, {
    kind: "rw",
    name: "max_power",
    identifier: 7,
    description: "Limit the power provided by the service. The actual maximum limit will depend on hardware.\nThis field may be read-only in some implementations - you should read it back after setting.",
    fields: [{
      name: "_",
      unit: "mA",
      type: "u16",
      storage: 2,
      isSimpleType: true,
      defaultValue: 900,
      typicalMax: 900,
      typicalMin: 0
    }],
    optional: true,
    identifierName: "max_power",
    packFormat: "u16"
  }, {
    kind: "ro",
    name: "power_status",
    identifier: 385,
    description: "Indicates whether the power provider is currently providing power (`Powering` state), and if not, why not.\n`Overprovision` means there was another power provider, and we stopped not to overprovision the bus.",
    fields: [{
      name: "_",
      type: "PowerStatus",
      storage: 1
    }],
    volatile: true,
    packFormat: "u8"
  }, {
    kind: "ro",
    name: "current_draw",
    identifier: 257,
    description: "Present current draw from the bus.",
    fields: [{
      name: "_",
      unit: "mA",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    volatile: true,
    optional: true,
    identifierName: "reading",
    packFormat: "u16"
  }, {
    kind: "ro",
    name: "battery_voltage",
    identifier: 384,
    description: "Voltage on input.",
    fields: [{
      name: "_",
      unit: "mV",
      type: "u16",
      storage: 2,
      isSimpleType: true,
      typicalMin: 4500,
      typicalMax: 5500
    }],
    volatile: true,
    optional: true,
    packFormat: "u16"
  }, {
    kind: "ro",
    name: "battery_charge",
    identifier: 386,
    description: "Fraction of charge in the battery.",
    fields: [{
      name: "_",
      unit: "/",
      shift: 16,
      type: "u0.16",
      storage: 2
    }],
    volatile: true,
    optional: true,
    packFormat: "u0.16"
  }, {
    kind: "const",
    name: "battery_capacity",
    identifier: 387,
    description: "Energy that can be delivered to the bus when battery is fully charged.\nThis excludes conversion overheads if any.",
    fields: [{
      name: "_",
      unit: "mWh",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    optional: true,
    packFormat: "u32"
  }, {
    kind: "rw",
    name: "keep_on_pulse_duration",
    identifier: 128,
    description: "Many USB power packs need current to be drawn from time to time to prevent shutdown.\nThis regulates how often and for how long such current is drawn.\nTypically a 1/8W 22 ohm resistor is used as load. This limits the duty cycle to 10%.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u16",
      storage: 2,
      isSimpleType: true,
      defaultValue: 600
    }],
    optional: true,
    packFormat: "u16"
  }, {
    kind: "rw",
    name: "keep_on_pulse_period",
    identifier: 129,
    description: "Many USB power packs need current to be drawn from time to time to prevent shutdown.\nThis regulates how often and for how long such current is drawn.\nTypically a 1/8W 22 ohm resistor is used as load. This limits the duty cycle to 10%.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u16",
      storage: 2,
      isSimpleType: true,
      defaultValue: 20000
    }],
    optional: true,
    packFormat: "u16"
  }, {
    kind: "command",
    name: "shutdown",
    identifier: 128,
    description: "Sent by the power service periodically, as broadcast.",
    fields: []
  }, {
    kind: "event",
    name: "power_status_changed",
    identifier: 3,
    description: "Emitted whenever `power_status` changes.",
    fields: [{
      name: "power_status",
      type: "PowerStatus",
      storage: 1
    }],
    identifierName: "change",
    packFormat: "u8"
  }],
  tags: []
}, {
  name: "Pressure Button",
  status: "experimental",
  shortId: "pressurebutton",
  camelName: "pressureButton",
  shortName: "pressureButton",
  "extends": ["_base"],
  notes: {
    short: "A pressure sensitive push-button."
  },
  classIdentifier: 672612547,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "threshold",
    identifier: 6,
    description: "Indicates the threshold for ``up`` events.",
    fields: [{
      name: "_",
      unit: "/",
      shift: 16,
      type: "u0.16",
      storage: 2
    }],
    identifierName: "active_threshold",
    packFormat: "u0.16"
  }],
  tags: ["8bit"],
  group: "Button"
}, {
  name: "Protocol Test",
  status: "experimental",
  shortId: "prototest",
  camelName: "protoTest",
  shortName: "protoTest",
  "extends": ["_base"],
  notes: {
    short: "This is test service to validate the protocol packet transmissions between the browser and a MCU.\nUse this page if you are porting Jacdac to a new platform.",
    long: "### Test procedure\n\nFor each ``rw`` registers, set a random value ``x``\n  * read ``rw`` and check value is equal to ``x``\n  * read ``ro`` and check value is equal to ``x``\n  * listen to ``e`` event and check that data is equal to ``x``\n  * call ``c`` command with new random value ``y``\n  * read ``rw`` and check value is equal to ``y``\n  * do all the above steps with acks\n\nFor each ``rw`` registers, there shall also\nbe an ``event`` and a ``command``. The event\nshould get raised when the value changes;\nand the command should set the value.",
    registers: "Every ``rw`` register has a corresponding ``ro`` regisrer\nand a corresponding ``set_...`` command to also set the value."
  },
  classIdentifier: 382158442,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "rw_bool",
    identifier: 129,
    description: "A read write bool register.",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1
    }],
    packFormat: "u8"
  }, {
    kind: "ro",
    name: "ro_bool",
    identifier: 385,
    description: "A read only bool register. Mirrors rw_bool.",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1
    }],
    packFormat: "u8"
  }, {
    kind: "rw",
    name: "rw_u32",
    identifier: 130,
    description: "A read write u32 register.",
    fields: [{
      name: "_",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    packFormat: "u32"
  }, {
    kind: "ro",
    name: "ro_u32",
    identifier: 386,
    description: "A read only u32 register.. Mirrors rw_u32.",
    fields: [{
      name: "_",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    packFormat: "u32"
  }, {
    kind: "rw",
    name: "rw_i32",
    identifier: 131,
    description: "A read write i32 register.",
    fields: [{
      name: "_",
      type: "i32",
      storage: -4,
      isSimpleType: true
    }],
    packFormat: "i32"
  }, {
    kind: "ro",
    name: "ro_i32",
    identifier: 387,
    description: "A read only i32 register.. Mirrors rw_i32.",
    fields: [{
      name: "_",
      type: "i32",
      storage: -4,
      isSimpleType: true
    }],
    packFormat: "i32"
  }, {
    kind: "rw",
    name: "rw_string",
    identifier: 132,
    description: "A read write string register.",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    packFormat: "s"
  }, {
    kind: "ro",
    name: "ro_string",
    identifier: 388,
    description: "A read only string register. Mirrors rw_string.",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    packFormat: "s"
  }, {
    kind: "rw",
    name: "rw_bytes",
    identifier: 133,
    description: "A read write string register.",
    fields: [{
      name: "_",
      type: "bytes",
      storage: 0,
      isSimpleType: true
    }],
    packFormat: "b"
  }, {
    kind: "ro",
    name: "ro_bytes",
    identifier: 389,
    description: "A read only string register. Mirrors ro_bytes.",
    fields: [{
      name: "_",
      type: "bytes",
      storage: 0,
      isSimpleType: true
    }],
    packFormat: "b"
  }, {
    kind: "rw",
    name: "rw_i8_u8_u16_i32",
    identifier: 134,
    description: "A read write i8, u8, u16, i32 register.",
    fields: [{
      name: "i8",
      type: "i8",
      storage: -1,
      isSimpleType: true
    }, {
      name: "u8",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "u16",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "i32",
      type: "i32",
      storage: -4,
      isSimpleType: true
    }],
    packFormat: "i8 u8 u16 i32"
  }, {
    kind: "ro",
    name: "ro_i8_u8_u16_i32",
    identifier: 390,
    description: "A read only i8, u8, u16, i32 register.. Mirrors rw_i8_u8_u16_i32.",
    fields: [{
      name: "i8",
      type: "i8",
      storage: -1,
      isSimpleType: true
    }, {
      name: "u8",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "u16",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "i32",
      type: "i32",
      storage: -4,
      isSimpleType: true
    }],
    packFormat: "i8 u8 u16 i32"
  }, {
    kind: "rw",
    name: "rw_u8_string",
    identifier: 135,
    description: "A read write u8, string register.",
    fields: [{
      name: "u8",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "string",
      type: "string",
      storage: 0
    }],
    packFormat: "u8 s"
  }, {
    kind: "ro",
    name: "ro_u8_string",
    identifier: 391,
    description: "A read only u8, string register.. Mirrors rw_u8_string.",
    fields: [{
      name: "u8",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "string",
      type: "string",
      storage: 0
    }],
    packFormat: "u8 s"
  }, {
    kind: "event",
    name: "e_bool",
    identifier: 129,
    description: "An event raised when rw_bool is modified",
    fields: [{
      name: "bool",
      type: "bool",
      storage: 1
    }],
    packFormat: "u8"
  }, {
    kind: "event",
    name: "e_u32",
    identifier: 130,
    description: "An event raised when rw_u32 is modified",
    fields: [{
      name: "u32",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    packFormat: "u32"
  }, {
    kind: "event",
    name: "e_i32",
    identifier: 131,
    description: "An event raised when rw_i32 is modified",
    fields: [{
      name: "i32",
      type: "i32",
      storage: -4,
      isSimpleType: true
    }],
    packFormat: "i32"
  }, {
    kind: "event",
    name: "e_string",
    identifier: 132,
    description: "An event raised when rw_string is modified",
    fields: [{
      name: "string",
      type: "string",
      storage: 0
    }],
    packFormat: "s"
  }, {
    kind: "event",
    name: "e_bytes",
    identifier: 133,
    description: "An event raised when rw_bytes is modified",
    fields: [{
      name: "bytes",
      type: "bytes",
      storage: 0,
      isSimpleType: true
    }],
    packFormat: "b"
  }, {
    kind: "event",
    name: "e_i8_u8_u16_i32",
    identifier: 134,
    description: "An event raised when rw_i8_u8_u16_i32 is modified",
    fields: [{
      name: "i8",
      type: "i8",
      storage: -1,
      isSimpleType: true
    }, {
      name: "u8",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "u16",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "i32",
      type: "i32",
      storage: -4,
      isSimpleType: true
    }],
    packFormat: "i8 u8 u16 i32"
  }, {
    kind: "event",
    name: "e_u8_string",
    identifier: 135,
    description: "An event raised when rw_u8_string is modified",
    fields: [{
      name: "u8",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "string",
      type: "string",
      storage: 0
    }],
    packFormat: "u8 s"
  }, {
    kind: "command",
    name: "c_bool",
    identifier: 129,
    description: "A command to set rw_bool.",
    fields: [{
      name: "bool",
      type: "bool",
      storage: 1
    }],
    packFormat: "u8"
  }, {
    kind: "command",
    name: "c_u32",
    identifier: 130,
    description: "A command to set rw_u32.",
    fields: [{
      name: "u32",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    packFormat: "u32"
  }, {
    kind: "command",
    name: "c_i32",
    identifier: 131,
    description: "A command to set rw_i32.",
    fields: [{
      name: "i32",
      type: "i32",
      storage: -4,
      isSimpleType: true
    }],
    packFormat: "i32"
  }, {
    kind: "command",
    name: "c_string",
    identifier: 132,
    description: "A command to set rw_string.",
    fields: [{
      name: "string",
      type: "string",
      storage: 0
    }],
    packFormat: "s"
  }, {
    kind: "command",
    name: "c_bytes",
    identifier: 133,
    description: "A command to set rw_string.",
    fields: [{
      name: "bytes",
      type: "bytes",
      storage: 0,
      isSimpleType: true
    }],
    packFormat: "b"
  }, {
    kind: "command",
    name: "c_i8_u8_u16_i32",
    identifier: 134,
    description: "A command to set rw_bytes.",
    fields: [{
      name: "i8",
      type: "i8",
      storage: -1,
      isSimpleType: true
    }, {
      name: "u8",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "u16",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "i32",
      type: "i32",
      storage: -4,
      isSimpleType: true
    }],
    packFormat: "i8 u8 u16 i32"
  }, {
    kind: "command",
    name: "c_u8_string",
    identifier: 135,
    description: "A command to set rw_u8_string.",
    fields: [{
      name: "u8",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "string",
      type: "string",
      storage: 0
    }],
    packFormat: "u8 s"
  }, {
    kind: "command",
    name: "c_report_pipe",
    identifier: 144,
    description: "A command to read the content of rw_bytes, byte per byte, as a pipe.",
    fields: [{
      name: "p_bytes",
      type: "pipe",
      storage: 12
    }],
    pipeType: "c_report_pipe",
    packFormat: "b[12]"
  }, {
    kind: "pipe_report",
    name: "p_bytes",
    identifier: 0,
    description: "A command to read the content of rw_bytes, byte per byte, as a pipe.",
    fields: [{
      name: "byte",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    pipeType: "c_report_pipe",
    packFormat: "u8"
  }],
  tags: []
}, {
  name: "Pulse Oximeter",
  status: "experimental",
  shortId: "pulseoximeter",
  camelName: "pulseOximeter",
  shortName: "pulseOximeter",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "A sensor approximating the oxygen level. \n\n**Jacdac is not suitable for medical devices and should NOT be used in any kind of device to diagnose or treat any medical conditions.**"
  },
  classIdentifier: 280710838,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "oxygen",
    identifier: 257,
    description: "The estimated oxygen level in blood.",
    fields: [{
      name: "_",
      unit: "%",
      shift: 8,
      type: "u8.8",
      storage: 2,
      typicalMin: 80,
      typicalMax: 100
    }],
    volatile: true,
    identifierName: "reading",
    packFormat: "u8.8"
  }, {
    kind: "ro",
    name: "oxygen_error",
    identifier: 262,
    description: "The estimated error on the reported sensor data.",
    fields: [{
      name: "_",
      unit: "%",
      shift: 8,
      type: "u8.8",
      storage: 2
    }],
    volatile: true,
    optional: true,
    identifierName: "reading_error",
    packFormat: "u8.8"
  }],
  tags: ["8bit"],
  group: "Biometric"
}, {
  name: "Rain gauge",
  status: "experimental",
  shortId: "raingauge",
  camelName: "rainGauge",
  shortName: "rainGauge",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "Measures the amount of liquid precipitation over an area in a predefined period of time."
  },
  classIdentifier: 326323349,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "precipitation",
    identifier: 257,
    description: "Total precipitation recorded so far.",
    fields: [{
      name: "_",
      unit: "mm",
      shift: 16,
      type: "u16.16",
      storage: 4
    }],
    volatile: true,
    identifierName: "reading",
    preferredInterval: 60000,
    packFormat: "u16.16"
  }, {
    kind: "const",
    name: "precipitation_precision",
    identifier: 264,
    description: "Typically the amount of rain needed for tipping the bucket.",
    fields: [{
      name: "_",
      unit: "mm",
      shift: 16,
      type: "u16.16",
      storage: 4
    }],
    optional: true,
    identifierName: "reading_resolution",
    packFormat: "u16.16"
  }],
  tags: ["8bit"],
  group: "Environment"
}, {
  name: "Real time clock",
  status: "experimental",
  shortId: "realtimeclock",
  camelName: "realTimeClock",
  shortName: "realTimeClock",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "Real time clock to support collecting data with precise time stamps."
  },
  classIdentifier: 445323816,
  enums: {
    Variant: {
      name: "Variant",
      storage: 1,
      members: {
        Computer: 1,
        Crystal: 2,
        Cuckoo: 3
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "local_time",
    identifier: 257,
    description: "Current time in 24h representation. \n* ``day_of_month`` is day of the month, starting at ``1``\n* ``day_of_week`` is day of the week, starting at ``1`` as monday\nDefault streaming period is 1 second.",
    fields: [{
      name: "year",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "month",
      type: "u8",
      storage: 1,
      isSimpleType: true,
      absoluteMin: 1,
      absoluteMax: 12
    }, {
      name: "day_of_month",
      type: "u8",
      storage: 1,
      isSimpleType: true,
      absoluteMin: 1,
      absoluteMax: 31
    }, {
      name: "day_of_week",
      type: "u8",
      storage: 1,
      isSimpleType: true,
      absoluteMin: 1,
      absoluteMax: 7
    }, {
      name: "hour",
      type: "u8",
      storage: 1,
      isSimpleType: true,
      absoluteMin: 0,
      absoluteMax: 23
    }, {
      name: "min",
      type: "u8",
      storage: 1,
      isSimpleType: true,
      absoluteMin: 0,
      absoluteMax: 59
    }, {
      name: "sec",
      type: "u8",
      storage: 1,
      isSimpleType: true,
      absoluteMin: 0,
      absoluteMax: 60
    }],
    volatile: true,
    identifierName: "reading",
    preferredInterval: 1000,
    packFormat: "u16 u8 u8 u8 u8 u8 u8"
  }, {
    kind: "ro",
    name: "error",
    identifier: 384,
    description: "Time drift since the last call to the ``set_time`` command.",
    fields: [{
      name: "_",
      unit: "s",
      shift: 16,
      type: "u16.16",
      storage: 4
    }],
    volatile: true,
    optional: true,
    packFormat: "u16.16"
  }, {
    kind: "const",
    name: "precision",
    identifier: 385,
    description: "Error on the clock, in parts per million of seconds.",
    fields: [{
      name: "_",
      unit: "ppm",
      shift: 16,
      type: "u16.16",
      storage: 4
    }],
    optional: true,
    packFormat: "u16.16"
  }, {
    kind: "const",
    name: "variant",
    identifier: 263,
    description: "The type of physical clock used by the sensor.",
    fields: [{
      name: "_",
      type: "Variant",
      storage: 1
    }],
    optional: true,
    identifierName: "variant",
    packFormat: "u8"
  }, {
    kind: "command",
    name: "set_time",
    identifier: 128,
    description: "Sets the current time and resets the error.",
    fields: [{
      name: "year",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "month",
      type: "u8",
      storage: 1,
      isSimpleType: true,
      absoluteMin: 1,
      absoluteMax: 12
    }, {
      name: "day_of_month",
      type: "u8",
      storage: 1,
      isSimpleType: true,
      absoluteMin: 1,
      absoluteMax: 31
    }, {
      name: "day_of_week",
      type: "u8",
      storage: 1,
      isSimpleType: true,
      absoluteMin: 1,
      absoluteMax: 7
    }, {
      name: "hour",
      type: "u8",
      storage: 1,
      isSimpleType: true,
      absoluteMin: 0,
      absoluteMax: 23
    }, {
      name: "min",
      type: "u8",
      storage: 1,
      isSimpleType: true,
      absoluteMin: 0,
      absoluteMax: 59
    }, {
      name: "sec",
      type: "u8",
      storage: 1,
      isSimpleType: true,
      absoluteMin: 0,
      absoluteMax: 60
    }],
    packFormat: "u16 u8 u8 u8 u8 u8 u8"
  }],
  tags: ["8bit"]
}, {
  name: "Reflected light",
  status: "experimental",
  shortId: "reflectedlight",
  camelName: "reflectedLight",
  shortName: "reflectedLight",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "A sensor that detects light and dark surfaces, commonly used for line following robots."
  },
  classIdentifier: 309087410,
  enums: {
    Variant: {
      name: "Variant",
      storage: 1,
      members: {
        InfraredDigital: 1,
        InfraredAnalog: 2
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "brightness",
    identifier: 257,
    description: "Reports the reflected brightness. It may be a digital value or, for some sensor, analog value.",
    fields: [{
      name: "_",
      unit: "/",
      shift: 16,
      type: "u0.16",
      storage: 2
    }],
    volatile: true,
    identifierName: "reading",
    packFormat: "u0.16"
  }, {
    kind: "const",
    name: "variant",
    identifier: 263,
    description: "Type of physical sensor used",
    fields: [{
      name: "_",
      type: "Variant",
      storage: 1
    }],
    optional: true,
    identifierName: "variant",
    packFormat: "u8"
  }, {
    kind: "event",
    name: "dark",
    identifier: 2,
    description: "The sensor detected a transition from light to dark",
    fields: [],
    identifierName: "inactive"
  }, {
    kind: "event",
    name: "light",
    identifier: 1,
    description: "The sensor detected a transition from dark to light",
    fields: [],
    identifierName: "active"
  }],
  tags: ["8bit"],
  group: "Imaging"
}, {
  name: "Relay",
  status: "experimental",
  shortId: "relay",
  camelName: "relay",
  shortName: "relay",
  "extends": ["_base"],
  notes: {
    short: "A switching relay."
  },
  classIdentifier: 406840918,
  enums: {
    Variant: {
      name: "Variant",
      storage: 1,
      members: {
        Electromechanical: 1,
        SolidState: 2,
        Reed: 3
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "closed",
    identifier: 1,
    description: "Indicates whether the relay circuit is currently energized (closed) or not.",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1
    }],
    identifierName: "intensity",
    packFormat: "u8"
  }, {
    kind: "const",
    name: "variant",
    identifier: 263,
    description: "Describes the type of relay used.",
    fields: [{
      name: "_",
      type: "Variant",
      storage: 1
    }],
    optional: true,
    identifierName: "variant",
    packFormat: "u8"
  }, {
    kind: "const",
    name: "max_switching_current",
    identifier: 384,
    description: "Maximum switching current for a resistive load.",
    fields: [{
      name: "_",
      unit: "mA",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    optional: true,
    packFormat: "u32"
  }, {
    kind: "event",
    name: "active",
    identifier: 1,
    description: "Emitted when relay goes from `inactive` to `active` state.\nNormally open (NO) relays close the circuit when activated.",
    fields: [],
    identifierName: "active"
  }, {
    kind: "event",
    name: "inactive",
    identifier: 2,
    description: "Emitted when relay goes from `active` to `inactive` state.\nNormally closed (NC) relays open the circuit when activated.",
    fields: [],
    identifierName: "inactive"
  }],
  tags: ["8bit"]
}, {
  name: "Random Number Generator",
  status: "experimental",
  shortId: "rng",
  camelName: "rng",
  shortName: "rng",
  "extends": ["_base"],
  notes: {
    short: "Generates random numbers using entropy sourced from physical processes.\n\nThis typically uses a cryptographical pseudo-random number generator (for example [Fortuna](https://en.wikipedia.org/wiki/Fortuna_(PRNG))),\nwhich is periodically re-seeded with entropy coming from some hardware source."
  },
  classIdentifier: 394916002,
  enums: {
    Variant: {
      name: "Variant",
      storage: 1,
      members: {
        Quantum: 1,
        ADCNoise: 2,
        WebCrypto: 3
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "ro",
    name: "random",
    identifier: 384,
    description: "A register that returns a 64 bytes random buffer on every request.\nThis never blocks for a long time. If you need additional random bytes, keep querying the register.",
    fields: [{
      name: "_",
      type: "bytes",
      storage: 0,
      isSimpleType: true
    }],
    volatile: true,
    packFormat: "b"
  }, {
    kind: "const",
    name: "variant",
    identifier: 263,
    description: "The type of algorithm/technique used to generate the number.\n`Quantum` refers to dedicated hardware device generating random noise due to quantum effects.\n`ADCNoise` is the noise from quick readings of analog-digital converter, which reads temperature of the MCU or some floating pin.\n`WebCrypto` refers is used in simulators, where the source of randomness comes from an advanced operating system.",
    fields: [{
      name: "_",
      type: "Variant",
      storage: 1
    }],
    optional: true,
    identifierName: "variant",
    packFormat: "u8"
  }],
  tags: []
}, {
  name: "Role Manager",
  status: "experimental",
  shortId: "rolemanager",
  camelName: "roleManager",
  shortName: "roleManager",
  "extends": ["_base"],
  notes: {
    short: "Assign roles to services on the Jacdac bus.\n\nInternally, the role manager stores a mapping from `(device_id, service_idx)` to role name.\nUsers refer to services by using role names (eg., they instantiate an accelerometer client with a given role name).\nEach client has a role, and roles are unique to clients\n(ie., one should not have both a gyro and accelerometer service with role `left_leg`).\n\nRole names can be hierarchical, using slash character as a separator.\nExamples: `left_leg/acc`, `left_leg/gyro`, `right_leg/acc`.\nIf two roles share the prefix before first slash, it should be used as a hint that the services\nshould be co-located on a single device\n(eg., here the `left_leg` \"location\" is expected to have both an accelerometer and a gyro service on a single device)."
  },
  classIdentifier: 508264038,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "auto_bind",
    identifier: 128,
    description: "Normally, if some roles are unfilled, and there are idle services that can fulfill them,\nthe brain device will assign roles (bind) automatically.\nSuch automatic assignment happens every second or so, and is trying to be smart about \nco-locating roles that share \"host\" (part before first slash),\nas well as reasonably stable assignments.\nOnce user start assigning roles manually using this service, auto-binding should be disabled to avoid confusion.",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1,
      defaultValue: 1
    }],
    packFormat: "u8"
  }, {
    kind: "ro",
    name: "all_roles_allocated",
    identifier: 385,
    description: "Indicates if all required roles have been allocated to devices.",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1
    }],
    packFormat: "u8"
  }, {
    kind: "command",
    name: "get_role",
    identifier: 128,
    description: "Get the role corresponding to given device identifer. Returns empty string if unset.",
    fields: [{
      name: "device_id",
      type: "devid",
      storage: 8
    }, {
      name: "service_idx",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    hasReport: true,
    packFormat: "b[8] u8"
  }, {
    kind: "report",
    name: "get_role",
    identifier: 128,
    description: "Get the role corresponding to given device identifer. Returns empty string if unset.",
    fields: [{
      name: "device_id",
      type: "devid",
      storage: 8
    }, {
      name: "service_idx",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "role",
      type: "string",
      storage: 0
    }],
    secondary: true,
    packFormat: "b[8] u8 s"
  }, {
    kind: "command",
    name: "set_role",
    identifier: 129,
    description: "Set role. Can set to empty to remove role binding.",
    fields: [{
      name: "device_id",
      type: "devid",
      storage: 8
    }, {
      name: "service_idx",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "role",
      type: "string",
      storage: 0
    }],
    packFormat: "b[8] u8 s"
  }, {
    kind: "command",
    name: "clear_all_roles",
    identifier: 132,
    description: "Remove all role bindings.",
    fields: []
  }, {
    kind: "command",
    name: "list_stored_roles",
    identifier: 130,
    description: "Return all roles stored internally.",
    fields: [{
      name: "stored_roles",
      type: "pipe",
      storage: 12
    }],
    pipeType: "list_stored_roles",
    packFormat: "b[12]"
  }, {
    kind: "pipe_report",
    name: "stored_roles",
    identifier: 0,
    description: "Return all roles stored internally.",
    fields: [{
      name: "device_id",
      type: "devid",
      storage: 8
    }, {
      name: "service_idx",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "role",
      type: "string",
      storage: 0
    }],
    pipeType: "list_stored_roles",
    packFormat: "b[8] u8 s"
  }, {
    kind: "command",
    name: "list_required_roles",
    identifier: 131,
    description: "List all roles required by the current program. `device_id` and `service_idx` are `0` if role is unbound.",
    fields: [{
      name: "required_roles",
      type: "pipe",
      storage: 12
    }],
    pipeType: "list_required_roles",
    packFormat: "b[12]"
  }, {
    kind: "pipe_report",
    name: "required_roles",
    identifier: 0,
    description: "List all roles required by the current program. `device_id` and `service_idx` are `0` if role is unbound.",
    fields: [{
      name: "device_id",
      type: "devid",
      storage: 8
    }, {
      name: "service_class",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }, {
      name: "service_idx",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "role",
      type: "string",
      storage: 0
    }],
    pipeType: "list_required_roles",
    packFormat: "b[8] u32 u8 s"
  }, {
    kind: "event",
    name: "change",
    identifier: 3,
    description: "Notifies that role bindings have changed.",
    fields: [],
    identifierName: "change"
  }],
  tags: []
}, {
  name: "Rotary encoder",
  status: "experimental",
  shortId: "rotaryencoder",
  camelName: "rotaryEncoder",
  shortName: "rotaryEncoder",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "An incremental rotary encoder - converts angular motion of a shaft to digital signal."
  },
  classIdentifier: 284830153,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "position",
    identifier: 257,
    description: "Upon device reset starts at `0` (regardless of the shaft position).\nIncreases by `1` for a clockwise \"click\", by `-1` for counter-clockwise.",
    fields: [{
      name: "_",
      unit: "#",
      type: "i32",
      storage: -4,
      isSimpleType: true
    }],
    volatile: true,
    identifierName: "reading",
    packFormat: "i32"
  }, {
    kind: "const",
    name: "clicks_per_turn",
    identifier: 384,
    description: "This specifies by how much `position` changes when the crank does 360 degree turn. Typically 12 or 24.",
    fields: [{
      name: "_",
      unit: "#",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    packFormat: "u16"
  }],
  tags: ["C", "8bit"],
  group: "Slider"
}, {
  name: "Rover",
  status: "experimental",
  shortId: "rover",
  camelName: "rover",
  shortName: "rover",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "A roving robot."
  },
  classIdentifier: 435474539,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "kinematics",
    identifier: 257,
    description: "The current position and orientation of the robot.",
    fields: [{
      name: "x",
      unit: "cm",
      shift: 16,
      type: "i16.16",
      storage: -4
    }, {
      name: "y",
      unit: "cm",
      shift: 16,
      type: "i16.16",
      storage: -4
    }, {
      name: "vx",
      unit: "cm/s",
      shift: 16,
      type: "i16.16",
      storage: -4
    }, {
      name: "vy",
      unit: "cm/s",
      shift: 16,
      type: "i16.16",
      storage: -4
    }, {
      name: "heading",
      unit: "°",
      shift: 16,
      type: "i16.16",
      storage: -4
    }],
    volatile: true,
    identifierName: "reading",
    packFormat: "i16.16 i16.16 i16.16 i16.16 i16.16"
  }],
  tags: []
}, {
  name: "Sensor Aggregator",
  status: "experimental",
  shortId: "sensoraggregator",
  camelName: "sensorAggregator",
  shortName: "sensorAggregator",
  "extends": ["_base"],
  notes: {
    short: "Aggregate data from multiple sensors into a single stream\n(often used as input to machine learning models on the same device, see model runner service)."
  },
  classIdentifier: 496034245,
  enums: {
    SampleType: {
      name: "SampleType",
      storage: 1,
      members: {
        U8: 8,
        I8: 136,
        U16: 16,
        I16: 144,
        U32: 32,
        I32: 160
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "inputs",
    identifier: 128,
    description: "Set automatic input collection.\nThese settings are stored in flash.",
    fields: [{
      name: "sampling_interval",
      unit: "ms",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "samples_in_window",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "reserved",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }, {
      name: "device_id",
      type: "devid",
      storage: 8,
      startRepeats: true
    }, {
      name: "service_class",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }, {
      name: "service_num",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "sample_size",
      unit: "B",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }, {
      name: "sample_type",
      type: "SampleType",
      storage: 1
    }, {
      name: "sample_shift",
      type: "i8",
      storage: -1,
      isSimpleType: true
    }],
    packFormat: "u16 u16 u32 r: b[8] u32 u8 u8 u8 i8"
  }, {
    kind: "ro",
    name: "num_samples",
    identifier: 384,
    description: "Number of input samples collected so far.",
    fields: [{
      name: "_",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    packFormat: "u32"
  }, {
    kind: "ro",
    name: "sample_size",
    identifier: 385,
    description: "Size of a single sample.",
    fields: [{
      name: "_",
      unit: "B",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    packFormat: "u8"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 129,
    description: "When set to `N`, will stream `N` samples as `current_sample` reading.",
    fields: [{
      name: "_",
      unit: "#",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    packFormat: "u32"
  }, {
    kind: "ro",
    name: "current_sample",
    identifier: 257,
    description: "Last collected sample.",
    fields: [{
      name: "_",
      type: "bytes",
      storage: 0,
      isSimpleType: true
    }],
    volatile: true,
    identifierName: "reading",
    packFormat: "b"
  }],
  tags: []
}, {
  name: "Servo",
  status: "experimental",
  shortId: "servo",
  camelName: "servo",
  shortName: "servo",
  "extends": ["_base"],
  notes: {
    short: "Servo is a small motor with arm that can be pointing at a specific direction.\n\nThe `min/max_angle/pulse` may be read-only if the servo is permanently affixed to its Jacdac controller."
  },
  classIdentifier: 318542083,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "angle",
    identifier: 2,
    description: "Specifies the angle of the arm (request).",
    fields: [{
      name: "_",
      unit: "°",
      shift: 16,
      type: "i16.16",
      storage: -4,
      typicalMin: -90,
      typicalMax: 90
    }],
    identifierName: "value",
    packFormat: "i16.16"
  }, {
    kind: "rw",
    name: "enabled",
    identifier: 1,
    description: "Turn the power to the servo on/off.",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1
    }],
    identifierName: "intensity",
    packFormat: "u8"
  }, {
    kind: "rw",
    name: "offset",
    identifier: 129,
    description: "Correction applied to the angle to account for the servo arm drift.",
    fields: [{
      name: "_",
      unit: "°",
      shift: 16,
      type: "i16.16",
      storage: -4
    }],
    packFormat: "i16.16"
  }, {
    kind: "const",
    name: "min_angle",
    identifier: 272,
    description: "Lowest angle that can be set.",
    fields: [{
      name: "_",
      unit: "°",
      shift: 16,
      type: "i16.16",
      storage: -4,
      defaultValue: -90
    }],
    identifierName: "min_value",
    packFormat: "i16.16"
  }, {
    kind: "rw",
    name: "min_pulse",
    identifier: 131,
    description: "The length of pulse corresponding to lowest angle.",
    fields: [{
      name: "_",
      unit: "us",
      type: "u16",
      storage: 2,
      isSimpleType: true,
      defaultValue: 500
    }],
    packFormat: "u16"
  }, {
    kind: "const",
    name: "max_angle",
    identifier: 273,
    description: "Highest angle that can be set.",
    fields: [{
      name: "_",
      unit: "°",
      shift: 16,
      type: "i16.16",
      storage: -4,
      defaultValue: 90
    }],
    identifierName: "max_value",
    packFormat: "i16.16"
  }, {
    kind: "rw",
    name: "max_pulse",
    identifier: 133,
    description: "The length of pulse corresponding to highest angle.",
    fields: [{
      name: "_",
      unit: "us",
      type: "u16",
      storage: 2,
      isSimpleType: true,
      defaultValue: 2500
    }],
    packFormat: "u16"
  }, {
    kind: "const",
    name: "stall_torque",
    identifier: 384,
    description: "The servo motor will stop rotating when it is trying to move a ``stall_torque`` weight at a radial distance of ``1.0`` cm.",
    fields: [{
      name: "_",
      unit: "kg/cm",
      shift: 16,
      type: "u16.16",
      storage: 4
    }],
    optional: true,
    packFormat: "u16.16"
  }, {
    kind: "const",
    name: "response_speed",
    identifier: 385,
    description: "Time to move 60°.",
    fields: [{
      name: "_",
      unit: "s/60°",
      shift: 16,
      type: "u16.16",
      storage: 4
    }],
    optional: true,
    packFormat: "u16.16"
  }, {
    kind: "ro",
    name: "current_angle",
    identifier: 257,
    description: "The current physical position of the arm.",
    fields: [{
      name: "_",
      unit: "°",
      shift: 16,
      type: "i16.16",
      storage: -4
    }],
    volatile: true,
    optional: true,
    identifierName: "reading",
    packFormat: "i16.16"
  }],
  tags: ["C"]
}, {
  name: "Settings",
  status: "experimental",
  shortId: "settings",
  camelName: "settings",
  shortName: "settings",
  "extends": ["_base"],
  notes: {
    short: "Non-volatile key-value storage interface for storing settings.",
    long: "## Secrets\n\nEntries with keys starting with `$` are considered secret.\nThey can be written normally, but they read as a single `0` byte,\nunless they are empty, in which case the value returned is also empty.\nThese are typically used by other services on the same device."
  },
  classIdentifier: 285727818,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "command",
    name: "get",
    identifier: 128,
    description: "Get the value of given setting. If no such entry exists, the value returned is empty.",
    fields: [{
      name: "key",
      type: "string",
      storage: 0
    }],
    hasReport: true,
    packFormat: "s"
  }, {
    kind: "report",
    name: "get",
    identifier: 128,
    description: "Get the value of given setting. If no such entry exists, the value returned is empty.",
    fields: [{
      name: "key",
      type: "string0",
      storage: 0
    }, {
      name: "value",
      type: "bytes",
      storage: 0,
      isSimpleType: true
    }],
    secondary: true,
    packFormat: "z b"
  }, {
    kind: "command",
    name: "set",
    identifier: 129,
    description: "Set the value of a given setting.",
    fields: [{
      name: "key",
      type: "string0",
      storage: 0
    }, {
      name: "value",
      type: "bytes",
      storage: 0,
      isSimpleType: true
    }],
    restricted: true,
    packFormat: "z b"
  }, {
    kind: "command",
    name: "delete",
    identifier: 132,
    description: "Delete a given setting.",
    fields: [{
      name: "key",
      type: "string",
      storage: 0
    }],
    restricted: true,
    packFormat: "s"
  }, {
    kind: "command",
    name: "list_keys",
    identifier: 130,
    description: "Return keys of all settings.",
    fields: [{
      name: "results",
      type: "pipe",
      storage: 12
    }],
    pipeType: "list_keys",
    packFormat: "b[12]"
  }, {
    kind: "pipe_report",
    name: "listed_key",
    identifier: 0,
    description: "Return keys of all settings.",
    fields: [{
      name: "key",
      type: "string",
      storage: 0
    }],
    pipeType: "list_keys",
    packFormat: "s"
  }, {
    kind: "command",
    name: "list",
    identifier: 131,
    description: "Return keys and values of all settings.",
    fields: [{
      name: "results",
      type: "pipe",
      storage: 12
    }],
    pipeType: "list",
    packFormat: "b[12]"
  }, {
    kind: "pipe_report",
    name: "listed_entry",
    identifier: 0,
    description: "Return keys and values of all settings.",
    fields: [{
      name: "key",
      type: "string0",
      storage: 0
    }, {
      name: "value",
      type: "bytes",
      storage: 0,
      isSimpleType: true
    }],
    pipeType: "list",
    packFormat: "z b"
  }, {
    kind: "command",
    name: "clear",
    identifier: 133,
    description: "Clears all keys.",
    fields: [],
    restricted: true
  }, {
    kind: "event",
    name: "change",
    identifier: 3,
    description: "Notifies that some setting have been modified.",
    fields: [],
    identifierName: "change"
  }],
  tags: []
}, {
  name: "7-segment display",
  status: "experimental",
  shortId: "sevensegmentdisplay",
  camelName: "sevenSegmentDisplay",
  shortName: "sevenSegmentDisplay",
  "extends": ["_base"],
  notes: {
    short: "A 7-segment numeric display, with one or more digits."
  },
  classIdentifier: 425810167,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "digits",
    identifier: 2,
    description: "Each byte encodes the display status of a digit using, \nwhere bit 0 encodes segment `A`, bit 1 encodes segments `B`, ..., bit 6 encodes segments `G`, and bit 7 encodes the decimal point (if present).\nIf incoming ``digits`` data is smaller than `digit_count`, the remaining digits will be cleared.\nThus, sending an empty ``digits`` payload clears the screen.\n\n```text\n - A -\n G   B\n |   |\n - F -\n |   |   -\n E   C  |DP|\n - D -   -\n```",
    fields: [{
      name: "_",
      encoding: "bitset",
      type: "bytes",
      storage: 0,
      isSimpleType: true
    }],
    lowLevel: true,
    identifierName: "value",
    packFormat: "b"
  }, {
    kind: "rw",
    name: "brightness",
    identifier: 1,
    description: "Controls the brightness of the LEDs. ``0`` means off.",
    fields: [{
      name: "_",
      unit: "/",
      shift: 16,
      type: "u0.16",
      storage: 2
    }],
    identifierName: "intensity",
    packFormat: "u0.16"
  }, {
    kind: "rw",
    name: "double_dots",
    identifier: 128,
    description: "Turn on or off the column LEDs (separating minutes from hours, etc.) in of the segment.\nIf the column LEDs is not supported, the value remains false.",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1
    }],
    optional: true,
    packFormat: "u8"
  }, {
    kind: "const",
    name: "digit_count",
    identifier: 384,
    description: "The number of digits available on the display.",
    fields: [{
      name: "_",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    packFormat: "u8"
  }, {
    kind: "const",
    name: "decimal_point",
    identifier: 385,
    description: "True if decimal points are available (on all digits).",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1
    }],
    packFormat: "u8"
  }, {
    kind: "command",
    name: "set_number",
    identifier: 128,
    description: "Shows the number on the screen using the decimal dot if available.",
    fields: [{
      name: "value",
      isFloat: true,
      type: "f64",
      storage: 8
    }],
    client: true,
    packFormat: "f64"
  }, {
    kind: "command",
    name: "set_text",
    identifier: 129,
    description: "Shows the text on the screen. The client may decide to scroll the text if too long.",
    fields: [{
      name: "text",
      type: "string",
      storage: 0
    }],
    client: true,
    packFormat: "s"
  }],
  tags: ["8bit"],
  group: "Display"
}, {
  name: "Soil moisture",
  status: "experimental",
  shortId: "soilmoisture",
  camelName: "soilMoisture",
  shortName: "soilMoisture",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "A soil moisture sensor."
  },
  classIdentifier: 491430835,
  enums: {
    Variant: {
      name: "Variant",
      storage: 1,
      members: {
        Resistive: 1,
        Capacitive: 2
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "moisture",
    identifier: 257,
    description: "Indicates the wetness of the soil, from ``dry`` to ``wet``.",
    fields: [{
      name: "_",
      unit: "/",
      shift: 16,
      type: "u0.16",
      storage: 2
    }],
    volatile: true,
    identifierName: "reading",
    preferredInterval: 1000,
    packFormat: "u0.16"
  }, {
    kind: "const",
    name: "variant",
    identifier: 263,
    description: "Describe the type of physical sensor.",
    fields: [{
      name: "_",
      type: "Variant",
      storage: 1
    }],
    optional: true,
    identifierName: "variant",
    packFormat: "u8"
  }],
  tags: ["8bit"],
  group: "Environment"
}, {
  name: "Solenoid",
  status: "experimental",
  shortId: "solenoid",
  camelName: "solenoid",
  shortName: "solenoid",
  "extends": ["_base"],
  notes: {
    short: "A push-pull solenoid is a type of relay that pulls a coil when activated."
  },
  classIdentifier: 387392458,
  enums: {
    Variant: {
      name: "Variant",
      storage: 1,
      members: {
        PushPull: 1,
        Valve: 2,
        Latch: 3
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "pulled",
    identifier: 1,
    description: "Indicates whether the solenoid is energized and pulled (on) or pushed (off).",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1
    }],
    identifierName: "intensity",
    packFormat: "u8"
  }, {
    kind: "const",
    name: "variant",
    identifier: 263,
    description: "Describes the type of solenoid used.",
    fields: [{
      name: "_",
      type: "Variant",
      storage: 1
    }],
    optional: true,
    identifierName: "variant",
    packFormat: "u8"
  }],
  tags: ["8bit"]
}, {
  name: "Sound level",
  status: "experimental",
  shortId: "soundlevel",
  camelName: "soundLevel",
  shortName: "soundLevel",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "A sound level detector sensor, gives a relative indication of the sound level."
  },
  classIdentifier: 346888797,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "sound_level",
    identifier: 257,
    description: "The sound level detected by the microphone",
    fields: [{
      name: "_",
      unit: "/",
      shift: 16,
      type: "u0.16",
      storage: 2
    }],
    volatile: true,
    identifierName: "reading",
    packFormat: "u0.16"
  }, {
    kind: "rw",
    name: "enabled",
    identifier: 1,
    description: "Turn on or off the microphone.",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1
    }],
    identifierName: "intensity",
    packFormat: "u8"
  }, {
    kind: "rw",
    name: "min_decibels",
    identifier: 129,
    description: "The minimum power value considered by the sensor.\nIf both ``min_decibels`` and ``max_decibels`` are supported,\nthe volume in deciment can be linearly interpolated between\n``[min_decibels, max_decibels]``.",
    fields: [{
      name: "_",
      unit: "dB",
      type: "i16",
      storage: -2,
      isSimpleType: true
    }],
    optional: true,
    packFormat: "i16"
  }, {
    kind: "rw",
    name: "max_decibels",
    identifier: 130,
    description: "The maximum power value considered by the sensor.\nIf both ``min_decibels`` and ``max_decibels`` are supported,\nthe volume in deciment can be linearly interpolated between\n``[min_decibels, max_decibels]``.",
    fields: [{
      name: "_",
      unit: "dB",
      type: "i16",
      storage: -2,
      isSimpleType: true
    }],
    optional: true,
    packFormat: "i16"
  }, {
    kind: "rw",
    name: "loud_threshold",
    identifier: 6,
    description: "The sound level to trigger a loud event.",
    fields: [{
      name: "_",
      unit: "/",
      shift: 16,
      type: "u0.16",
      storage: 2
    }],
    identifierName: "active_threshold",
    packFormat: "u0.16"
  }, {
    kind: "rw",
    name: "quiet_threshold",
    identifier: 5,
    description: "The sound level to trigger a quiet event.",
    fields: [{
      name: "_",
      unit: "/",
      shift: 16,
      type: "u0.16",
      storage: 2
    }],
    identifierName: "inactive_threshold",
    packFormat: "u0.16"
  }, {
    kind: "event",
    name: "loud",
    identifier: 1,
    description: "Raised when a loud sound is detected",
    fields: [],
    identifierName: "active"
  }, {
    kind: "event",
    name: "quiet",
    identifier: 2,
    description: "Raised when a period of quietness is detected",
    fields: [],
    identifierName: "inactive"
  }],
  tags: ["8bit"],
  group: "Sound"
}, {
  name: "Sound player",
  status: "experimental",
  shortId: "soundplayer",
  camelName: "soundPlayer",
  shortName: "soundPlayer",
  "extends": ["_base"],
  notes: {
    short: "A device that can play various sounds stored locally. This service is typically paired with a ``storage`` service for storing sounds."
  },
  classIdentifier: 335795000,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "volume",
    identifier: 1,
    description: "Global volume of the output. ``0`` means completely off. This volume is mixed with each play volumes.",
    fields: [{
      name: "_",
      unit: "/",
      shift: 16,
      type: "u0.16",
      storage: 2
    }],
    identifierName: "intensity",
    packFormat: "u0.16"
  }, {
    kind: "command",
    name: "play",
    identifier: 128,
    description: "Starts playing a sound.",
    fields: [{
      name: "name",
      type: "string",
      storage: 0
    }],
    packFormat: "s"
  }, {
    kind: "command",
    name: "list_sounds",
    identifier: 129,
    description: "Returns the list of sounds available to play.",
    fields: [{
      name: "sounds_port",
      type: "pipe",
      storage: 12
    }],
    pipeType: "list_sounds",
    packFormat: "b[12]"
  }, {
    kind: "pipe_report",
    name: "list_sounds_pipe",
    identifier: 0,
    description: "Returns the list of sounds available to play.",
    fields: [{
      name: "duration",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }, {
      name: "name",
      type: "string",
      storage: 0
    }],
    pipeType: "list_sounds",
    packFormat: "u32 s"
  }],
  tags: [],
  group: "Sound"
}, {
  name: "Sound Spectrum",
  status: "experimental",
  shortId: "soundspectrum",
  camelName: "soundSpectrum",
  shortName: "soundSpectrum",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "A microphone that analyzes the sound specturm"
  },
  classIdentifier: 360365086,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "frequency_bins",
    identifier: 257,
    description: "The computed frequency data.",
    fields: [{
      name: "_",
      type: "bytes",
      storage: 0,
      isSimpleType: true
    }],
    volatile: true,
    identifierName: "reading",
    packFormat: "b"
  }, {
    kind: "rw",
    name: "enabled",
    identifier: 1,
    description: "Turns on/off the micropohone.",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1
    }],
    identifierName: "intensity",
    packFormat: "u8"
  }, {
    kind: "rw",
    name: "fft_pow2_size",
    identifier: 128,
    description: "The power of 2 used as the size of the FFT to be used to determine the frequency domain.",
    fields: [{
      name: "_",
      type: "u8",
      storage: 1,
      isSimpleType: true,
      defaultValue: 5,
      absoluteMin: 2,
      absoluteMax: 7
    }],
    packFormat: "u8"
  }, {
    kind: "rw",
    name: "min_decibels",
    identifier: 129,
    description: "The minimum power value in the scaling range for the FFT analysis data",
    fields: [{
      name: "_",
      unit: "dB",
      type: "i16",
      storage: -2,
      isSimpleType: true
    }],
    packFormat: "i16"
  }, {
    kind: "rw",
    name: "max_decibels",
    identifier: 130,
    description: "The maximum power value in the scaling range for the FFT analysis data",
    fields: [{
      name: "_",
      unit: "dB",
      type: "i16",
      storage: -2,
      isSimpleType: true
    }],
    packFormat: "i16"
  }, {
    kind: "rw",
    name: "smoothing_time_constant",
    identifier: 131,
    description: "The averaging constant with the last analysis frame. \nIf ``0`` is set, there is no averaging done, whereas a value of ``1`` means \"overlap the previous and current buffer quite a lot while computing the value\".",
    fields: [{
      name: "_",
      unit: "/",
      shift: 8,
      type: "u0.8",
      storage: 1,
      defaultValue: 0.8
    }],
    packFormat: "u0.8"
  }],
  tags: [],
  group: "Sound"
}, {
  name: "Speech synthesis",
  status: "experimental",
  shortId: "speechsynthesis",
  camelName: "speechSynthesis",
  shortName: "speechSynthesis",
  "extends": ["_base"],
  notes: {
    short: "A speech synthesizer"
  },
  classIdentifier: 302307733,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "enabled",
    identifier: 1,
    description: "Determines if the speech engine is in a non-paused state.",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1
    }],
    identifierName: "intensity",
    packFormat: "u8"
  }, {
    kind: "rw",
    name: "lang",
    identifier: 128,
    description: "Language used for utterances as defined in https://www.ietf.org/rfc/bcp/bcp47.txt.",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    packFormat: "s"
  }, {
    kind: "rw",
    name: "volume",
    identifier: 129,
    description: "Volume for utterances.",
    fields: [{
      name: "_",
      unit: "/",
      shift: 8,
      type: "u0.8",
      storage: 1,
      defaultValue: 1
    }],
    optional: true,
    packFormat: "u0.8"
  }, {
    kind: "rw",
    name: "pitch",
    identifier: 130,
    description: "Pitch for utterances",
    fields: [{
      name: "_",
      shift: 16,
      type: "u16.16",
      storage: 4,
      defaultValue: 1,
      absoluteMax: 2,
      absoluteMin: 0
    }],
    optional: true,
    packFormat: "u16.16"
  }, {
    kind: "rw",
    name: "rate",
    identifier: 131,
    description: "Rate for utterances",
    fields: [{
      name: "_",
      shift: 16,
      type: "u16.16",
      storage: 4,
      defaultValue: 1,
      absoluteMin: 0.1,
      absoluteMax: 10
    }],
    optional: true,
    packFormat: "u16.16"
  }, {
    kind: "command",
    name: "speak",
    identifier: 128,
    description: "Adds an utterance to the utterance queue; it will be spoken when any other utterances queued before it have been spoken.",
    fields: [{
      name: "text",
      type: "string",
      storage: 0
    }],
    packFormat: "s"
  }, {
    kind: "command",
    name: "cancel",
    identifier: 129,
    description: "Cancels current utterance and all utterances from the utterance queue.",
    fields: []
  }],
  tags: []
}, {
  name: "Switch",
  status: "experimental",
  shortId: "switch",
  camelName: "switch",
  shortName: "switch",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "A switch, which keeps its position."
  },
  classIdentifier: 450008066,
  enums: {
    Variant: {
      name: "Variant",
      storage: 1,
      members: {
        Slide: 1,
        Tilt: 2,
        PushButton: 3,
        Tactile: 4,
        Toggle: 5,
        Proximity: 6,
        Magnetic: 7,
        FootPedal: 8
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "active",
    identifier: 257,
    description: "Indicates whether the switch is currently active (on).",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1
    }],
    volatile: true,
    identifierName: "reading",
    packFormat: "u8"
  }, {
    kind: "const",
    name: "variant",
    identifier: 263,
    description: "Describes the type of switch used.",
    fields: [{
      name: "_",
      type: "Variant",
      storage: 1
    }],
    optional: true,
    identifierName: "variant",
    packFormat: "u8"
  }, {
    kind: "const",
    name: "auto_off_delay",
    identifier: 384,
    description: "Specifies the delay without activity to automatically turn off after turning on.\nFor example, some light switches in staircases have such a capability.",
    fields: [{
      name: "_",
      unit: "s",
      shift: 16,
      type: "u16.16",
      storage: 4
    }],
    optional: true,
    packFormat: "u16.16"
  }, {
    kind: "event",
    name: "on",
    identifier: 1,
    description: "Emitted when switch goes from ``off`` to ``on``.",
    fields: [],
    identifierName: "active"
  }, {
    kind: "event",
    name: "off",
    identifier: 2,
    description: "Emitted when switch goes from ``on`` to ``off``.",
    fields: [],
    identifierName: "inactive"
  }],
  tags: ["8bit"],
  group: "Button"
}, {
  name: "TCP",
  status: "experimental",
  shortId: "tcp",
  camelName: "tcp",
  shortName: "tcp",
  "extends": ["_base"],
  notes: {
    short: "Data transfer over TCP/IP and TLS stream sockets.",
    commands: "## Pipes"
  },
  classIdentifier: 457422603,
  enums: {
    TcpError: {
      name: "TcpError",
      storage: -4,
      members: {
        InvalidCommand: 1,
        InvalidCommandPayload: 2
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "command",
    name: "open",
    identifier: 128,
    description: "Open pair of pipes between network peripheral and a controlling device. In/outbound refers to direction from/to internet.",
    fields: [{
      name: "inbound",
      type: "pipe",
      storage: 12
    }],
    pipeType: "open",
    hasReport: true,
    packFormat: "b[12]"
  }, {
    kind: "report",
    name: "open",
    identifier: 128,
    description: "Open pair of pipes between network peripheral and a controlling device. In/outbound refers to direction from/to internet.",
    fields: [{
      name: "outbound_port",
      type: "pipe_port",
      storage: 2
    }],
    secondary: true,
    pipeType: "open",
    packFormat: "u16"
  }, {
    kind: "meta_pipe_command",
    name: "open_ssl",
    identifier: 1,
    description: "Open an SSL connection to a given host:port pair. Can be issued only once on given pipe.\nAfter the connection is established, an empty data report is sent.\nConnection is closed by closing the pipe.",
    fields: [{
      name: "tcp_port",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "hostname",
      type: "string",
      storage: 0
    }],
    pipeType: "open",
    packFormat: "u16 s"
  }, {
    kind: "pipe_command",
    name: "outdata",
    identifier: 0,
    description: "Bytes to be sent directly over an established TCP or SSL connection.",
    fields: [{
      name: "data",
      type: "bytes",
      storage: 0,
      isSimpleType: true
    }],
    pipeType: "open",
    packFormat: "b"
  }, {
    kind: "pipe_report",
    name: "indata",
    identifier: 0,
    description: "Bytes read directly from directly over an established TCP or SSL connection.",
    fields: [{
      name: "data",
      type: "bytes",
      storage: 0,
      isSimpleType: true
    }],
    pipeType: "open",
    packFormat: "b"
  }, {
    kind: "meta_pipe_report",
    name: "error",
    identifier: 0,
    description: "Reported when an error is encountered. Negative error codes come directly from the SSL implementation.",
    fields: [{
      name: "error",
      type: "TcpError",
      storage: -4
    }],
    pipeType: "open",
    packFormat: "i32"
  }],
  tags: []
}, {
  name: "Thermocouple",
  status: "experimental",
  shortId: "thermocouple",
  camelName: "thermocouple",
  shortName: "thermocouple",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "A thermocouple using a heat probe to gather temperatures."
  },
  classIdentifier: 339394657,
  enums: {
    Variant: {
      name: "Variant",
      storage: 1,
      members: {
        TypeK: 1,
        TypeJ: 2,
        TypeT: 3,
        TypeE: 4,
        TypeN: 5,
        TypeS: 6,
        TypeR: 7,
        TypeB: 8
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "temperature",
    identifier: 257,
    description: "The temperature.",
    fields: [{
      name: "_",
      unit: "°C",
      shift: 10,
      type: "i22.10",
      storage: -4
    }],
    volatile: true,
    identifierName: "reading",
    preferredInterval: 1000,
    packFormat: "i22.10"
  }, {
    kind: "const",
    name: "min_temperature",
    identifier: 260,
    description: "Lowest temperature that can be reported.",
    fields: [{
      name: "_",
      unit: "°C",
      shift: 10,
      type: "i22.10",
      storage: -4
    }],
    identifierName: "min_reading",
    packFormat: "i22.10"
  }, {
    kind: "const",
    name: "max_temperature",
    identifier: 261,
    description: "Highest temperature that can be reported.",
    fields: [{
      name: "_",
      unit: "°C",
      shift: 10,
      type: "i22.10",
      storage: -4
    }],
    identifierName: "max_reading",
    packFormat: "i22.10"
  }, {
    kind: "ro",
    name: "temperature_error",
    identifier: 262,
    description: "The real temperature is between `temperature - temperature_error` and `temperature + temperature_error`.",
    fields: [{
      name: "_",
      unit: "°C",
      shift: 10,
      type: "u22.10",
      storage: 4
    }],
    volatile: true,
    identifierName: "reading_error",
    packFormat: "u22.10"
  }, {
    kind: "const",
    name: "variant",
    identifier: 263,
    description: "Specifies the type of thermometer.",
    fields: [{
      name: "_",
      type: "Variant",
      storage: 1
    }],
    optional: true,
    identifierName: "variant",
    packFormat: "u8"
  }],
  tags: ["8bit"],
  group: "Environment"
}, {
  name: "Thermometer",
  status: "experimental",
  shortId: "thermometer",
  camelName: "thermometer",
  shortName: "thermometer",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "A thermometer measuring outside or inside environment."
  },
  classIdentifier: 337754823,
  enums: {
    Variant: {
      name: "Variant",
      storage: 1,
      members: {
        Outdoor: 1,
        Indoor: 2,
        Body: 3
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "temperature",
    identifier: 257,
    description: "The temperature.",
    fields: [{
      name: "_",
      unit: "°C",
      shift: 10,
      type: "i22.10",
      storage: -4
    }],
    volatile: true,
    identifierName: "reading",
    preferredInterval: 1000,
    packFormat: "i22.10"
  }, {
    kind: "const",
    name: "min_temperature",
    identifier: 260,
    description: "Lowest temperature that can be reported.",
    fields: [{
      name: "_",
      unit: "°C",
      shift: 10,
      type: "i22.10",
      storage: -4
    }],
    identifierName: "min_reading",
    packFormat: "i22.10"
  }, {
    kind: "const",
    name: "max_temperature",
    identifier: 261,
    description: "Highest temperature that can be reported.",
    fields: [{
      name: "_",
      unit: "°C",
      shift: 10,
      type: "i22.10",
      storage: -4
    }],
    identifierName: "max_reading",
    packFormat: "i22.10"
  }, {
    kind: "ro",
    name: "temperature_error",
    identifier: 262,
    description: "The real temperature is between `temperature - temperature_error` and `temperature + temperature_error`.",
    fields: [{
      name: "_",
      unit: "°C",
      shift: 10,
      type: "u22.10",
      storage: 4
    }],
    volatile: true,
    identifierName: "reading_error",
    packFormat: "u22.10"
  }, {
    kind: "const",
    name: "variant",
    identifier: 263,
    description: "Specifies the type of thermometer.",
    fields: [{
      name: "_",
      type: "Variant",
      storage: 1
    }],
    optional: true,
    identifierName: "variant",
    packFormat: "u8"
  }],
  tags: ["C", "8bit"],
  group: "Environment"
}, {
  name: "Traffic Light",
  status: "experimental",
  shortId: "trafficlight",
  camelName: "trafficLight",
  shortName: "trafficLight",
  "extends": ["_base"],
  notes: {
    short: "Controls a mini traffic with a red, orange and green LED."
  },
  classIdentifier: 365137307,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "red",
    identifier: 128,
    description: "The on/off state of the red light.",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1
    }],
    packFormat: "u8"
  }, {
    kind: "rw",
    name: "orange",
    identifier: 129,
    description: "The on/off state of the red light.",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1
    }],
    packFormat: "u8"
  }, {
    kind: "rw",
    name: "green",
    identifier: 130,
    description: "The on/off state of the red light.",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1
    }],
    packFormat: "u8"
  }],
  tags: ["8bit"]
}, {
  name: "Total Volatile organic compound",
  status: "experimental",
  shortId: "tvoc",
  camelName: "tvoc",
  shortName: "tvoc",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "Measures equivalent Total Volatile Organic Compound levels."
  },
  classIdentifier: 312849815,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "TVOC",
    identifier: 257,
    description: "Total volatile organic compound readings in parts per billion.",
    fields: [{
      name: "_",
      unit: "ppb",
      shift: 10,
      type: "u22.10",
      storage: 4,
      absoluteMin: 0,
      typicalMax: 1187,
      typicalMin: 0
    }],
    volatile: true,
    identifierName: "reading",
    packFormat: "u22.10"
  }, {
    kind: "ro",
    name: "TVOC_error",
    identifier: 262,
    description: "Error on the reading data",
    fields: [{
      name: "_",
      unit: "ppb",
      shift: 10,
      type: "u22.10",
      storage: 4
    }],
    volatile: true,
    optional: true,
    identifierName: "reading_error",
    packFormat: "u22.10"
  }, {
    kind: "const",
    name: "min_TVOC",
    identifier: 260,
    description: "Minimum measurable value",
    fields: [{
      name: "_",
      unit: "ppb",
      shift: 10,
      type: "u22.10",
      storage: 4
    }],
    optional: true,
    identifierName: "min_reading",
    packFormat: "u22.10"
  }, {
    kind: "const",
    name: "max_TVOC",
    identifier: 261,
    description: "Minimum measurable value",
    fields: [{
      name: "_",
      unit: "ppb",
      shift: 10,
      type: "u22.10",
      storage: 4
    }],
    optional: true,
    identifierName: "max_reading",
    packFormat: "u22.10"
  }, {
    kind: "const",
    name: "conditioning_period",
    identifier: 384,
    description: "Time required to achieve good sensor stability before measuring after long idle period.",
    fields: [{
      name: "_",
      unit: "s",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    optional: true,
    packFormat: "u32"
  }],
  tags: ["8bit"],
  group: "Environment"
}, {
  name: "UV index",
  status: "experimental",
  shortId: "uvindex",
  camelName: "uvIndex",
  shortName: "uvIndex",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "The UV Index is a measure of the intensity of ultraviolet (UV) rays from the Sun."
  },
  classIdentifier: 527306128,
  enums: {
    Variant: {
      name: "Variant",
      storage: 1,
      members: {
        UVA_UVB: 1,
        Visible_IR: 2
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "uv_index",
    identifier: 257,
    description: "Ultraviolet index, typically refreshed every second.",
    fields: [{
      name: "_",
      unit: "uv",
      shift: 16,
      type: "u16.16",
      storage: 4,
      typicalMax: 11,
      typicalMin: 0
    }],
    volatile: true,
    identifierName: "reading",
    packFormat: "u16.16"
  }, {
    kind: "ro",
    name: "uv_index_error",
    identifier: 262,
    description: "Error on the UV measure.",
    fields: [{
      name: "_",
      unit: "uv",
      shift: 16,
      type: "u16.16",
      storage: 4
    }],
    volatile: true,
    optional: true,
    identifierName: "reading_error",
    packFormat: "u16.16"
  }, {
    kind: "const",
    name: "variant",
    identifier: 263,
    description: "The type of physical sensor and capabilities.",
    fields: [{
      name: "_",
      type: "Variant",
      storage: 1
    }],
    optional: true,
    identifierName: "variant",
    packFormat: "u8"
  }],
  tags: ["8bit"],
  group: "Environment"
}, {
  name: "Verified Telemetry",
  status: "experimental",
  shortId: "verifiedtelemetrysensor",
  camelName: "verifiedTelemetry",
  shortName: "verifiedTelemetry",
  "extends": ["_base"],
  notes: {
    short: "A mixin service that exposes verified telemetry information for a sensor (see https://github.com/Azure/Verified-Telemetry/tree/main/PnPModel)."
  },
  classIdentifier: 563381279,
  enums: {
    Status: {
      name: "Status",
      storage: 1,
      members: {
        Unknown: 0,
        Working: 1,
        Faulty: 2
      }
    },
    FingerprintType: {
      name: "FingerprintType",
      storage: 1,
      members: {
        FallCurve: 1,
        CurrentSense: 2,
        Custom: 3
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "ro",
    name: "telemetry_status",
    identifier: 384,
    description: "Reads the telemetry working status, where ``true`` is working and ``false`` is faulty.",
    fields: [{
      name: "_",
      type: "Status",
      storage: 1
    }],
    packFormat: "u8"
  }, {
    kind: "rw",
    name: "telemetry_status_interval",
    identifier: 128,
    description: "Specifies the interval between computing the fingerprint information.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    optional: true,
    packFormat: "u32"
  }, {
    kind: "const",
    name: "fingerprint_type",
    identifier: 385,
    description: "Type of the fingerprint.",
    fields: [{
      name: "_",
      type: "FingerprintType",
      storage: 1
    }],
    packFormat: "u8"
  }, {
    kind: "ro",
    name: "fingerprint_template",
    identifier: 386,
    description: "Template Fingerprint information of a working sensor.",
    fields: [{
      name: "confidence",
      unit: "%",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "template",
      type: "bytes",
      storage: 0,
      isSimpleType: true
    }],
    packFormat: "u16 b"
  }, {
    kind: "command",
    name: "reset_fingerprint_template",
    identifier: 128,
    description: "This command will clear the template fingerprint of a sensor and collect a new template fingerprint of the attached sensor.",
    fields: []
  }, {
    kind: "command",
    name: "retrain_fingerprint_template",
    identifier: 129,
    description: "This command will append a new template fingerprint to the `fingerprintTemplate`. Appending more fingerprints will increase the accuracy in detecting the telemetry status.",
    fields: []
  }, {
    kind: "event",
    name: "telemetry_status_change",
    identifier: 3,
    description: "The telemetry status of the device was updated.",
    fields: [{
      name: "telemetry_status",
      type: "Status",
      storage: 1
    }],
    identifierName: "change",
    packFormat: "u8"
  }, {
    kind: "event",
    name: "fingerprint_template_change",
    identifier: 128,
    description: "The fingerprint template was updated",
    fields: []
  }],
  tags: []
}, {
  name: "Vibration motor",
  status: "experimental",
  shortId: "vibration",
  camelName: "vibrationMotor",
  shortName: "vibrationMotor",
  "extends": ["_base"],
  notes: {
    short: "A vibration motor."
  },
  classIdentifier: 406832290,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "enabled",
    identifier: 1,
    description: "Determines if the vibration motor responds to vibrate commands.",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1
    }],
    identifierName: "intensity",
    packFormat: "u8"
  }, {
    kind: "command",
    name: "vibrate",
    identifier: 128,
    description: "Starts a sequence of vibration and pauses. To stop any existing vibration, send an empty payload.",
    fields: [{
      name: "duration",
      unit: "8ms",
      type: "u8",
      storage: 1,
      isSimpleType: true,
      startRepeats: true
    }, {
      name: "speed",
      unit: "/",
      shift: 8,
      type: "u0.8",
      storage: 1
    }],
    packFormat: "r: u8 u0.8"
  }],
  tags: []
}, {
  name: "Water level",
  status: "experimental",
  shortId: "waterlevel",
  camelName: "waterLevel",
  shortName: "waterLevel",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "A sensor that measures liquid/water level."
  },
  classIdentifier: 343630573,
  enums: {
    Variant: {
      name: "Variant",
      storage: 1,
      members: {
        Resistive: 1,
        ContactPhotoElectric: 2,
        NonContactPhotoElectric: 3
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "level",
    identifier: 257,
    description: "The reported water level.",
    fields: [{
      name: "_",
      unit: "/",
      shift: 16,
      type: "u0.16",
      storage: 2
    }],
    volatile: true,
    identifierName: "reading",
    packFormat: "u0.16"
  }, {
    kind: "const",
    name: "variant",
    identifier: 263,
    description: "The type of physical sensor.",
    fields: [{
      name: "_",
      type: "Variant",
      storage: 1
    }],
    optional: true,
    identifierName: "variant",
    packFormat: "u8"
  }],
  tags: ["8bit"]
}, {
  name: "Weight Scale",
  status: "experimental",
  shortId: "weightscale",
  camelName: "weightScale",
  shortName: "weightScale",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "A weight measuring sensor."
  },
  classIdentifier: 525160512,
  enums: {
    Variant: {
      name: "Variant",
      storage: 1,
      members: {
        Body: 1,
        Food: 2,
        Jewelry: 3
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "weight",
    identifier: 257,
    description: "The reported weight.",
    fields: [{
      name: "_",
      unit: "kg",
      shift: 16,
      type: "u16.16",
      storage: 4
    }],
    volatile: true,
    identifierName: "reading",
    packFormat: "u16.16"
  }, {
    kind: "ro",
    name: "weight_error",
    identifier: 262,
    description: "The estimate error on the reported reading.",
    fields: [{
      name: "_",
      unit: "kg",
      shift: 16,
      type: "u16.16",
      storage: 4
    }],
    volatile: true,
    optional: true,
    identifierName: "reading_error",
    packFormat: "u16.16"
  }, {
    kind: "rw",
    name: "zero_offset",
    identifier: 128,
    description: "Calibrated zero offset error on the scale, i.e. the measured weight when nothing is on the scale.\nYou do not need to subtract that from the reading, it has already been done.",
    fields: [{
      name: "_",
      unit: "kg",
      shift: 16,
      type: "u16.16",
      storage: 4
    }],
    optional: true,
    packFormat: "u16.16"
  }, {
    kind: "rw",
    name: "gain",
    identifier: 129,
    description: "Calibrated gain on the weight scale error.",
    fields: [{
      name: "_",
      shift: 16,
      type: "u16.16",
      storage: 4
    }],
    optional: true,
    packFormat: "u16.16"
  }, {
    kind: "const",
    name: "max_weight",
    identifier: 261,
    description: "Maximum supported weight on the scale.",
    fields: [{
      name: "_",
      unit: "kg",
      shift: 16,
      type: "u16.16",
      storage: 4
    }],
    optional: true,
    identifierName: "max_reading",
    packFormat: "u16.16"
  }, {
    kind: "const",
    name: "min_weight",
    identifier: 260,
    description: "Minimum recommend weight on the scale.",
    fields: [{
      name: "_",
      unit: "kg",
      shift: 16,
      type: "u16.16",
      storage: 4
    }],
    optional: true,
    identifierName: "min_reading",
    packFormat: "u16.16"
  }, {
    kind: "const",
    name: "weight_resolution",
    identifier: 264,
    description: "Smallest, yet distinguishable change in reading.",
    fields: [{
      name: "_",
      unit: "kg",
      shift: 16,
      type: "u16.16",
      storage: 4
    }],
    optional: true,
    identifierName: "reading_resolution",
    packFormat: "u16.16"
  }, {
    kind: "const",
    name: "variant",
    identifier: 263,
    description: "The type of physical scale",
    fields: [{
      name: "_",
      type: "Variant",
      storage: 1
    }],
    optional: true,
    identifierName: "variant",
    packFormat: "u8"
  }, {
    kind: "command",
    name: "calibrate_zero_offset",
    identifier: 128,
    description: "Call this command when there is nothing on the scale. If supported, the module should save the calibration data.",
    fields: []
  }, {
    kind: "command",
    name: "calibrate_gain",
    identifier: 129,
    description: "Call this command with the weight of the thing on the scale.",
    fields: [{
      name: "weight",
      unit: "g",
      shift: 10,
      type: "u22.10",
      storage: 4
    }],
    packFormat: "u22.10"
  }],
  tags: ["8bit"]
}, {
  name: "WIFI",
  status: "experimental",
  shortId: "wifi",
  camelName: "wifi",
  shortName: "wifi",
  "extends": ["_base"],
  notes: {
    short: "Discovery and connection to WiFi networks. Separate TCP service can be used for data transfer.\n\nThe device controlled by this service is meant to connect automatically, once configured.\nTo that end, it keeps a list of known WiFi networks, with priorities and passwords.\nIt will connect to the available network with numerically highest priority,\nbreaking ties in priority by signal strength (typically all known networks have priority of `0`)."
  },
  classIdentifier: 413852154,
  enums: {
    APFlags: {
      name: "APFlags",
      storage: 4,
      isFlags: true,
      members: {
        HasPassword: 1,
        WPS: 2,
        HasSecondaryChannelAbove: 4,
        HasSecondaryChannelBelow: 8,
        IEEE_802_11B: 256,
        IEEE_802_11A: 512,
        IEEE_802_11G: 1024,
        IEEE_802_11N: 2048,
        IEEE_802_11AC: 4096,
        IEEE_802_11AX: 8192,
        IEEE_802_LongRange: 32768
      }
    }
  },
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "command",
    name: "last_scan_results",
    identifier: 128,
    description: "Return list of WiFi network from the last scan.\nScans are performed periodically while not connected (in particular, on startup and after current connection drops),\nas well as upon `reconnect` and `scan` commands.",
    fields: [{
      name: "results",
      type: "pipe",
      storage: 12
    }],
    pipeType: "last_scan_results",
    packFormat: "b[12]"
  }, {
    kind: "pipe_report",
    name: "results",
    identifier: 0,
    description: "Return list of WiFi network from the last scan.\nScans are performed periodically while not connected (in particular, on startup and after current connection drops),\nas well as upon `reconnect` and `scan` commands.",
    fields: [{
      name: "flags",
      type: "APFlags",
      storage: 4
    }, {
      name: "reserved",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }, {
      name: "rssi",
      unit: "dB",
      type: "i8",
      storage: -1,
      isSimpleType: true,
      typicalMin: -100,
      typicalMax: -20
    }, {
      name: "channel",
      type: "u8",
      storage: 1,
      isSimpleType: true,
      typicalMin: 1,
      typicalMax: 13
    }, {
      name: "bssid",
      type: "u8[6]",
      storage: 6
    }, {
      name: "ssid",
      type: "string",
      storage: 33,
      maxBytes: 33
    }],
    pipeType: "last_scan_results",
    packFormat: "u32 u32 i8 u8 b[6] s[33]"
  }, {
    kind: "command",
    name: "add_network",
    identifier: 129,
    description: "Automatically connect to named network if available. Also set password if network is not open.",
    fields: [{
      name: "ssid",
      type: "string0",
      storage: 0
    }, {
      name: "password",
      type: "string0",
      storage: 0,
      isOptional: true
    }],
    packFormat: "z z"
  }, {
    kind: "command",
    name: "reconnect",
    identifier: 130,
    description: "Initiate a scan, wait for results, disconnect from current WiFi network if any,\nand then reconnect (using regular algorithm, see `set_network_priority`).",
    fields: []
  }, {
    kind: "command",
    name: "forget_network",
    identifier: 131,
    description: "Prevent from automatically connecting to named network in future.\nForgetting a network resets its priority to `0`.",
    fields: [{
      name: "ssid",
      type: "string",
      storage: 0
    }],
    packFormat: "s"
  }, {
    kind: "command",
    name: "forget_all_networks",
    identifier: 132,
    description: "Clear the list of known networks.",
    fields: []
  }, {
    kind: "command",
    name: "set_network_priority",
    identifier: 133,
    description: "Set connection priority for a network.\nBy default, all known networks have priority of `0`.",
    fields: [{
      name: "priority",
      type: "i16",
      storage: -2,
      isSimpleType: true
    }, {
      name: "ssid",
      type: "string",
      storage: 0
    }],
    packFormat: "i16 s"
  }, {
    kind: "command",
    name: "scan",
    identifier: 134,
    description: "Initiate search for WiFi networks. Generates `scan_complete` event.",
    fields: []
  }, {
    kind: "command",
    name: "list_known_networks",
    identifier: 135,
    description: "Return list of known WiFi networks.\n`flags` is currently always 0.",
    fields: [{
      name: "results",
      type: "pipe",
      storage: 12
    }],
    pipeType: "list_known_networks",
    packFormat: "b[12]"
  }, {
    kind: "pipe_report",
    name: "network_results",
    identifier: 0,
    description: "Return list of known WiFi networks.\n`flags` is currently always 0.",
    fields: [{
      name: "priority",
      type: "i16",
      storage: -2,
      isSimpleType: true
    }, {
      name: "flags",
      type: "i16",
      storage: -2,
      isSimpleType: true
    }, {
      name: "ssid",
      type: "string",
      storage: 0
    }],
    pipeType: "list_known_networks",
    packFormat: "i16 i16 s"
  }, {
    kind: "rw",
    name: "enabled",
    identifier: 1,
    description: "Determines whether the WiFi radio is enabled. It starts enabled upon reset.",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1
    }],
    identifierName: "intensity",
    packFormat: "u8"
  }, {
    kind: "ro",
    name: "connected",
    identifier: 384,
    description: "Indicates whether or not we currently have an IP address assigned.",
    fields: [{
      name: "_",
      type: "bool",
      storage: 1
    }],
    packFormat: "u8"
  }, {
    kind: "ro",
    name: "ip_address",
    identifier: 385,
    description: "0, 4 or 16 byte buffer with the IPv4 or IPv6 address assigned to device if any.",
    fields: [{
      name: "_",
      type: "bytes",
      storage: 16,
      isSimpleType: true,
      maxBytes: 16
    }],
    packFormat: "b[16]"
  }, {
    kind: "const",
    name: "eui_48",
    identifier: 386,
    description: "The 6-byte MAC address of the device. If a device does MAC address randomization it will have to \"restart\".",
    fields: [{
      name: "_",
      type: "bytes",
      storage: 6,
      isSimpleType: true,
      maxBytes: 6
    }],
    packFormat: "b[6]"
  }, {
    kind: "ro",
    name: "ssid",
    identifier: 387,
    description: "SSID of the access-point to which device is currently connected.\nEmpty string if not connected.",
    fields: [{
      name: "_",
      type: "string",
      storage: 32,
      maxBytes: 32
    }],
    packFormat: "s[32]"
  }, {
    kind: "ro",
    name: "rssi",
    identifier: 388,
    description: "Current signal strength. Returns -128 when not connected.",
    fields: [{
      name: "_",
      unit: "dB",
      type: "i8",
      storage: -1,
      isSimpleType: true,
      typicalMin: -128,
      typicalMax: -20
    }],
    volatile: true,
    packFormat: "i8"
  }, {
    kind: "event",
    name: "got_ip",
    identifier: 1,
    description: "Emitted upon successful join and IP address assignment.",
    fields: [],
    identifierName: "active"
  }, {
    kind: "event",
    name: "lost_ip",
    identifier: 2,
    description: "Emitted when disconnected from network.",
    fields: [],
    identifierName: "inactive"
  }, {
    kind: "event",
    name: "scan_complete",
    identifier: 128,
    description: "A WiFi network scan has completed. Results can be read with the `last_scan_results` command.\nThe event indicates how many networks where found, and how many are considered\nas candidates for connection.",
    fields: [{
      name: "num_networks",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "num_known_networks",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    packFormat: "u16 u16"
  }, {
    kind: "event",
    name: "networks_changed",
    identifier: 129,
    description: "Emitted whenever the list of known networks is updated.",
    fields: []
  }],
  tags: [],
  group: "Iot"
}, {
  name: "Wind direction",
  status: "experimental",
  shortId: "winddirection",
  camelName: "windDirection",
  shortName: "windDirection",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "A sensor that measures wind direction."
  },
  classIdentifier: 409725227,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "wind_direction",
    identifier: 257,
    description: "The direction of the wind.",
    fields: [{
      name: "_",
      unit: "°",
      type: "u16",
      storage: 2,
      isSimpleType: true,
      absoluteMin: 0,
      absoluteMax: 359
    }],
    volatile: true,
    identifierName: "reading",
    preferredInterval: 1000,
    packFormat: "u16"
  }, {
    kind: "ro",
    name: "wind_direction_error",
    identifier: 262,
    description: "Error on the wind direction reading",
    fields: [{
      name: "_",
      unit: "°",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    volatile: true,
    optional: true,
    identifierName: "reading_error",
    packFormat: "u16"
  }],
  tags: ["8bit"]
}, {
  name: "Wind speed",
  status: "experimental",
  shortId: "windspeed",
  camelName: "windSpeed",
  shortName: "windSpeed",
  "extends": ["_base", "_sensor"],
  notes: {
    short: "A sensor that measures wind speed."
  },
  classIdentifier: 458824639,
  enums: {},
  constants: {},
  packets: [{
    kind: "const",
    name: "instance_name",
    identifier: 265,
    description: "A friendly name that describes the role of this service instance in the device.\nIt often corresponds to what's printed on the device:\nfor example, `A` for button A, or `S0` for servo channel 0.\nWords like `left` should be avoided because of localization issues (unless they are printed on the device).",
    fields: [{
      name: "_",
      type: "string",
      storage: 0
    }],
    optional: true,
    identifierName: "instance_name",
    packFormat: "s",
    derived: "_base"
  }, {
    kind: "ro",
    name: "status_code",
    identifier: 259,
    description: "Reports the current state or error status of the device. ``code`` is a standardized value from \nthe Jacdac status/error codes. ``vendor_code`` is any vendor specific error code describing the device\nstate. This report is typically not queried, when a device has an error, it will typically\nadd this report in frame along with the announce packet. If a service implements this register,\nit should also support the ``status_code_changed`` event defined below.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "event",
    name: "status_code_changed",
    identifier: 4,
    description: "Notifies that the status code of the service changed.",
    fields: [{
      name: "code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }, {
      name: "vendor_code",
      type: "u16",
      storage: 2,
      isSimpleType: true
    }],
    optional: true,
    identifierName: "status_code_changed",
    packFormat: "u16 u16",
    derived: "_base"
  }, {
    kind: "rw",
    name: "streaming_samples",
    identifier: 3,
    description: "Asks device to stream a given number of samples\n(clients will typically write `255` to this register every second or so, while streaming is required).",
    fields: [{
      name: "_",
      unit: "#",
      type: "u8",
      storage: 1,
      isSimpleType: true
    }],
    internal: true,
    identifierName: "streaming_samples",
    packFormat: "u8",
    derived: "_sensor"
  }, {
    kind: "rw",
    name: "streaming_interval",
    identifier: 4,
    description: "Period between packets of data when streaming in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true,
      defaultValue: 100,
      typicalMin: 1,
      typicalMax: 60000
    }],
    identifierName: "streaming_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "const",
    name: "streaming_preferred_interval",
    identifier: 258,
    description: "Preferred default streaming interval for sensor in milliseconds.",
    fields: [{
      name: "_",
      unit: "ms",
      type: "u32",
      storage: 4,
      isSimpleType: true
    }],
    internal: true,
    optional: true,
    identifierName: "streaming_preferred_interval",
    packFormat: "u32",
    derived: "_sensor"
  }, {
    kind: "ro",
    name: "wind_speed",
    identifier: 257,
    description: "The velocity of the wind.",
    fields: [{
      name: "_",
      unit: "m/s",
      shift: 16,
      type: "u16.16",
      storage: 4
    }],
    volatile: true,
    identifierName: "reading",
    preferredInterval: 60000,
    packFormat: "u16.16"
  }, {
    kind: "ro",
    name: "wind_speed_error",
    identifier: 262,
    description: "Error on the reading",
    fields: [{
      name: "_",
      unit: "m/s",
      shift: 16,
      type: "u16.16",
      storage: 4
    }],
    volatile: true,
    identifierName: "reading_error",
    packFormat: "u16.16"
  }, {
    kind: "const",
    name: "max_wind_speed",
    identifier: 261,
    description: "Maximum speed that can be measured by the sensor.",
    fields: [{
      name: "_",
      unit: "m/s",
      shift: 16,
      type: "u16.16",
      storage: 4
    }],
    optional: true,
    identifierName: "max_reading",
    packFormat: "u16.16"
  }],
  tags: ["8bit"]
}];
var deviceRegistryData = [{
  id: "microsoft-research-jacdaccableextender38v10",
  name: "JacdacCableExtender ",
  company: "Microsoft Research",
  repo: "",
  services: [],
  productIdentifiers: [928595161],
  version: "1.0",
  designIdentifier: "38",
  status: "experimental"
}, {
  id: "microsoft-research-jacdacjoystick440344v03",
  name: "JacdacJoystick 44-0.3",
  company: "Microsoft Research",
  link: "https://github.com/microsoft/jacdac-padauk",
  services: [277836886],
  productIdentifiers: [832285283],
  version: "0.3",
  designIdentifier: "44",
  status: "experimental"
}, {
  id: "microsoft-research-jacdacmicrobitshieldlp29v03",
  name: "JacDacMicroBitShieldLP",
  company: "Microsoft Research",
  repo: "",
  services: [],
  productIdentifiers: [1009620586],
  version: "0.3",
  designIdentifier: "29",
  status: "experimental"
}, {
  id: "microsoft-research-jacdacmotiondetection54v01",
  name: "JacdacMotionDetection ",
  company: "Microsoft Research",
  link: "https://github.com/microsoft/jacdac-padauk",
  services: [293185353],
  productIdentifiers: [1030407429],
  version: "0.1",
  designIdentifier: "54",
  status: "experimental"
}, {
  id: "microsoft-research-jacdacpinheaders45v02",
  name: "JacdacPinHeaders ",
  company: "Microsoft Research",
  repo: "",
  services: [],
  productIdentifiers: [970939382],
  version: "0.2",
  designIdentifier: "45",
  status: "experimental"
}, {
  id: "microsoft-research-jacdactouchtest35v10",
  name: "JacdacTouchTest",
  company: "Microsoft Research",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  services: [677752265],
  productIdentifiers: [933677864],
  version: "1.0",
  designIdentifier: "35",
  status: "experimental"
}, {
  id: "microsoft-research-jacdactouchtestelectrode36v10",
  name: "JacdacTouchTestElectrode",
  company: "Microsoft Research",
  repo: "",
  services: [677752265],
  productIdentifiers: [1026187559],
  version: "1.0",
  designIdentifier: "36",
  status: "experimental"
}, {
  id: "microsoft-research-jmaccelerometer30v02",
  name: "JM Accelerometer",
  company: "Microsoft Research",
  description: "",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [521405449],
  productIdentifiers: [872001670],
  version: "0.2",
  designIdentifier: "30",
  status: "deprecated"
}, {
  id: "microsoft-research-jmaccelerometer30v10",
  name: "JM Accelerometer",
  company: "Microsoft Research",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  services: [521405449],
  productIdentifiers: [952491663],
  tags: ["kit"],
  version: "1.0",
  designIdentifier: "30"
}, {
  id: "microsoft-research-jmaccelerometerv20",
  name: "JM Accelerometer v2.0",
  company: "Microsoft Research",
  description: "A 3-axis accelerometer. 16G range.",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [521405449],
  productIdentifiers: [1020174761],
  status: "deprecated"
}, {
  id: "microsoft-research-jmaccessswitchinput34v13",
  name: "JM Access Switch Input",
  company: "Microsoft Research",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  services: [343122531, 522667846, 277836886],
  productIdentifiers: [964964313],
  tags: ["kit"],
  version: "1.3",
  designIdentifier: "34"
}, {
  id: "microsoft-research-jmaccessswitchoutputv11",
  name: "JM Access Switch Output",
  company: "Microsoft Research",
  description: "",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [406840918],
  productIdentifiers: [942325999],
  tags: ["kit"],
  version: "1.1"
}, {
  id: "microsoft-research-jmambientlight55v01",
  name: "JM Ambient Light",
  company: "Microsoft Research",
  description: "",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [400333340],
  productIdentifiers: [896864987],
  tags: ["kit"],
  version: "0.1",
  designIdentifier: "55"
}, {
  id: "microsoft-research-jmanalogjoystick44v02",
  name: "JM Analog Joystick",
  company: "Microsoft Research",
  description: "",
  link: "https://github.com/microsoft/jacdac-padauk",
  services: [277836886],
  productIdentifiers: [976429228],
  tags: ["kit"],
  version: "0.2",
  designIdentifier: "44"
}, {
  id: "microsoft-research-jmarcadebtnv20",
  name: "JM ArcadeBtn v2.0",
  company: "Microsoft Research",
  description: "Lets you connect a single arcade button with an LED.",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [343122531],
  productIdentifiers: [886919574],
  status: "deprecated"
}, {
  id: "microsoft-research-jmarcadecontrolsv20",
  name: "JM Arcade Controls v2.0",
  company: "Microsoft Research",
  description: "Lets you connect arcade buttons and joystick to a Jacdac network.",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [501915758],
  productIdentifiers: [954450524],
  status: "deprecated"
}, {
  id: "microsoft-research-jmbrainesp3248v02",
  name: "JM Brain ESP32",
  company: "Microsoft Research",
  repo: "https://github.com/microsoft/pxt-jacdac/",
  services: [342028028],
  productIdentifiers: [],
  transport: "serial",
  version: "0.2",
  designIdentifier: "48",
  status: "deprecated"
}, {
  id: "microsoft-research-jmbrainesp3248v03",
  name: "JM Brain ESP32",
  company: "Microsoft Research",
  repo: "https://github.com/microsoft/pxt-jacdac/",
  services: [342028028],
  productIdentifiers: [917230668],
  transport: "serial",
  version: "0.3",
  designIdentifier: "48",
  status: "experimental"
}, {
  id: "microsoft-research-jmbrainf441v02",
  name: "JM Brain F4",
  company: "Microsoft Research",
  description: "",
  link: "https://github.com/microsoft/pxt-jacdac",
  services: [414210922, 411425820],
  productIdentifiers: [1003209864, 970267564],
  tags: ["kit"],
  firmwares: [{
    name: "HID Keyboard + Mouse",
    url: "https://github.com/microsoft/pxt-jacdac/releases/latest/download/hid-servers-f4.uf2"
  }],
  version: "0.2",
  designIdentifier: "41"
}, {
  id: "microsoft-research-jmbrainrp204059v01",
  name: "JM Brain RP2040",
  company: "Microsoft Research",
  description: "",
  link: "https://github.com/microsoft/pxt-jacdac",
  services: [414210922, 411425820],
  productIdentifiers: [884301483, 999933064],
  tags: ["kit"],
  firmwares: [{
    name: "HID Keyboard + Mouse",
    url: "https://github.com/microsoft/pxt-jacdac/releases/latest/download/hid-servers-rp2040.uf2"
  }],
  version: "0.1",
  designIdentifier: "59"
}, {
  id: "microsoft-research-jmbutton10v13",
  name: "JM Button",
  company: "Microsoft Research",
  description: "",
  link: "https://github.com/microsoft/jacdac-padauk",
  services: [343122531],
  productIdentifiers: [896566497],
  tags: ["kit"],
  version: "1.3",
  designIdentifier: "10"
}, {
  id: "microsoft-research-jmbutton40v02",
  name: "JM Button",
  company: "Microsoft Research",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  services: [343122531],
  productIdentifiers: [946173966],
  tags: ["kit"],
  version: "0.2",
  designIdentifier: "40"
}, {
  id: "microsoft-research-jmbuttonterminal62v01",
  name: "JM Button Terminal",
  company: "Microsoft Research",
  description: "",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [343122531],
  productIdentifiers: [1047530059],
  tags: ["kit"],
  version: "0.1",
  designIdentifier: "62"
}, {
  id: "microsoft-research-jmbuzzerv20",
  name: "JM Buzzer v2.0",
  company: "Microsoft Research",
  description: "A simple buzzer.",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [458731991],
  productIdentifiers: [854957595],
  status: "deprecated"
}, {
  id: "microsoft-research-jmclickairquality4v32",
  name: "JM-Click Airquality4",
  company: "Microsoft Research",
  description: "",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [379362758, 312849815],
  productIdentifiers: [878106432],
  tags: ["kit"],
  version: "3.2"
}, {
  id: "microsoft-research-jmclickcolorv32",
  name: "JM-Click Color",
  company: "Microsoft Research",
  description: "",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [372299111],
  productIdentifiers: [1020991645],
  tags: ["kit"],
  version: "3.2"
}, {
  id: "microsoft-research-jmcrankbuttonv20",
  name: "JM Crank + Button",
  company: "Microsoft Research",
  description: "A rotary encoder with a push button.",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [284830153, 343122531],
  productIdentifiers: [813927310],
  version: "2.0",
  status: "deprecated"
}, {
  id: "microsoft-research-jmcrankv20",
  name: "JM Crank",
  company: "Microsoft Research",
  description: "A rotary encoder without a push button.",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [284830153],
  productIdentifiers: [866678795],
  version: "2.0",
  status: "deprecated"
}, {
  id: "microsoft-research-jmflexv10",
  name: "JM Flex",
  company: "Microsoft Research",
  description: "",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [524797638],
  productIdentifiers: [840841542],
  tags: ["kit"],
  version: "1.0"
}, {
  id: "microsoft-research-jmgamepadv20",
  name: "JM GamePad",
  company: "Microsoft Research",
  description: "Lets you convert a plastic d-pad controller, so that it can be connected to a Jacdac network.",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [501915758],
  productIdentifiers: [919754666],
  version: "2.0"
}, {
  id: "microsoft-research-jmhapticmach101v10",
  name: "JM Haptic MACH-1.0",
  company: "Microsoft Research",
  description: "JM Haptic MACH-1.0",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  services: [406832290],
  productIdentifiers: [1022649261],
  version: "1.0",
  designIdentifier: "1"
}, {
  id: "microsoft-research-jmhub39v03",
  name: "JM Hub",
  company: "Microsoft Research",
  repo: "",
  services: [],
  productIdentifiers: [917230668],
  version: "0.3",
  designIdentifier: "39",
  status: "experimental"
}, {
  id: "microsoft-research-jmkeyboardkey46v10",
  name: "JM Keyboard Key",
  company: "Microsoft Research",
  description: "",
  link: "https://github.com/microsoft/jacdac-padauk",
  services: [343122531],
  productIdentifiers: [1067229774],
  tags: ["kit"],
  version: "1.0",
  designIdentifier: "46",
  status: "deprecated"
}, {
  id: "microsoft-research-jmkeyboardkey46v11",
  name: "JM Keyboard Key",
  company: "Microsoft Research",
  description: "",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [343122531],
  productIdentifiers: [911541523],
  tags: ["kit"],
  version: "1.1",
  designIdentifier: "46",
  status: "deprecated"
}, {
  id: "microsoft-research-jmkeyboardkey46v12",
  name: "JM Keyboard Key",
  company: "Microsoft Research",
  link: "https://github.com/microsoft/jacdac-padauk",
  services: [343122531],
  productIdentifiers: [876567534],
  tags: [],
  version: "1.2",
  designIdentifier: "46"
}, {
  id: "microsoft-research-jmmachinelearning",
  name: "JM Machine Learning",
  company: "Microsoft Research",
  description: "Lets you run machine learning models on data coming from Jacdac network.",
  repo: "https://github.com/microsoft/pxt-tensorflow",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [336566904, 496034245],
  productIdentifiers: [],
  status: "deprecated"
}, {
  id: "microsoft-research-jmmicrobitshieldlp29v05",
  name: "JM MicroBit Shield LP",
  company: "Microsoft Research",
  repo: "",
  services: [],
  productIdentifiers: [974031363],
  version: "0.5",
  designIdentifier: "29",
  status: "experimental"
}, {
  id: "microsoft-research-jmmotorv21",
  name: "JM Motor",
  company: "Microsoft Research",
  description: "Lets you control a single DC motor (up to 5V; yellow plastic ones work well).",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [385895640],
  productIdentifiers: [809626198],
  version: "2.1",
  status: "deprecated"
}, {
  id: "microsoft-research-jmpinheader45v01",
  name: "JM Pin Header",
  company: "Microsoft Research",
  description: "A unregulated passive adapter from Jacdac to pin headers.",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [],
  productIdentifiers: [939230090],
  version: "0.1",
  designIdentifier: "45",
  status: "deprecated"
}, {
  id: "microsoft-research-jmpinheader45v02",
  name: "JM Pin Header",
  company: "Microsoft Research",
  description: "A regulated passive adapter from Jacdac to pin headers.",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [],
  productIdentifiers: [994328823],
  version: "0.2",
  designIdentifier: "45"
}, {
  id: "microsoft-research-jmpower",
  name: "JM Power",
  company: "Microsoft Research",
  description: "Lets you supply power to Jacdac network from a MicroUSB connection (eg. a USB battery pack).",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [530893146],
  productIdentifiers: [815885628],
  status: "deprecated"
}, {
  id: "microsoft-research-jmprotov20",
  name: "JM Proto",
  company: "Microsoft Research",
  description: "A prototype multi-function board.\n* ``0x3f9bc26a`` JM Touch-Proto v2.0",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [],
  productIdentifiers: [1052138004],
  version: "2.0",
  status: "deprecated"
}, {
  id: "microsoft-research-jmpwmnpxv20",
  name: "JM PWM (npx)",
  company: "Microsoft Research",
  description: "A light-strip controller. Supports WS2812B, APA102, and SK9822.",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [309264608],
  productIdentifiers: [895762065],
  version: "2.0",
  status: "deprecated"
}, {
  id: "microsoft-research-jmpwmnpxv21",
  name: "JM PWM (npx)",
  company: "Microsoft Research",
  description: "A light-strip controller with MicroUSB connector for power. Supports WS2812B, APA102, and SK9822.",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [309264608],
  productIdentifiers: [1013705700],
  version: "2.1",
  status: "deprecated"
}, {
  id: "microsoft-research-jmpwmservov20",
  name: "JM PWM (Servo)",
  company: "Microsoft Research",
  description: "A controller for a 5V servo.",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [318542083],
  productIdentifiers: [816890446],
  version: "2.0",
  status: "deprecated"
}, {
  id: "microsoft-research-jmpwmservov21",
  name: "JM PWM (Servo)",
  company: "Microsoft Research",
  description: "A controller for a 5V servo, with MicroUSB connector for power.",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [318542083],
  productIdentifiers: [986140247],
  version: "2.1",
  status: "deprecated"
}, {
  id: "microsoft-research-jmrgbledbar58v01",
  name: "JM RGB LED Bar",
  company: "Microsoft Research",
  description: "",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [309264608],
  productIdentifiers: [1046525691],
  tags: ["kit"],
  version: "0.1",
  designIdentifier: "58"
}, {
  id: "microsoft-research-jmrgbledgeneric60v01",
  name: "JM RGB LED Generic",
  company: "Microsoft Research",
  description: "",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [309264608],
  productIdentifiers: [967723905],
  tags: ["kit"],
  version: "0.1",
  designIdentifier: "60"
}, {
  id: "microsoft-research-jmrgbledring37v21",
  name: "JM RGB LED Ring",
  company: "Microsoft Research",
  description: "",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [309264608],
  productIdentifiers: [807926135],
  tags: ["kit"],
  version: "2.1",
  designIdentifier: "37"
}, {
  id: "microsoft-research-jmrotarycontrolbuttonv10",
  name: "JM Rotary Control + Button",
  company: "Microsoft Research",
  description: "",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [284830153, 343122531],
  productIdentifiers: [1060754715],
  tags: ["kit"],
  version: "1.0"
}, {
  id: "microsoft-research-jmsinglergbled42v01",
  name: "JM Single RGB LED",
  company: "Microsoft Research",
  description: "",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [506480888],
  productIdentifiers: [917828732],
  tags: ["kit"],
  version: "0.1",
  designIdentifier: "42"
}, {
  id: "microsoft-research-jmslider49v10",
  name: "JM Slider",
  company: "Microsoft Research",
  description: "",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [522667846],
  productIdentifiers: [981005156],
  version: "1.0",
  designIdentifier: "49",
  status: "deprecated"
}, {
  id: "microsoft-research-jmslider49v11",
  name: "JM Slider",
  company: "Microsoft Research",
  description: "",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [522667846],
  productIdentifiers: [966423091],
  tags: ["kit"],
  version: "1.1",
  designIdentifier: "49"
}, {
  id: "microsoft-research-jmsliderv20",
  name: "JM Slider",
  company: "Microsoft Research",
  description: "A linear potentiometer (slider).",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [522667846],
  productIdentifiers: [1043615261],
  version: "2.0",
  status: "deprecated"
}, {
  id: "microsoft-research-jmspeechsynthesis61v33",
  name: "JM Speech Synthesis",
  company: "Microsoft Research",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  services: [302307733],
  productIdentifiers: [934541191],
  version: "3.3",
  designIdentifier: "61"
}, {
  id: "microsoft-research-jmtemperaturehumidity18v10a",
  name: "JM Temperature + Humidity",
  company: "Microsoft Research",
  description: "",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [337754823, 382210232],
  productIdentifiers: [899442616],
  version: "1.0A",
  designIdentifier: "18",
  status: "deprecated"
}, {
  id: "microsoft-research-jmtemperaturehumidity18v11",
  name: "JM Temperature + Humidity",
  company: "Microsoft Research",
  description: "",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [337754823, 382210232],
  productIdentifiers: [827772887],
  tags: ["kit"],
  version: "1.1",
  designIdentifier: "18"
}, {
  id: "microsoft-research-jmtouchprotov20",
  name: "JM Touch-Proto",
  company: "Microsoft Research",
  description: "A multi-touch sensor based on proto board.",
  repo: "https://github.com/microsoft/jacdac-msr-modules",
  link: "https://github.com/microsoft/jacdac-msr-modules",
  services: [416636459],
  productIdentifiers: [1067172458],
  version: "2.0",
  status: "deprecated"
}, {
  id: "microsoft-research-mikrobuscarrierboard53v01",
  name: "MikrobusCarrierBoard",
  company: "Microsoft Research",
  repo: "",
  services: [],
  productIdentifiers: [961789360],
  version: "0.1",
  designIdentifier: "53",
  status: "experimental"
}, {
  id: "microbit-foundation-microbitv2",
  name: "micro:bit V2",
  company: "microbit foundation",
  description: "The new micro:bit V2 has a built-in microphone and speaker to allow sound-sensing and sound-making without the need to attach another device. It also introduces capacitive touch sensing, a power-saving mode and more computing power for the classroom.",
  link: "https://microsoft.github.io/jacdac-docs/hardware/kit/oob/",
  services: [],
  productIdentifiers: [854992189],
  transport: "usb",
  tags: ["kit"],
  firmwares: [{
    name: "Kit Out-Of-the-Box Experience",
    url: "https://github.com/microsoft/pxt-jacdac/releases/latest/download/microbit-oob.hex"
  }]
}]; // eslint-disable-next-line @typescript-eslint/triple-slash-reference
// eslint-disable-next-line @typescript-eslint/no-explicit-any

let _serviceSpecifications = serviceSpecificationData;
let _serviceSpecificationMap = undefined;
let _customServiceSpecifications = {}; // eslint-disable-next-line @typescript-eslint/no-explicit-any

const _deviceRegistry = deviceRegistryData;
/**
 * Override built-in service specifications
 * @param specs
 * @category Specification
 */

function loadServiceSpecifications(specs) {
  _serviceSpecifications = (specs === null || specs === void 0 ? void 0 : specs.slice(0)) || [];
  _serviceSpecificationMap = undefined;
}
/**
 * Adds a custom service specification
 * @param service
 * @category Specification
 */


function addCustomServiceSpecification(service) {
  if (service && service.classIdentifier) {
    _customServiceSpecifications[service.classIdentifier] = service;
    _serviceSpecificationMap = undefined;
  }
}
/**
 * Clears any custom service specification
 * @category Specification
 */


function clearCustomServiceSpecifications() {
  _customServiceSpecifications = {};
  _serviceSpecificationMap = undefined;
}
/**
 * Returns a map from service short ids to service specifications
 * @category Specification
 */


function serviceMap() {
  const m = {};

  _serviceSpecifications.forEach(spec => m[spec.shortId] = spec);

  return m;
}
/**
 * Returns the list of service specifications
 * @category Specification
 */


function serviceSpecifications() {
  return _serviceSpecifications.slice(0);
}
/**
 * Resolve the device specification from the product identiier
 * @category Specification
 */


function deviceSpecificationFromProductIdentifier(productIdentifier) {
  if (isNaN(productIdentifier)) return undefined;

  const spec = _deviceRegistry.find(spec => {
    var _a;

    return ((_a = spec.productIdentifiers) === null || _a === void 0 ? void 0 : _a.indexOf(productIdentifier)) > -1;
  });

  return spec;
}
/**
 * @internal
 */


function deviceSpecificationFromIdentifier(id) {
  if (id === undefined) return undefined;

  const spec = _deviceRegistry.find(spec => spec.id === id);

  return spec;
}
/**
 * Gets the list of devices that use this service class
 * @param serviceClass
 * @category Specification
 */


function deviceSpecificationsForService(serviceClass) {
  if (isNaN(serviceClass)) return undefined;
  return _deviceRegistry.filter(spec => {
    var _a;

    return ((_a = spec.services) === null || _a === void 0 ? void 0 : _a.indexOf(serviceClass)) > -1;
  });
}
/**
 * Gets the list of device specifications
 * @returns
 * @category Specification
 */


function deviceSpecifications(options) {
  const {
    includeDeprecated,
    includeExperimental
  } = options || {};

  let r = _deviceRegistry.slice(0);

  if (!includeDeprecated) r = r.filter(d => d.status !== "deprecated");
  if (!includeExperimental) r = r.filter(d => d.status !== "experimental");
  return r;
}
/**
 * @internal
 */


function identifierToUrlPath(id) {
  // compiled web site does not like . in path
  return id === null || id === void 0 ? void 0 : id.replace(/-/g, "/").replace(/\./g, "").toLowerCase();
}
/**
 * Checks if classIdentifier is compatible with requiredClassIdentifier
 * @category Specification
 */


function isInstanceOf(classIdentifier, requiredClassIdentifier) {
  var _a; // garbage data


  if (isNaN(classIdentifier)) return false; // direct hit

  if (classIdentifier === requiredClassIdentifier) return true; // lookup inheritance chain

  const classSpec = serviceSpecificationFromClassIdentifier(classIdentifier);
  return !!((_a = classSpec === null || classSpec === void 0 ? void 0 : classSpec.extends) === null || _a === void 0 ? void 0 : _a.some(extend => {
    const extendSpec = serviceSpecificationFromName(extend);
    return !!extendSpec && isInstanceOf(extendSpec.classIdentifier, requiredClassIdentifier);
  }));
}
/**
 * Checks if the service supports the Jacdac infrastructure
 * @param spec
 * @returns
 * @category Specification
 */


function isInfrastructure(spec) {
  return spec && ([SRV_CONTROL, SRV_ROLE_MANAGER, SRV_LOGGER, SRV_SETTINGS, SRV_BOOTLOADER, SRV_PROTO_TEST, SRV_INFRASTRUCTURE].indexOf(spec.classIdentifier) > -1 || spec.shortId[0] === "_");
}
/**
 * Looks up a service specification by name
 * @param shortId
 * @category Specification
 */


function serviceSpecificationFromName(shortId) {
  if (!shortId) return undefined;
  return _serviceSpecifications.find(s => s.shortId === shortId) || Object.values(_customServiceSpecifications).find(ser => ser.shortId === shortId);
}
/**
 * Looks up a service specification by class
 * @param classIdentifier
 * @category Specification
 */


function serviceSpecificationFromClassIdentifier(classIdentifier) {
  if (isNaN(classIdentifier)) return undefined; // try lookup cache

  let srv = _serviceSpecificationMap === null || _serviceSpecificationMap === void 0 ? void 0 : _serviceSpecificationMap[classIdentifier];
  if (srv) return srv; // resolve

  srv = _serviceSpecifications.find(s => s.classIdentifier === classIdentifier) || _customServiceSpecifications[classIdentifier];

  if (srv) {
    if (!_serviceSpecificationMap) _serviceSpecificationMap = {};
    _serviceSpecificationMap[classIdentifier] = srv;
  }

  return srv;
}
/**
 * Indicates if the specified service is a sensor
 * @param spec
 * @returns
 * @category Specification
 */


function isSensor(spec) {
  return spec && spec.packets.some(pkt => isReading(pkt)) && spec.packets.some(pkt => pkt.identifier == exports.SensorReg.StreamingSamples) && spec.packets.some(pkt => pkt.identifier == exports.SensorReg.StreamingInterval);
}
/**
 * Indicates if the specified service is an actuator
 * @param spec
 * @returns
 * @category Specification
 */


function isActuator(spec) {
  return spec && spec.packets.some(pkt => pkt.identifier === exports.SystemReg.Value) && spec.packets.some(pkt => pkt.identifier === exports.SystemReg.Intensity);
}
/**
 * Indicates if the packet information is a register
 * @param spec
 * @returns
 * @category Specification
 */


function isRegister(pkt) {
  return pkt && (pkt.kind == "const" || pkt.kind == "ro" || pkt.kind == "rw");
}
/**
 * Indicates if the packet information is a ``reading`` register
 * @param spec
 * @returns
 * @category Specification
 */


function isReading(pkt) {
  return pkt && pkt.kind == "ro" && pkt.identifier == exports.SystemReg.Reading;
}

const ignoredRegister = [exports.SystemReg.StatusCode, exports.SystemReg.InstanceName, exports.SystemReg.StreamingInterval, exports.SystemReg.StreamingPreferredInterval, exports.SystemReg.StreamingSamples, exports.SystemReg.ReadingError, exports.SystemReg.ReadingResolution, exports.SystemReg.MinReading, exports.SystemReg.MaxReading, exports.SystemReg.MinValue, exports.SystemReg.MaxValue, exports.SystemReg.MaxPower];
/**
 * Indicates if the register is usable from a high-level programming environment.
 * @category Specification
 */

function isHighLevelRegister(pkt) {
  return isRegister(pkt) && !pkt.lowLevel && !pkt.internal && ignoredRegister.indexOf(pkt.identifier) < 0;
}

const ignoredEvents = [exports.SystemEvent.StatusCodeChanged];
/**
 * Indicates if the event is usable from a high-level programming environment.
 * @category Specification
 */

function isHighLevelEvent(pkt) {
  return isEvent(pkt) && !pkt.lowLevel && !pkt.internal && ignoredEvents.indexOf(pkt.identifier) < 0;
}
/**
 * Indicate if the register code is an auxilliary register to support streaming.
 * @param code
 * @returns
 * @category Specification
 */


function isOptionalReadingRegisterCode(code) {
  const regs = [exports.SystemReg.MinReading, exports.SystemReg.MaxReading, exports.SystemReg.ReadingError, exports.SystemReg.ReadingResolution, exports.SystemReg.StreamingPreferredInterval];
  return regs.indexOf(code) > -1;
}
/**
 * Indicates if the packet info represents an ``intensity`` register
 * @category Specification
 */


function isIntensity(pkt) {
  return pkt && pkt.kind == "rw" && pkt.identifier == exports.SystemReg.Intensity;
}
/**
 * Indicates if the packet info represents a ``value`` register
 * @category Specification
 */


function isValue(pkt) {
  return pkt && pkt.kind == "rw" && pkt.identifier == exports.SystemReg.Value;
}
/**
 * Indicates if the packet info represents a ``intensity`` or a ``value`` register
 * @category Specification
 */


function isValueOrIntensity(pkt) {
  return pkt && pkt.kind == "rw" && (pkt.identifier == exports.SystemReg.Value || pkt.identifier == exports.SystemReg.Intensity);
}
/**
 * Indicates if the packet info represents an ``const`` register
 * @category Specification
 */


function isConstRegister(pkt) {
  return (pkt === null || pkt === void 0 ? void 0 : pkt.kind) == "const";
}
/**
 * Indicates if the packet info represents an ``event``
 * @category Specification
 */


function isEvent(pkt) {
  return pkt.kind == "event";
}
/**
 * Indicates if the packet info represents a ``command``
 * @category Specification
 */


function isCommand(pkt) {
  return pkt.kind == "command";
}
/**
 * Indicates if the packet info represents a ``pipe_report``
 * @category Specification
 */


function isPipeReport(pkt) {
  return pkt.kind == "pipe_report";
}
/**
 * Indicates if the `report` packet is the report specication of the `cmd` command.
 * @category Specification
 */


function isReportOf(cmd, report) {
  return report.secondary && report.kind == "report" && cmd.kind == "command" && cmd.name == report.name;
}
/**
 * Indicates if the `report` packet is the *pipe* report specication of the `cmd` command.
 * @category Specification
 */


function isPipeReportOf(cmd, pipeReport) {
  return pipeReport.kind == "pipe_report" && cmd.kind == "command" && cmd.pipeType && cmd.pipeType === pipeReport.pipeType;
}
/**
 * @internal
 */


function isIntegerType(tp) {
  return /^[ui]\d+(\.|$)/.test(tp) || tp == "pipe_port" || tp == "bool";
}
/**
 * @internal
 */


function numberFormatFromStorageType(tp) {
  switch (tp) {
    case -1:
      return exports.NumberFormat.Int8LE;

    case 1:
      return exports.NumberFormat.UInt8LE;

    case -2:
      return exports.NumberFormat.Int16LE;

    case 2:
      return exports.NumberFormat.UInt16LE;

    case -4:
      return exports.NumberFormat.Int32LE;

    case 4:
      return exports.NumberFormat.UInt32LE;

    case -8:
      return exports.NumberFormat.Int64LE;

    case 8:
      return exports.NumberFormat.UInt64LE;

    case 0:
      return null;

    default:
      return null;
  }
}
/**
 * @internal
 */


function numberFormatToStorageType(nf) {
  switch (nf) {
    case exports.NumberFormat.Int8LE:
      return -1;

    case exports.NumberFormat.UInt8LE:
      return 1;

    case exports.NumberFormat.Int16LE:
      return -2;

    case exports.NumberFormat.UInt16LE:
      return 2;

    case exports.NumberFormat.Int32LE:
      return -4;

    case exports.NumberFormat.UInt32LE:
      return 4;

    case exports.NumberFormat.Int64LE:
      return -8;

    case exports.NumberFormat.UInt64LE:
      return 8;

    default:
      return null;
  }
}
/**
 * @internal
 */


function scaleIntToFloat(v, info) {
  if (!info.shift) return v;
  if (info.shift < 0) return v * (1 << -info.shift);else return v / (1 << info.shift);
}
/**
 * @internal
 */


function scaleFloatToInt(v, info) {
  if (!info.shift) return v;
  if (info.shift < 0) return Math.round(v / (1 << -info.shift));else return Math.round(v * (1 << info.shift));
}
/**
 * @internal
 */


function storageTypeRange(tp) {
  if (tp == 0) throw new Error("no range for 0");

  if (tp < 0) {
    const v = Math.pow(2, -tp * 8 - 1);
    return [-v, v - 1];
  } else {
    const v = Math.pow(2, tp * 8);
    return [0, v - 1];
  }
}
/**
 * @internal
 */


function clampToStorage(v, tp) {
  const [min, max] = storageTypeRange(tp);
  if (isNaN(v)) return 0;
  if (v < min) return min;
  if (v > max) return max;
  return v;
}
/**
 * @internal
 */


function memberValueToString(value, info) {
  if (value === undefined || value === null) return "";

  switch (info.type) {
    case "bytes":
      return toHex(value);

    case "string":
      return value;

    default:
      return "" + value;
  }
}
/**
 * @internal
 */


function tryParseMemberValue(text, info) {
  if (!text) return {};
  if (info.type === "string") return {
    value: text
  };else if (info.type === "pipe") return {}; // not supported
  else if (info.type === "bytes") {
    try {
      return {
        value: fromHex(text)
      };
    } catch (e) {
      return {
        error: "invalid hexadecimal format"
      };
    }
  } else {
    const n = isIntegerType(info.type) ? parseInt(text) : parseFloat(text);
    if (isNaN(n)) return {
      error: "invalid format"
    };else return {
      value: n
    };
  }
}
/**
 * Parses a device identifier into a buffer, returns undefined if invalid
 * @param id
 * @returns
 * @category Specification
 */


function parseDeviceId(id) {
  if (!id) return undefined;
  id = id.replace(/\s/g, "");
  if (id.length != 16 || !/^[a-f0-9]+$/i.test(id)) return undefined;
  return fromHex(id);
} // ASCII codes of characters


const ch_b = 98;
const ch_i = 105;
const ch_r = 114;
const ch_s = 115;
const ch_u = 117;
const ch_x = 120;
const ch_z = 122; //const ch_0 = 48
//const ch_9 = 57

const ch_colon = 58;
const ch_sq_open = 91;
const ch_sq_close = 93;

function numberFormatOfType(tp) {
  switch (tp) {
    case "u8":
      return exports.NumberFormat.UInt8LE;

    case "u16":
      return exports.NumberFormat.UInt16LE;

    case "u32":
      return exports.NumberFormat.UInt32LE;

    case "i8":
      return exports.NumberFormat.Int8LE;

    case "i16":
      return exports.NumberFormat.Int16LE;

    case "i32":
      return exports.NumberFormat.Int32LE;

    case "f32":
      return exports.NumberFormat.Float32LE;

    case "f64":
      return exports.NumberFormat.Float64LE;

    case "i64":
      return exports.NumberFormat.Int64LE;

    case "u64":
      return exports.NumberFormat.UInt64LE;

    default:
      return null;
  }
}

function bufferSlice(buf, start, end) {
  return buf.slice(start, end);
}

class TokenParser {
  constructor(fmt) {
    this.fmt = fmt;
    this.fp = 0;
  }

  parse() {
    this.div = 1;
    this.isArray = false;
    const fmt = this.fmt;

    while (this.fp < fmt.length) {
      let endp = this.fp;

      while (endp < fmt.length && fmt.charCodeAt(endp) != 32) endp++;

      let word = fmt.slice(this.fp, endp);
      this.fp = endp + 1;
      if (!word) continue;
      const dotIdx = word.indexOf(".");
      let c0 = word.charCodeAt(0); // "u10.6" -> "u16", div = 1 << 6

      if ((c0 == ch_i || c0 == ch_u) && dotIdx >= 0) {
        const sz0 = parseInt(word.slice(1, dotIdx));
        const sz1 = parseInt(word.slice(dotIdx + 1));
        word = word[0] + (sz0 + sz1);
        this.div = 1 << sz1;
      }

      const c1 = word.charCodeAt(1);

      if (c1 == ch_sq_open) {
        this.size = parseInt(word.slice(2));
      } else {
        this.size = -1;
      }

      if (word.charCodeAt(word.length - 1) == ch_sq_close && word.charCodeAt(word.length - 2) == ch_sq_open) {
        word = word.slice(0, -2);
        this.isArray = true;
      }

      this.nfmt = numberFormatOfType(word);
      this.word = word;

      if (this.nfmt == null) {
        if (c0 == ch_r) {
          if (c1 != ch_colon) c0 = 0;
        } else if (c0 == ch_s || c0 == ch_b || c0 == ch_x) {
          if (word.length != 1 && this.size == -1) c0 = 0;
        } else if (c0 == ch_z) {
          if (word.length != 1) c0 = 0;
        } else {
          c0 = 0;
        }

        if (c0 == 0) throw new Error(`invalid format: ${word}`);
        this.c0 = c0;
      } else {
        this.size = sizeOfNumberFormat(this.nfmt);
        this.c0 = -1;
      }

      return true;
    }

    return false;
  }

}

function jdunpackCore(buf, fmt, repeat) {
  const repeatRes = repeat ? [] : null;
  let res = [];
  let off = 0;
  let fp0 = 0;
  const parser = new TokenParser(fmt);
  if (repeat && buf.length == 0) return [];

  while (parser.parse()) {
    if (parser.isArray && !repeat) {
      res.push(jdunpackCore(bufferSlice(buf, off, buf.length), fmt.slice(fp0), 1));
      return res;
    }

    fp0 = parser.fp;
    let sz = parser.size;
    const c0 = parser.c0;

    if (c0 == ch_z) {
      let endoff = off;

      while (endoff < buf.length && buf[endoff] != 0) endoff++;

      sz = endoff - off;
    } else if (sz < 0) {
      sz = buf.length - off;
    }

    if (parser.nfmt !== null) {
      let v = getNumber(buf, parser.nfmt, off);
      if (parser.div != 1) v /= parser.div;
      res.push(v);
      off += parser.size;
    } else {
      const subbuf = bufferSlice(buf, off, off + sz);

      if (c0 == ch_z || c0 == ch_s) {
        let zerop = 0;

        while (zerop < subbuf.length && subbuf[zerop] != 0) zerop++;

        res.push(bufferToString(bufferSlice(subbuf, 0, zerop)));
      } else if (c0 == ch_b) {
        res.push(subbuf);
      } else if (c0 == ch_x) ;else if (c0 == ch_r) {
        res.push(jdunpackCore(subbuf, fmt.slice(fp0), 2));
        break;
      } else {
        throw new Error(`whoops`);
      }

      off += subbuf.length;
      if (c0 == ch_z) off++;
    }

    if (repeat && parser.fp >= fmt.length) {
      parser.fp = 0;

      if (repeat == 2) {
        repeatRes.push(res);
        res = [];
      }

      if (off >= buf.length) break;
    }
  }

  if (repeat == 2) {
    if (res.length) repeatRes.push(res);
    return repeatRes;
  } else {
    return res;
  }
}
/**
 Unpacks a byte buffer into structured data as specified in the format string.
 See jdpack for format string reference.
 @category Data Packing
*/


function jdunpack(buf, fmt) {
  if (!buf || !fmt) return undefined; // hot path for buffers

  if (fmt === "b") return [buf.slice(0)]; // hot path

  const nf = numberFormatOfType(fmt);

  if (nf !== null) {
    const sz = sizeOfNumberFormat(nf);
    if (buf.length < sz) throw new Error(`size mistmatch, expected ${fmt} (${sz} bytes), got ${buf.length}`);
    return [getNumber(buf, nf, 0)];
  } // slow path


  return jdunpackCore(buf, fmt, 0);
}

function jdpackCore(trg, fmt, data, off) {
  //console.log({ fmt, data })
  let idx = 0;
  const parser = new TokenParser(fmt);

  while (parser.parse()) {
    const c0 = parser.c0;

    if (c0 == ch_x) {
      // skip padding
      off += parser.size;
      continue;
    }

    const dataItem = data[idx++];

    if (c0 == ch_r && dataItem) {
      const fmt0 = fmt.slice(parser.fp);

      for (const velt of dataItem) {
        off = jdpackCore(trg, fmt0, velt, off);
      }

      break;
    } // use temporary variable to avoid a Gatsby build bug


    let arr;
    if (parser.isArray) arr = dataItem;else arr = [dataItem];

    for (const v of arr) {
      if (parser.nfmt !== null) {
        if (typeof v != "number") throw new Error(`expecting number, got ` + typeof v);

        if (trg) {
          const st = numberFormatToStorageType(parser.nfmt);
          setNumber(trg, parser.nfmt, off, clampToStorage(Math.round(v * parser.div), st));
        }

        off += parser.size;
      } else {
        let buf;

        if (typeof v === "string") {
          if (c0 == ch_z) buf = stringToBuffer(v + "\u0000");else if (c0 == ch_s) buf = stringToBuffer(v);else throw new Error(`unexpected string`);
        } else if (v && typeof v === "object" && v.length != null) {
          // assume buffer
          if (c0 == ch_b) buf = v;else throw new Error(`unexpected buffer`);
        } else {
          console.log({
            parser,
            v
          });
          throw new Error(`expecting string or buffer`);
        }

        let sz = parser.size;

        if (sz >= 0) {
          if (buf.length > sz) buf = bufferSlice(buf, 0, sz);
        } else {
          sz = buf.length;
        }

        if (trg) trg.set(buf, off);
        off += sz;
      }
    }
  }

  if (data.length > idx) throw new Error(`format '${fmt}' too short`);
  return off;
}
/**

* Format strings are space-separated sequences of type descriptions.
* All numbers are understood to be little endian.
* The following type descriptions are supported:
*
* - `u8`, `u16`, `u32` - unsigned, 1, 2, and 4 bytes long respectively
* - `i8`, `i16`, `i32` - similar, but signed
* - `b` - buffer until the end of input (has to be last)
* - `s` - similar, but utf-8 encoded string
* - `z` - NUL-terminated utf-8 string
* - `b[10]` - 10 byte buffer (10 is just an example, here and below)
* - `s[10]` - 10 byte utf-8 string; trailing NUL bytes (if any) are removed
* - `x[10]` - 10 bytes of padding
*
* There is one more token, `r:`. The type descriptions following it are repeated in order
* until the input buffer is exhausted.
* When unpacking, fields after `r:` are repeated as an array of tuples.
*
* In case there's only a single field repeating,
* it's also possible to append `[]` to its type, to get an array of values.
*
* @category Data Packing
*/


function jdpack(fmt, data) {
  var _a;

  if (!fmt || !data) return undefined; // hot path for buffers

  if (fmt === "b") return (_a = data[0]) === null || _a === void 0 ? void 0 : _a.slice(0); // hot path

  const nf = numberFormatOfType(fmt);

  if (nf !== null) {
    const buf = new Uint8Array(sizeOfNumberFormat(nf));
    setNumber(buf, nf, 0, data[0]);
    return buf;
  } // slow path


  const len = jdpackCore(null, fmt, data, 0);
  const res = new Uint8Array(len);
  jdpackCore(res, fmt, data, 0);
  return res;
}
/**
 * Checks if two packed values serialize to the same buffer
 * @param fmt packing format string
 * @param left left data
 * @param right right data
 * @returns true if both data serialize to the same buffer
 * @category Data Packing
 */


function jdpackEqual(fmt, left, right) {
  if (!left !== !right) return false;
  if (!left) return true;
  const leftBuffer = jdpack(fmt, left);
  const rightBuffer = jdpack(fmt, right);
  return bufferEq(leftBuffer, rightBuffer);
}
/** @internal */


exports.RegisterType = void 0;

(function (RegisterType) {
  RegisterType[RegisterType["UInt"] = 0] = "UInt";
  RegisterType[RegisterType["UIntHex"] = 1] = "UIntHex";
  RegisterType[RegisterType["Int"] = 2] = "Int";
  RegisterType[RegisterType["IntArray"] = 3] = "IntArray";
  RegisterType[RegisterType["String"] = 4] = "String";
})(exports.RegisterType || (exports.RegisterType = {}));

function prettyUnit(u) {
  switch (u) {
    case "us":
      return "μs";

    case "C":
    case "Cel":
      return "°C";

    case "K":
      return "°K";

    case "/":
    case "#":
      return "";

    default:
      return u;
  }
}

function prettyMemberUnit(specification, showDataType) {
  const parts = [prettyUnit(specification.unit), isSet(specification.typicalMin) && `[${specification.typicalMin}, ${specification.typicalMax}]`, isSet(specification.absoluteMin) && `absolute [${specification.absoluteMin}, ${specification.absoluteMax}]`].filter(f => isSet(f) && f);
  if (showDataType) parts.unshift(specification.type);
  const helperText = parts.join(", ");
  return helperText;
}

function prettySize(b) {
  b = b | 0;
  if (b < 1000) return b + "b";else if (b < 1000000) return roundWithPrecision(b / 1e3, 1) + "kb";else return roundWithPrecision(b / 1e6, 1) + "mb";
}

function prettyDuration(ms) {
  let s = ms / 1000;
  if (s < 1) return `${roundWithPrecision(s, 2)}s`;
  if (s < 10) return `${roundWithPrecision(s, 1)}s`;
  if (s < 60) return `${Math.floor(s)}s`;
  let r = "";
  const d = Math.floor(s / (24 * 3600));

  if (d > 0) {
    r += d + ":";
    s -= d * (24 * 3600);
  }

  const h = Math.floor(s / 3600);

  if (h > 0) {
    r += h + ":";
    s -= h * 3600;
  }

  const m = Math.floor(s / 60);

  if (d > 0 || h > 0 || m > 0) {
    r += m + ":";
    s -= m * 60;
  }

  r += Math.floor(s);
  return r;
}

function prettyMicroDuration(us) {
  if (us < 1000) return `${us}${prettyUnit("us")}`;else return prettyDuration(us / 1000);
} // 2 letter + 2 digit ID; 1.8%/0.3%/0.07%/0.015% collision probability among 50/20/10/5 devices


function shortDeviceId(devid) {
  const h = hash(fromHex(devid), 30);
  return String.fromCharCode(0x41 + h % 26) + String.fromCharCode(0x41 + idiv(h, 26) % 26) + String.fromCharCode(0x30 + idiv(h, 26 * 26) % 10) + String.fromCharCode(0x30 + idiv(h, 26 * 26 * 10) % 10);
}

function decodeMember(service, pktInfo, member, pkt, offset) {
  var _a;

  if (!member) return null;
  if (pkt.data.length <= offset) return null;
  let numValue = undefined;
  let scaledValue = undefined;
  let value = undefined;
  let humanValue = undefined;
  let size = Math.abs(member.storage);
  const enumInfo = service === null || service === void 0 ? void 0 : service.enums[member.type];
  const isInt = isIntegerType(member.type) || !!enumInfo;

  if (member.isFloat && (size == 4 || size == 8)) {
    if (size == 4) numValue = pkt.getNumber(exports.NumberFormat.Float32LE, offset);else numValue = pkt.getNumber(exports.NumberFormat.Float64LE, offset);
    value = scaledValue = numValue;
    if (Math.abs(value) < 10) humanValue = value.toFixed(5);else if (Math.abs(value) < 1000) humanValue = value.toFixed(3);else if (Math.abs(value) < 100000) humanValue = value.toFixed(2);else humanValue = "" + value;
    if (member.unit) humanValue += prettyUnit(member.unit);
  } else if (!isInt) {
    const buf = size ? pkt.data.slice(offset, offset + size) : pkt.data.slice(offset);

    if (member.type == "string") {
      try {
        value = fromUTF8(uint8ArrayToString(buf));
      } catch (_b) {
        // invalid UTF8
        value = uint8ArrayToString(buf);
      }

      humanValue = JSON.stringify(value).replace(/\\u0000/g, "\\0");
    } else if (member.type == "pipe") {
      value = buf;
      const devid = toHex(buf.slice(0, 8));
      const port = read16(buf, 8);
      humanValue = "pipe to " + shortDeviceId(devid) + " port:" + port; // + " [" + toHex(buf.slice(10)) + "]"

      if ((_a = pkt === null || pkt === void 0 ? void 0 : pkt.device) === null || _a === void 0 ? void 0 : _a.bus) {
        const trg = pkt.device.bus.device(devid, true);
        if (trg) trg.port(port).pipeType = (service === null || service === void 0 ? void 0 : service.shortId) + "." + pktInfo.pipeType + ".report";
      }
    } else {
      value = buf;
      humanValue = hexDump(buf);
    }

    size = buf.length;
  } else {
    const fmt = numberFormatFromStorageType(member.storage);
    numValue = pkt.getNumber(fmt, offset);
    value = scaledValue = scaleIntToFloat(numValue, member);
    if (pkt.device && member.type == "pipe_port") pkt.device.port(value).pipeType = (service === null || service === void 0 ? void 0 : service.shortId) + "." + pktInfo.pipeType + ".command";

    if (enumInfo) {
      if (enumInfo.isFlags) {
        humanValue = "";
        let curr = numValue;

        for (const key of Object.keys(enumInfo.members)) {
          const val = enumInfo.members[key];

          if ((curr & val) == val) {
            if (humanValue) humanValue += " | ";
            humanValue += key;
            curr &= ~val;
          }
        }

        if (curr) {
          if (humanValue) humanValue += " | ";
          humanValue += hexNum(curr);
        }
      } else {
        humanValue = reverseLookup(enumInfo.members, numValue);
      }
    } else if (member.type == "bool") {
      value = !!numValue;
      humanValue = value ? "true" : "false";
    } else if (member.unit === "ms") humanValue = prettyDuration(value);else if (member.unit === "us") humanValue = prettyMicroDuration(value);else if (member.unit || scaledValue != numValue) {
      // don't show so much digits
      let v = scaledValue;
      if (member.unit) v = roundWithPrecision(v, 3);
      humanValue = "" + v;
      if (member.unit) humanValue += prettyUnit(member.unit);
    } else {
      humanValue = scaledValue + "";

      if ((scaledValue | 0) == scaledValue && (!member.unit || scaledValue >= 15)) {
        if (!member.unit) humanValue = hexNum(scaledValue);else humanValue += " (" + hexNum(scaledValue) + ")";
      } else if (scaledValue && member.storage == 8) {
        const did = toHex(pkt.data.slice(offset, offset + 8));
        humanValue += ` (${did} / ${shortDeviceId(did)})`;
      }
    }
  }

  return {
    value,
    numValue,
    scaledValue,
    humanValue,
    description: member.name + ":" + (!humanValue ? "?" : humanValue.indexOf("\n") >= 0 ? "\n" + humanValue.replace(/^/gm, "      ") : " " + humanValue),
    info: member,
    size
  };
}

function valueToFlags(enumInfo, value) {
  const r = [];
  const curr = value;

  for (const key of Object.keys(enumInfo.members)) {
    const val = enumInfo.members[key];

    if (curr & val) {
      r.push(val);
    }
  }

  return r;
}

function flagsToValue(values) {
  return values.reduce((prev, cur) => prev | cur, 0);
}

function decodeMembers(service, pktInfo, pkt, off = 0) {
  const fields = pktInfo.fields.slice(0);
  let idx = fields.findIndex(f => f.startRepeats);

  if (idx >= 0) {
    if (fields.some(f => !f.storage)) throw new Error("zero-sized field in repeats:");
    let sz = 0;

    for (const f of fields) sz += Math.abs(f.storage); // make sure we have enough fields to decode all data


    while (sz <= pkt.data.length) {
      const f = fields[idx++];
      sz += Math.abs(f.storage);
      fields.push(f);
    }
  }

  return fields.map(mem => {
    const decoded = decodeMember(service, pktInfo, mem, pkt, off);
    if (decoded) off += decoded.size;
    return decoded;
  }).filter(info => !!info);
}

function wrapDecodedMembers(decoded) {
  if (decoded.length == 0) return " {}";else if (decoded.length == 1 && decoded[0].description.length < 60) return " { " + decoded[0].description + " }";else return " {\n" + decoded.map(d => "    " + d.description).join("\n") + "\n}";
}

function syntheticPktInfo(kind, addr) {
  return {
    kind,
    identifier: addr,
    name: hexNum(addr),
    description: "",
    fields: [{
      name: "_",
      type: "bytes",
      storage: 0
    }]
  };
}

function decodeRegister(service, pkt) {
  const isSet = pkt.isRegisterSet;
  const isGet = pkt.isRegisterGet;
  if (isSet == isGet) return null;
  let error = "";
  const addr = pkt.serviceCommand & CMD_REG_MASK;
  let regInfo = service === null || service === void 0 ? void 0 : service.packets.find(p => isRegister(p) && p.identifier == addr);

  if (!regInfo) {
    regInfo = syntheticPktInfo("rw", addr);
    error = `unable to decode register`;
  }

  const decoded = decodeMembers(service, regInfo, pkt);

  if (regInfo.packFormat && pkt.data.length) {
    try {
      const recoded = toHex(jdpack(regInfo.packFormat, jdunpack(pkt.data, regInfo.packFormat)));

      if (recoded !== undefined && recoded !== toHex(pkt.data)) {
        error = `invalid data packing, ${toHex(pkt.data)} recoded to ${recoded}`;
      }
    } catch (e) {
      error = `invalid data packing, ${e.message}`;
    }
  }

  let description = "";
  if (decoded.length == 0) description = regInfo.name;else if (decoded.length == 1) description = regInfo.name + ": " + decoded[0].humanValue;else description = wrapDecodedMembers(decoded);
  if (isGet) description = "GET " + description;else description = "SET " + description;
  return {
    service,
    info: regInfo,
    decoded,
    description,
    error
  };
}

function decodeEvent(service, pkt) {
  if (pkt.isCommand || !pkt.isEvent) return null;
  const evCode = pkt.eventCode;
  const evInfo = (service === null || service === void 0 ? void 0 : service.packets.find(p => p.kind == "event" && p.identifier == evCode)) || syntheticPktInfo("event", evCode);
  const decoded = decodeMembers(service, evInfo, pkt);
  const description = `EVENT[${pkt.eventCounter}] ${evInfo.name}` + wrapDecodedMembers(decoded);
  return {
    service,
    info: evInfo,
    decoded,
    description
  };
}

function decodeCommand(service, pkt) {
  const kind = pkt.isCommand ? "command" : "report";
  const cmdInfo = (service === null || service === void 0 ? void 0 : service.packets.find(p => p.kind == kind && p.identifier == pkt.serviceCommand)) || syntheticPktInfo(kind, pkt.serviceCommand);
  const decoded = decodeMembers(service, cmdInfo, pkt);
  const description = (pkt.isCommand ? "CMD " : "REPORT ") + cmdInfo.name + wrapDecodedMembers(decoded);
  return {
    service,
    info: cmdInfo,
    decoded,
    description
  };
}

function decodePacket(service, pkt) {
  const decoded = decodeRegister(service, pkt) || decodeEvent(service, pkt) || decodeCommand(service, pkt);
  return decoded;
}

function decodePipe(pkt) {
  const cmd = pkt.serviceCommand;
  const pinfo = pkt.device.port(cmd >> PIPE_PORT_SHIFT);
  if (!pinfo.pipeType) return null;
  const [servId, pipeType, dir] = pinfo.pipeType.split(/\./);
  const service = serviceSpecificationFromName(servId);
  if (!service) return null;
  const meta = !!(cmd & PIPE_METADATA_MASK);
  const candidates = service.packets.filter(p => p.pipeType == pipeType && /pipe/.test(p.kind) && /meta/.test(p.kind) == meta && /command/.test(p.kind) == (dir == "command")).filter(p => !meta || pkt.getNumber(exports.NumberFormat.UInt16LE, 0) == p.identifier);
  const cmdInfo = candidates[0];

  if (cmdInfo) {
    const decoded = decodeMembers(service, cmdInfo, pkt, meta ? 4 : 0);
    const description = cmdInfo.kind.toUpperCase() + " " + cmdInfo.name + wrapDecodedMembers(decoded);
    return {
      service,
      info: cmdInfo,
      decoded,
      description
    };
  }

  return null;
}

function decodePacketData(pkt) {
  try {
    if (pkt.device && pkt.isPipe) {
      const info = decodePipe(pkt);
      if (info) return info;
    }

    const serviceClass = pkt.serviceClass;
    const service = serviceSpecificationFromClassIdentifier(serviceClass);
    return decodePacket(service, pkt);
  } catch (error) {
    console.error(error, {
      error,
      pkt,
      data: toHex(pkt.data)
    });
    throw error;
  }
}

function reverseLookup(map, n) {
  for (const k of Object.keys(map)) {
    if (map[k] == n) return k;
  }

  return hexNum(n);
}

function serviceClass(name) {
  const serv = serviceSpecificationFromName(name);
  return serv ? serv.classIdentifier : -1;
}

function serviceName(serviceClass) {
  if (!isSet(serviceClass)) return "?";
  const serv = serviceSpecificationFromClassIdentifier(serviceClass);
  return serv ? serv.name.toUpperCase() : "?";
}

function serviceShortIdOrClass(serviceClass) {
  if (!isSet(serviceClass)) return "?";
  const serv = serviceSpecificationFromClassIdentifier(serviceClass);
  return (serv === null || serv === void 0 ? void 0 : serv.shortId) || `0x${serviceClass.toString(16)}`;
}

function deviceServiceName(pkt) {
  var _a, _b;

  const srv_class = (_a = pkt === null || pkt === void 0 ? void 0 : pkt.device) === null || _a === void 0 ? void 0 : _a.serviceClassAt(pkt.serviceIndex);
  const serv_id = serviceName(srv_class);
  return `${((_b = pkt === null || pkt === void 0 ? void 0 : pkt.device) === null || _b === void 0 ? void 0 : _b.shortId) || "?"}/${serv_id}:${pkt.serviceIndex}`;
}

function commandName(n, serviceClass) {
  var _a, _b, _c, _d;

  let pref = "";
  if ((n & CMD_TOP_MASK) == CMD_SET_REG) pref = "SET[";else if ((n & CMD_TOP_MASK) == CMD_GET_REG) pref = "GET[";

  if (pref) {
    const reg = n & CMD_REG_MASK;
    let regName = (_a = exports.SystemReg[reg]) === null || _a === void 0 ? void 0 : _a.toLowerCase(); // try reserved registers first, fast path

    if (regName === undefined) {
      const serviceSpec = serviceSpecificationFromClassIdentifier(serviceClass);
      regName = (_b = serviceSpec === null || serviceSpec === void 0 ? void 0 : serviceSpec.packets.find(pkt => isRegister(pkt) && pkt.identifier === reg)) === null || _b === void 0 ? void 0 : _b.name;
    }

    return pref + (regName !== undefined ? regName : `x${reg.toString(16)}`) + "]";
  }

  let r = (_c = exports.SystemCmd[n]) === null || _c === void 0 ? void 0 : _c.toLowerCase();

  if (r === undefined) {
    const serviceSpec = serviceSpecificationFromClassIdentifier(serviceClass);
    r = (_d = serviceSpec === null || serviceSpec === void 0 ? void 0 : serviceSpec.packets.find(pkt => pkt.kind === "command" && pkt.identifier === n)) === null || _d === void 0 ? void 0 : _d.name;
  }

  return r;
}

function num2str(n) {
  return n + " (0x" + n.toString(16) + ")";
}

function toAscii(d) {
  let r = "";

  for (let i = 0; i < d.length; ++i) {
    const c = d[i];
    if (c < 32 || c >= 128) r += ".";else r += String.fromCharCode(c);
  }

  return r;
}

function hexDump(d) {
  const chunk = 32;
  if (d.length <= chunk) return toHex(d) + "\u00A0|\u00A0" + toAscii(d);
  const a = toArray(d);
  let r = "";

  for (let i = 0; i < d.length; i += chunk) {
    if (i + chunk >= d.length) {
      let s = toHex(a.slice(i));

      while (s.length < chunk * 2) s += "  ";

      r += s + "\u00A0|\u00A0" + toAscii(a.slice(i));
    } else {
      r += hexDump(a.slice(i, i + chunk)) + "\n";
    }
  }

  return r;
}

function printPacket(pkt, opts = {}) {
  const frame_flags = pkt.frameFlags;
  const devname = pkt.friendlyDeviceName;
  const service_name = pkt.friendlyServiceName;
  const cmdname = pkt.friendlyCommandName;
  const sender = pkt.sender;
  let pdesc = `${devname}/${service_name}: ${cmdname}; sz=${pkt.size}`;
  if (frame_flags & JD_FRAME_FLAG_COMMAND) pdesc = "to " + pdesc;else pdesc = "from " + pdesc;
  if (frame_flags & JD_FRAME_FLAG_ACK_REQUESTED) pdesc = `[ack:${hexNum(pkt.crc)}] ` + pdesc;
  const d = pkt.data;

  if (pkt.device && pkt.serviceIndex == JD_SERVICE_INDEX_CTRL && pkt.serviceCommand == CMD_ADVERTISEMENT_DATA) {
    if (pkt.device.lastServiceUpdate < pkt.timestamp) {
      if (opts.skipRepeatedAnnounce) return "";else pdesc = " ====== " + pdesc;
    } else {
      const services = [];

      for (const sc of pkt.device.serviceClasses) services.push(serviceName(sc));

      pdesc += "; " + "Announce services: " + services.join(", ");
    }
  } else {
    const decoded = pkt.decoded;

    if (decoded) {
      pdesc += "; " + decoded.description;
    } else if (0 < d.length && d.length <= 4) {
      const v0 = pkt.uintData,
            v1 = pkt.intData;
      pdesc += "; " + num2str(v0);
      if (v0 != v1) pdesc += "; signed: " + num2str(v1);
    } else if (d.length) {
      pdesc += "; " + hexDump(d);
    }
  }

  if (sender) pdesc += `; ${sender}`;
  return (!isNaN(pkt.timestamp) && (opts === null || opts === void 0 ? void 0 : opts.showTime) ? Math.round(pkt.timestamp) + "ms: " : "") + pdesc;
}

const {
  warn: warn$1
} = console;
/**
 * A Jacdac packet
 * @category JDOM
 */

class Packet {
  constructor() {
    this._meta = undefined; // accesory data used by clients

    this.key = Packet._nextKey++;
  }

  static fromBinary(data, timestamp) {
    if (!data || data.length > 252) return undefined;
    const p = new Packet();
    p._header = data.slice(0, JD_SERIAL_HEADER_SIZE);
    p._data = data.slice(JD_SERIAL_HEADER_SIZE, JD_SERIAL_HEADER_SIZE + p.size);
    if (timestamp !== undefined) p.timestamp = timestamp;
    return p;
  }

  static from(service_command, data) {
    const p = new Packet();
    p._header = new Uint8Array(JD_SERIAL_HEADER_SIZE);
    p.data = data;
    p.serviceCommand = service_command;
    return p;
  }

  static onlyHeader(service_command) {
    return Packet.from(service_command, new Uint8Array(0));
  }

  toBuffer() {
    // compute correct framing and CRC
    const res = bufferConcat(this._header, this._data);
    res[2] = this._data.length + 4;
    write16(res, 0, crc(res.slice(2)));
    return res;
  }

  get header() {
    return this._header.slice(0);
  }

  get deviceIdentifier() {
    return toHex(this._header.slice(4, 4 + 8));
  }

  set deviceIdentifier(id) {
    const idb = fromHex(id);
    if (idb.length != 8) throwError("Invalid id");
    if (this.isMultiCommand) throwError("Invalid multicast");

    this._header.set(idb, 4);

    this._decoded = undefined;
  }

  get frameFlags() {
    return this._header[3];
  }

  set frameFlags(v) {
    this._header[3] = v;
  }

  get isMultiCommand() {
    return !!(this.frameFlags & JD_FRAME_FLAG_IDENTIFIER_IS_SERVICE_CLASS);
  }

  get size() {
    return this._header[12];
  }

  get requiresAck() {
    return this.frameFlags & JD_FRAME_FLAG_ACK_REQUESTED ? true : false;
  }

  set requiresAck(ack) {
    if (ack != this.requiresAck) this._header[3] ^= JD_FRAME_FLAG_ACK_REQUESTED;
    this._decoded = undefined;
  }

  get serviceIndex() {
    return this._header[13] & JD_SERVICE_INDEX_MASK;
  }

  set serviceIndex(value) {
    if (value == null) throw new Error("service_index not set");
    this._header[13] = this._header[13] & JD_SERVICE_INDEX_INV_MASK | value;
    this._decoded = undefined;
  }

  get serviceClass() {
    var _a;

    if (this.isMultiCommand) return read32(this._header, 4);
    return (_a = this.device) === null || _a === void 0 ? void 0 : _a.serviceClassAt(this.serviceIndex);
  }

  get crc() {
    return read16(this._header, 0);
  }

  get serviceCommand() {
    return read16(this._header, 14);
  }

  set serviceCommand(cmd) {
    write16(this._header, 14, cmd);
    this._decoded = undefined;
  }

  get isRegisterSet() {
    return this.serviceCommand >> 12 == CMD_SET_REG >> 12;
  }

  get isRegisterGet() {
    return this.serviceCommand >> 12 == CMD_GET_REG >> 12;
  } // TODO rename to registerCode


  get registerIdentifier() {
    if (!this.isRegisterGet && !this.isRegisterSet) return undefined;
    return this.serviceCommand & CMD_REG_MASK;
  }

  get isEvent() {
    return this.serviceIndex <= JD_SERVICE_INDEX_MAX_NORMAL && (this.serviceCommand & CMD_EVENT_MASK) !== 0;
  }

  get eventCode() {
    return this.isEvent ? this.serviceCommand & CMD_EVENT_CODE_MASK : undefined;
  }

  get eventCounter() {
    return this.isEvent ? this.serviceCommand >> CMD_EVENT_COUNTER_POS & CMD_EVENT_COUNTER_MASK : undefined;
  }

  get isCRCAck() {
    return this.serviceIndex === JD_SERVICE_INDEX_CRC_ACK;
  }

  get isPipe() {
    return this.serviceIndex === JD_SERVICE_INDEX_PIPE;
  }

  get pipePort() {
    return this.isPipe && this.serviceCommand >> PIPE_PORT_SHIFT;
  }

  get pipeCount() {
    return this.isPipe && this.serviceCommand & PIPE_COUNTER_MASK;
  }

  get data() {
    return this._data;
  }

  set data(buf) {
    if (buf.length > JD_SERIAL_MAX_PAYLOAD_SIZE) throw Error(`jacdac packet length too large, ${buf.length} > ${JD_SERIAL_MAX_PAYLOAD_SIZE} bytes`);
    this._header[12] = buf.length;
    this._data = buf;
    this._decoded = undefined;
  }

  jdunpack(fmt) {
    return this._data && fmt && jdunpack(this._data, fmt) || [];
  }

  get uintData() {
    let buf = this._data;
    if (buf.length == 0) return undefined;
    if (buf.length < 4) buf = bufferConcat(buf, new Uint8Array(4));
    if (buf.length == 8) return read32(buf, 0) + read32(buf, 4) * 0x100000000;
    return read32(buf, 0);
  }

  get stringData() {
    return this._data && bufferToString(this._data);
  }

  get intData() {
    let fmt;

    switch (this._data.length) {
      case 0:
        return undefined;

      case 1:
        fmt = exports.NumberFormat.Int8LE;
        break;

      case 2:
      case 3:
        fmt = exports.NumberFormat.Int16LE;
        break;

      default:
        fmt = exports.NumberFormat.Int32LE;
        break;
    }

    return this.getNumber(fmt, 0);
  }

  get isAnnounce() {
    return this.serviceIndex == JD_SERVICE_INDEX_CTRL && this.isReport && this.serviceCommand == exports.SystemCmd.Announce;
  }

  get isRepeatedAnnounce() {
    var _a;

    return this.isAnnounce && ((_a = this.device) === null || _a === void 0 ? void 0 : _a.lastServiceUpdate) < this.timestamp;
  }

  get decoded() {
    if (!this._decoded) this._decoded = decodePacketData(this);
    return this._decoded;
  }

  get meta() {
    if (!this._meta) this._meta = {};
    return this._meta;
  }

  clone() {
    const pkt = new Packet();
    pkt._header = this._header.slice();
    pkt._data = this._data.slice();
    pkt.timestamp = this.timestamp;
    return pkt;
  }

  cloneForDevice(deviceId, serviceIndex) {
    const idb = fromHex(deviceId);
    if (idb.length != 8) throwError("Invalid id");
    if (!this.isMultiCommand) throwError("Must be multi command");
    const pkt = Packet.fromBinary(this.toBuffer(), this.timestamp);
    pkt.frameFlags &= ~JD_FRAME_FLAG_IDENTIFIER_IS_SERVICE_CLASS;

    pkt._header.set(idb, 4);

    pkt._decoded = undefined;
    pkt.serviceIndex = serviceIndex;
    return pkt;
  }

  compress(stripped) {
    if (stripped.length == 0) return;
    let sz = -4;

    for (const s of stripped) {
      sz += s.length;
    }

    const data = new Uint8Array(sz);

    this._header.set(stripped[0], 12);

    data.set(stripped[0].slice(4), 0);
    sz = stripped[0].length - 4;

    for (const s of stripped.slice(1)) {
      data.set(s, sz);
      sz += s.length;
    }

    this._data = data;
    this._decoded = undefined;
  }

  withFrameStripped() {
    return bufferConcat(this._header.slice(12, 12 + 4), this._data);
  }

  getNumber(fmt, offset) {
    return getNumber(this._data, fmt, offset);
  }

  get isCommand() {
    return !!(this.frameFlags & JD_FRAME_FLAG_COMMAND);
  }

  set isCommand(value) {
    if (value) this._header[3] |= JD_FRAME_FLAG_COMMAND;else this._header[3] &= ~JD_FRAME_FLAG_COMMAND;
    this._decoded = undefined;
  }

  get isReport() {
    return !this.isCommand;
  }

  toString() {
    let msg = `${shortDeviceId(this.deviceIdentifier)}/${this.serviceIndex}[${this.frameFlags}]: ${this.serviceCommand} sz=${this.size}`;
    if (this.size < 20) msg += ": " + toHex(this.data);else msg += ": " + toHex(this.data.slice(0, 20)) + "...";
    return msg;
  }

  sendCoreAsync(bus) {
    const buf = this.toBuffer(); // Here we're sending this packet as the only one in a frame, therefore we need to compute CRC (which toBuffer() does)
    // There's no crc computation function on Packet, since it should be typically only applied to full frames.
    // The crc field reads the CRC from the frame (which is useful eg for acks).

    this._header[0] = buf[0];
    this._header[1] = buf[1];
    this._header[2] = buf[2];
    return bus.sendPacketAsync(this);
  }

  sendReportAsync(dev) {
    if (!dev) return Promise.resolve();
    this.deviceIdentifier = dev.deviceId;
    return this.sendCoreAsync(dev.bus);
  }

  sendCmdAsync(dev) {
    if (!dev) return Promise.resolve();
    this.deviceIdentifier = dev.deviceId;
    this.isCommand = true;
    return this.sendCoreAsync(dev.bus);
  }

  sendAsMultiCommandAsync(bus, service_class) {
    this._header[3] |= JD_FRAME_FLAG_IDENTIFIER_IS_SERVICE_CLASS | JD_FRAME_FLAG_COMMAND;
    write32(this._header, 4, service_class);
    write32(this._header, 8, 0);
    return this.sendCoreAsync(bus);
  }

  static fromFrame(frame, timestamp) {
    return frameToPackets(frame, timestamp);
  }

  static jdpacked(service_command, fmt, nums) {
    return Packet.from(service_command, jdpack(fmt, nums));
  } // helpers


  get friendlyDeviceName() {
    var _a;

    if (this.isMultiCommand) return "*";
    return ((_a = this.device) === null || _a === void 0 ? void 0 : _a.friendlyName) || this.deviceIdentifier;
  }

  get friendlyServiceName() {
    let service_name;

    if (this.isCRCAck) {
      service_name = "CRC-ACK";
    } else if (this.isPipe) {
      service_name = "PIPE";
    } else {
      const serv_id = serviceName(this.serviceClass);
      service_name = `${serv_id} (${this.serviceIndex})`;
    }

    return service_name;
  }

  get friendlyCommandName() {
    const cmd = this.serviceCommand;
    let cmdname;

    if (this.isCRCAck) {
      cmdname = hexNum(cmd);
    } else if (this.isPipe) {
      cmdname = `port:${cmd >> PIPE_PORT_SHIFT} cnt:${cmd & PIPE_COUNTER_MASK}`;
      if (cmd & PIPE_METADATA_MASK) cmdname += " meta";
      if (cmd & PIPE_CLOSE_MASK) cmdname += " close";
    } else if (this.isEvent) {
      const spec = serviceSpecificationFromClassIdentifier(this.serviceClass);
      const code = this.eventCode;
      const pkt = spec === null || spec === void 0 ? void 0 : spec.packets.find(pkt => pkt.kind === "event" && pkt.identifier === code);
      cmdname = pkt === null || pkt === void 0 ? void 0 : pkt.name;
    } else if (this.isReport) {
      const spec = serviceSpecificationFromClassIdentifier(this.serviceClass);
      const code = this.serviceCommand & ~CMD_GET_REG;
      const pkt = spec === null || spec === void 0 ? void 0 : spec.packets.find(pkt => pkt.kind === "report" && pkt.identifier === code);
      cmdname = pkt === null || pkt === void 0 ? void 0 : pkt.name;
    } else {
      cmdname = commandName(cmd, this.serviceClass);
    }

    return cmdname;
  }

}

Packet._nextKey = 1;

function frameToPackets(frame, timestamp) {
  const size = frame[2] || 0;

  if (frame.length < size + 12) {
    warn$1(`${timestamp}ms: got only ${frame.length} bytes; expecting ${size + 12}`);
  } else if (size < 4) {
    warn$1(`${timestamp}ms: empty packet`);
  } else {
    const computed = crc(frame.slice(2, size + 12));
    const actual = read16(frame, 0);
    if (actual != computed) console.error(`crc mismatch; sz=${size} got:${actual}, exp:${computed}`);
    const res = [];
    if (frame.length != 12 + frame[2]) warn$1(`${timestamp}ms: unexpected packet len: ${frame.length}`);

    for (let ptr = 12; ptr < 12 + frame[2];) {
      const psz = frame[ptr] + 4;
      const sz = ALIGN(psz);
      const pkt = bufferConcat(frame.slice(0, 12), frame.slice(ptr, ptr + psz));
      if (ptr + psz > 12 + frame[2]) warn$1(`${timestamp}ms: invalid frame compression, res len=${res.length}`);
      const p = Packet.fromBinary(pkt);
      p.timestamp = timestamp;
      res.push(p); // only set req_ack flag on first packet - otherwise we would sent multiple acks

      if (res.length > 1) p.requiresAck = false;
      ptr += sz;
    }

    return res;
  }

  return [];
}

const TRACE_OVERSHOOT = 1.1;
/**
 * Collect stack trace at the current execution position
 * @returns
 * @internal
 */

function stack() {
  return new Error().stack;
}
/**
 * @internal
 */


function cleanStack(text) {
  return text === null || text === void 0 ? void 0 : text.split(/\n/g).slice(2).join("\n").replace(/webpack-internal:\/\/\//g, "").replace(/https:\/\/microsoft\.github\.io\/jacdac-docs/g, "");
}
/**
 * A sequence of packets.
 * @category Trace
 */


class Trace {
  /**
   * Constructs a new empty trace or from an existing list of packets
   * @param packets list of packets
   * @param description description of the trace
   */
  constructor(packets = [], options) {
    this.packets = packets;
    this.description = options === null || options === void 0 ? void 0 : options.description;
    this.maxLength = options === null || options === void 0 ? void 0 : options.maxLength;
  }
  /**
   * Number of packets in trace
   */


  get length() {
    return this.packets.length;
  }
  /**
   * Duration in milliseconds between the first and last packet.
   */


  get duration() {
    if (!this.packets.length) return 0;
    return this.packets[this.packets.length - 1].timestamp - this.packets[0].timestamp;
  }
  /**
   * Timestamp of the first packet, defaults to 0 if trace is empty.
   */


  get startTimestamp() {
    var _a;

    return ((_a = this.packets[0]) === null || _a === void 0 ? void 0 : _a.timestamp) || 0;
  }
  /**
   * Timestamp of the last packet, defaults to 0 if trace is empty.
   */


  get endTimestamp() {
    var _a;

    return ((_a = this.packets[this.packets.length - 1]) === null || _a === void 0 ? void 0 : _a.timestamp) || 0;
  }
  /**
   * Appends a packet to the trace
   * @param packet packet to add
   * @param maxLength If positive, prunes older packets when the length reaches maxLength
   */


  addPacket(packet) {
    this.packets.push(packet);

    if (this.maxLength > 0 && this.packets.length > this.maxLength * TRACE_OVERSHOOT) {
      // 10% overshoot of max
      this.packets = this.packets.slice(-this.maxLength);
    }
  }
  /**
   * Gets a text-rendered view of the trace
   * @param length maximum number of elements
   * @returns text where each line is a packet
   */


  serializeToText(length) {
    var _a;

    const start = ((_a = this.packets[0]) === null || _a === void 0 ? void 0 : _a.timestamp) || 0;
    let pkts = this.packets;
    if (length > 0) pkts = pkts.slice(-length);
    const text = pkts.map(pkt => {
      let t = `${roundWithPrecision(pkt.timestamp - start, 3)}\t${toHex(pkt.toBuffer())}\t${printPacket(pkt, {}).replace(/\r?\n/g, " ")}`;
      const trace = pkt.meta[META_TRACE];
      if (trace) t += "\n" + cleanStack(trace);
      return t;
    });

    if (this.description) {
      text.unshift(this.description);
      text.unshift("");
    }

    return text.join("\n");
  }

}

function normalizeEventNames(eventNames) {
  if (!eventNames) eventNames = [];
  if (typeof eventNames === "string") eventNames = [eventNames];
  return eventNames;
}
/**
 * Given a node or set of nodes, generate a stable string that can be used to track dependencies in frameworks like React.
 * @param nodes
 * @returns
 * @category JDOM
 */


function dependencyId(nodes) {
  if (Array.isArray(nodes)) return (nodes === null || nodes === void 0 ? void 0 : nodes.map(node => (node === null || node === void 0 ? void 0 : node.nodeId) || "?").join(",")) || "";else return (nodes === null || nodes === void 0 ? void 0 : nodes.nodeId) || "";
}

let nextNodeId = 0;
/**
 * Base class for evented nodes in Jacdac
 * @category JDOM
 */

class JDEventSource {
  /**
   * @internal
   */
  constructor() {
    /**
     * Gets an internal unique node identifier, mostly used for debugging.
     * @category JDOM
     */
    this.nodeId = nextNodeId++;
    this.listeners = {};
    /**
     * Gets a counter of event emit calls.
     * @category JDOM
     */

    this.eventStats = {};
    /**
     * Gets a counter map from events to new listener counts
     * @category JDOM
     */

    this.newListenerStats = undefined;
  }
  /**
   * Registers a handler for one or more events
   * @param eventName name or names of the events to subscribe
   * @param handler handler to register
   * @returns current object instance
   * @category JDOM
   */


  on(eventName, handler) {
    if (!handler) return this;
    normalizeEventNames(eventName).forEach(eventName => this.addListenerInternal(eventName, handler, false));
    return this;
  }
  /**
   * Unregisters a handler for one or more events
   * @param eventName name or names of the events to subscribe
   * @param handler handler to unregister
   * @returns current object instance
   * @category JDOM
   */


  off(eventName, handler) {
    normalizeEventNames(eventName).forEach(eventName => this.removeListenerInternal(eventName, handler));
    return this;
  }
  /**
   * Registers a handler for one or more events to run only once.
   * @param eventName name or names of the events to subscribe
   * @param handler handler to execute
   * @returns current object instance
   * @category JDOM
   */


  once(eventName, handler) {
    normalizeEventNames(eventName).forEach(eventName => this.addListenerInternal(eventName, handler, true));
    return this;
  }

  addListenerInternal(eventName, handler, once) {
    if (!eventName || !handler) {
      return;
    }

    const eventListeners = this.listeners[eventName] || (this.listeners[eventName] = []);
    const listener = eventListeners.find(listener => listener.handler === handler);

    if (listener) {
      listener.once = !!once;
      return;
    }

    eventListeners.push({
      handler,
      once: !!once,
      // debug only collection of trace for leak detection
      stackTrace: Flags.diagnostics && stack()
    });
    this.emit(NEW_LISTENER, eventName, handler); // diagnostics

    if (Flags.diagnostics) {
      if (!this.newListenerStats) this.newListenerStats = {};
      this.newListenerStats[eventName] = (this.newListenerStats[eventName] || 0) + 1;
    }
  }

  removeListenerInternal(eventName, handler) {
    if (!eventName || !handler) return;
    const eventListeners = this.listeners[eventName];

    if (eventListeners) {
      for (let i = 0; i < eventListeners.length; ++i) {
        const listener = eventListeners[i];

        if (handler === listener.handler) {
          eventListeners.splice(i, 1);
          this.emit(REMOVE_LISTENER, eventName, handler);
          return;
        }
      }
    }
  }
  /**
   * Synchronously calls each of the listeners registered for the event named eventName,
   * in the order they were registered, passing the supplied arguments to each.
   * @param eventName
   * @param args
   * @category JDOM
   */


  emit(eventName, ...args) {
    if (!eventName) return false; // track event stats

    this.eventStats[eventName] = (this.eventStats[eventName] || 0) + 1;
    const eventListeners = this.listeners[eventName];

    if (!eventListeners || eventListeners.length == 0) {
      // report unhandled errors
      if (eventName == ERROR) console.error(args[0]);
      return false;
    }

    for (let i = 0; i < eventListeners.length; ++i) {
      const listener = eventListeners[i];
      const handler = listener.handler;

      if (listener.once) {
        eventListeners.splice(i, 1);
        --i;
      }

      try {
        // eslint-disable-next-line prefer-spread
        handler.apply(null, args);
      } catch (e) {
        // avoid recursive errors in error handler
        if (eventName !== ERROR) this.emit(ERROR, e);
      }
    }

    return true;
  }
  /**
   * Gets the number of listeners for a given event
   * @param eventName name of the event
   * @returns number of registered handlers
   * @category JDOM
   */


  listenerCount(eventName) {
    if (!eventName) return 0;
    const listeners = this.listeners[eventName];
    return (listeners === null || listeners === void 0 ? void 0 : listeners.length) || 0;
  }
  /**
   * Gets the list stack trace where an event was registered. Only enabled if ``Flags.debug`` is true.
   * @param eventName name of the event
   * @returns stack traces where a listener was added
   * @category JDOM
   */


  listenerStackTraces(eventName) {
    const listeners = this.listeners[eventName];
    return listeners === null || listeners === void 0 ? void 0 : listeners.map(listener => listener.stackTrace);
  }
  /**
   * Returns an array listing the events for which the emitter has registered listeners.
   * @category JDOM
   */


  eventNames() {
    return Object.keys(this.listeners);
  }
  /**
   * Creates an observable from the given event
   * @param eventName
   * @category JDOM
   */


  observe(eventName) {
    return new EventObservable(this, normalizeEventNames(eventName));
  }
  /**
   * Subscribes to an event and returns the unsubscription handler
   * @param eventName
   * @param next
   * @category JDOM
   */


  subscribe(eventName, next) {
    const observer = this.observe(eventName);
    return observer.subscribe({
      next
    }).unsubscribe;
  }
  /**
   * Gets a counter for the ``CHANGE`` event.
   * @category JDOM
   */


  get changeId() {
    return this.eventStats[CHANGE] || 0;
  }

}

class EventObservable {
  constructor(eventEmitter, eventNames) {
    this.eventEmitter = eventEmitter;
    this.eventNames = eventNames; //console.log(`obs`, this.eventNames)
  }

  subscribe(observer) {
    //console.log(`on`, this.eventNames, observer)
    if (observer.next) this.eventEmitter.on(this.eventNames, observer.next);
    if (observer.error) this.eventEmitter.on(ERROR, observer.error); // never completes

    return {
      unsubscribe: () => {
        //console.log(`off`, this.eventNames, observer)
        if (observer.next) this.eventEmitter.off(this.eventNames, observer.next);
        if (observer.error) this.eventEmitter.off(ERROR, observer.error);
      }
    };
  }

}
/* eslint-disable @typescript-eslint/no-explicit-any */

/**
 * Base class for JDOM Node classes.
 * @category JDOM
 */


class JDNode extends JDEventSource {
  constructor() {
    super();
  }
  /**
   * A human friendly name
   * @category JDOM
   */


  get friendlyName() {
    return this.name;
  }
  /**
   * Gets a databag to store custom information
   * @category JDOM
   */


  get nodeData() {
    if (!this._nodeData) this._nodeData = {};
    return this._nodeData;
  }
  /**
   * Emit event in current node and parent nodes
   * @param event event to emit
   * @param arg event arguments
   * @category JDOM
   */


  emitPropagated(event, arg) {
    let current = this;

    while (current) {
      current.emit(event, arg || this);
      current = current.parent;
    }
  }
  /**
   * @hidden
   */


  toString() {
    return this.friendlyName;
  }

}
/**
 * Base class for JDOM service member classes.
 * @category JDOM
 */


class JDServiceMemberNode extends JDNode {
  /**
   * @internal
   */
  constructor(service, code, isPacket) {
    super();
    this._specification = null;
    this.service = service;
    this.code = code;
    this.isPacket = isPacket;
  }
  /**
   * Gets the node identifier in the JDOM tree
   * @category JDOM
   */


  get id() {
    return `${this.nodeKind}:${this.service.device.deviceId}:${this.service.serviceIndex.toString(16)}:${this.code.toString(16)}`;
  }
  /**
   * Gets the event name, if specified.
   * @category JDOM
   */


  get name() {
    var _a;

    return ((_a = this.specification) === null || _a === void 0 ? void 0 : _a.name) || this.code.toString(16);
  }
  /**
   * Gets the qualitified event name, if specified.
   * @category JDOM
   */


  get qualifiedName() {
    return `${this.service.qualifiedName}.${this.name}`;
  }
  /**
   * Gets the event specification if known.
   * @category Specification
   */


  get specification() {
    var _a;

    if (this._specification === null) // lookup once
      this._specification = (_a = this.service.specification) === null || _a === void 0 ? void 0 : _a.packets.find(packet => this.isPacket(packet) && packet.identifier === this.code);
    return this._specification;
  }
  /**
   * Gets the parent service client instance.
   * @category JDOM
   */


  get parent() {
    return this.service;
  }
  /**
   * Gets the event friendly name.
   * @category JDOM
   */


  get friendlyName() {
    const parts = [this.service.friendlyName, this.name];
    return parts.join(".");
  }

}
/**
 * A Jacdac field.
 * @category JDOM
 */


class JDField extends JDNode {
  /**
   * @internal
   */
  constructor(member, index, specification) {
    super();
    this.member = member;
    this.index = index;
    this.specification = specification;
  }
  /**
   * Gets the JDOM node identifier
   * @category JDOM
   */


  get id() {
    return `${this.nodeKind}:${this.member.service.device.deviceId}:${this.member.service.serviceIndex.toString(16)}:${this.member.code.toString(16)}:${this.index.toString(16)}`;
  }
  /**
   * Gets the JDOM name
   * @category JDOM
   */


  get name() {
    return this.specification.name === "_" ? this.member.specification.name : this.specification.name;
  }
  /**
   * @internal
   */


  get children() {
    return [];
  }
  /**
   * Gets the JDOM qualified name
   * @category JDOM
   */


  get qualifiedName() {
    return `${this.member.qualifiedName}.${this.name}`;
  }
  /**
   * Gets the JDOM parent
   * @category JDOM
   */


  get parent() {
    return this.member;
  }
  /**
   * Gets the JDOM friendly name
   * @category JDOM
   */


  get friendlyName() {
    const parts = [this.member.friendlyName];
    if (this.specification.name !== "_") parts.push(this.name);
    return parts.join(".");
  }
  /**
   * @internal
   */


  get dataTypeName() {
    const parts = [this.member.service.specification.shortName, this.name];
    return parts.join(".");
  }
  /**
   * Gets the unit of the data stored in the field
   * @category Data
   */


  get unit() {
    return this.specification.unit;
  }
  /**
   * Gets ``FIELD_NODE_NAME``
   * @category JDOM
   */


  get nodeKind() {
    return FIELD_NODE_NAME;
  }
  /**
   * @internal
   */


  get decoded() {
    const decoded = this.member.decoded;
    return decoded === null || decoded === void 0 ? void 0 : decoded.decoded[this.index];
  }
  /**
   * Gets the decoded field value
   * @category Data
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any


  get value() {
    var _a;

    return (_a = this.decoded) === null || _a === void 0 ? void 0 : _a.value;
  }

}
/**
 * Unrolls an array of packed values into a friendly object structure
 * @param data
 * @param fields
 * @returns
 * @category Data Packing
 */


function unpackedToObject(data, fields, defaultName) {
  if (!data || !fields) return undefined;
  const r = {};

  for (let i = 0; i < data.length; ++i) {
    const field = fields[i];
    const value = data[i];
    const {
      name,
      startRepeats
    } = field;
    const prettyName = name === "_" && defaultName ? defaultName : name;

    if (startRepeats) {
      const repeatFields = fields.slice(i);
      console.log({
        value,
        repeatFields,
        data
      });
      r["repeat"] = value.map(rdata => {
        const r = {};

        for (let i = 0; i < repeatFields.length; ++i) {
          const field = fields[i];
          const value = rdata[i];
          const {
            name
          } = field;
          const prettyName = name === "_" && defaultName ? defaultName : name;
          r[prettyName] = value;
        }

        return r;
      });
      break;
    } else r[prettyName] = value;
  }

  return r;
}
/**
 * Converts an object structure into a flat packed data array
 * @param pkt
 * @param msg
 * @returns
 * @category Data Packing
 */


function objectToUnpacked(pkt, // eslint-disable-next-line @typescript-eslint/no-explicit-any
msg) {
  if (!msg) return [];
  if (typeof msg === "number" || typeof msg === "string") return [msg];else if (typeof msg === "boolean") return [msg ? 1 : 0];else if (Array.isArray(msg)) {
    // assume a packaged layout
    return msg;
  } else {
    const {
      fields
    } = pkt;
    const r = [];

    for (let i = 0; i < fields.length; ++i) {
      const field = fields[i];
      const name = field.name === "_" ? pkt.name : field.name;
      const value = msg[name];

      if (field.startRepeats) {
        const repeatFields = fields.slice(i);
        r.push( // eslint-disable-next-line @typescript-eslint/no-explicit-any
        value.map(vrow => {
          const arow = [];

          for (let j = 0; j < repeatFields.length; ++j) {
            const rfield = repeatFields[j];
            const rname = rfield.name;
            arow.push(vrow[rname]);
          }

          return arow;
        }));
        break;
      } else {
        r.push(value);
      }
    }

    return r;
  }
}
/**
 * A Jacdac register client.
 * @category JDOM
 */


class JDRegister extends JDServiceMemberNode {
  /**
   * @internal
   */
  constructor(service, code) {
    super(service, code, isRegister);
    this._lastSetTimestamp = -Infinity;
    this._lastGetTimestamp = -Infinity;
    this._lastGetAttempts = 0;
  }
  /**
   * Returns ``REGISTER_NODE_NAME``
   * @category JDOM
   */


  get nodeKind() {
    return REGISTER_NODE_NAME;
  }
  /**
   * Gets the list of field, if the specification is known
   * @category JDOM
   */


  get fields() {
    var _a;

    if (!this._fields) this._fields = (_a = this.specification) === null || _a === void 0 ? void 0 : _a.fields.map((field, index) => new JDField(this, index, field));
    return this._fields.slice();
  }
  /**
   * Gets the list of fields
   * @category JDOM
   */


  get children() {
    return this.fields;
  }
  /**
   * Timestamp of the last ``register set`` packet
   * @category Packets
   */


  get lastSetTimestamp() {
    return this._lastSetTimestamp;
  }
  /**
   * Timestamp of the last ``register get`` packet
   * @category Packets
   */


  get lastGetTimestamp() {
    return this._lastGetTimestamp;
  }
  /**
   * Clears the get timestamp
   * @internal
   * @category Packets
   */


  clearGetTimestamp() {
    this._lastGetTimestamp = -Infinity;
  }
  /**
   * Number of attempts to send a ``get`` packet without response
   * @category Packets
   */


  get lastGetAttempts() {
    return this._lastGetAttempts;
  }
  /**
   * Send a message to set the register value
   * @param data packed data
   * @param autoRefresh immediately send a ``get`` packet
   * @returns
   * @category Packets
   */


  sendSetAsync(data, autoRefresh) {
    const cmd = CMD_SET_REG | this.code;
    const pkt = Packet.from(cmd, data);
    this._lastSetTimestamp = this.service.device.bus.timestamp;
    let p = this.service.sendPacketAsync(pkt, this.service.registersUseAcks);
    if (autoRefresh) p = this.service.device.bus.delay(50).then(() => this.sendGetAsync());
    return p;
  }
  /**
   * Requests the value of the register by sending a ``get`` packet
   * @returns
   * @category Packets
   */


  sendGetAsync() {
    var _a;

    if (((_a = this.specification) === null || _a === void 0 ? void 0 : _a.kind) === "const" && this.data !== undefined) return Promise.resolve();
    this._lastGetTimestamp = this.service.device.bus.timestamp;
    this._lastGetAttempts++;
    const cmd = CMD_GET_REG | this.code;
    return this.service.sendCmdAsync(cmd, undefined, this.service.registersUseAcks).then(() => {
      this.emit(GET_ATTEMPT);
    });
  }
  /**
   * Send a message to set the register value
   * @param values message to pack and send
   * @param autoRefresh immediately send a ``get`` packet
   * @category Packets
   */


  sendSetPackedAsync(values, autoRefresh) {
    var _a;

    const fmt = (_a = this.specification) === null || _a === void 0 ? void 0 : _a.packFormat;
    if (!fmt) throw new Error("unknown register data format");
    return this.sendSetAsync(jdpack(fmt, values), autoRefresh);
  }
  /**
   * Sends a message to set the register value as a bpolean
   * @param value
   * @param autoRefresh
   * @param autoRefresh immediately send a ``get`` packet
   * @category Packets
   */


  sendSetBoolAsync(value, autoRefresh) {
    return this.sendSetPackedAsync([value ? 1 : 0], autoRefresh);
  }
  /**
   * Sends a message to set the register value as a string
   * @param value
   * @param autoRefresh
   * @param autoRefresh immediately send a ``get`` packet
   * @category Packets
   */


  sendSetStringAsync(value, autoRefresh) {
    return this.sendSetPackedAsync([value || ""], autoRefresh);
  }
  /**
   * Gets the raw data from the last report packet
   * @category Data
   */


  get data() {
    var _a;

    return (_a = this._lastReportPkt) === null || _a === void 0 ? void 0 : _a.data;
  }
  /**
   * Gets the timestamp when received the last report with data
   * @category Data
   */


  get lastDataTimestamp() {
    var _a;

    return (_a = this._lastReportPkt) === null || _a === void 0 ? void 0 : _a.timestamp;
  }
  /**
   * Get the data from the last report packet, unpacked according to the specification.
   * @category Data
   */


  get unpackedValue() {
    var _a;

    const d = this.data;
    const fmt = (_a = this.specification) === null || _a === void 0 ? void 0 : _a.packFormat;
    return d && fmt && jdunpack(this.data, fmt);
  }
  /**
   * Gets the data from the last report packet, unpacked and hydrated into an object.
   * @category Data
   */


  get objectValue() {
    const {
      specification
    } = this;
    return unpackedToObject(this.unpackedValue, specification === null || specification === void 0 ? void 0 : specification.fields, specification.name);
  }
  /**
   * Gets the data as a signed integer
   * @category Data
   */


  get intValue() {
    const d = this.data;
    return d && intOfBuffer(d);
  }
  /**
   * Gets the data as a unsigned integer
   * @category Data
   */


  get uintValue() {
    const d = this.data;
    return d && uintOfBuffer(d);
  }
  /**
   * Gets the data as a boolean
   * @category Data
   */


  get boolValue() {
    if (this.data === undefined) return undefined;
    return !!this.intValue;
  }
  /**
   * Gets the data as a string
   * @category Data
   */


  get stringValue() {
    const buf = this.data;
    if (buf === undefined) return undefined;
    let value;

    try {
      value = fromUTF8(uint8ArrayToString(buf));
    } catch (_a) {
      // invalid UTF8
      value = uint8ArrayToString(buf);
    }

    return value;
  }
  /**
   * Gets a pretty printed represention of the data
   * @category Data
   */


  get humanValue() {
    var _a, _b;

    return (_b = (_a = this.decoded) === null || _a === void 0 ? void 0 : _a.decoded) === null || _b === void 0 ? void 0 : _b.map(field => field.humanValue).join(",");
  }
  /**
   * @internal
   */


  toString() {
    const d = this.data;
    return `${this.id} ${d ? toHex(d) : ""}`;
  }
  /**
   * @internal
   */


  get decoded() {
    var _a;

    return (_a = this._lastReportPkt) === null || _a === void 0 ? void 0 : _a.decoded;
  }
  /**
   * Refresh the value of the register within a timeout
   * @param skipIfValue don't refesh if any data if available
   * @returns
   * @category Data
   */


  refresh(skipIfValue) {
    var _a; // don't refetch consts
    // don't refetch if already data


    if (!!this.data && (skipIfValue || ((_a = this.specification) === null || _a === void 0 ? void 0 : _a.kind) === "const")) return;
    const bus = this.service.device.bus;
    return bus.withTimeout(REGISTER_REFRESH_TIMEOUT, new Promise((resolve, reject) => {
      this.once(REPORT_RECEIVE, () => {
        const f = resolve;
        resolve = null;
        f();
      }); // re-send get if no answer within 40ms and 90ms

      this.sendGetAsync().then(() => bus.delay(REGISTER_REFRESH_RETRY_0)).then(() => {
        if (resolve) return this.sendGetAsync().then(() => bus.delay(REGISTER_REFRESH_RETRY_1));
      }).then(() => {
        if (resolve) return this.sendGetAsync();
      }).catch(e => reject(e));
    }));
  }
  /**
   * @internal
   */


  processPacket(pkt) {
    if (pkt.isRegisterGet) this.processReport(pkt);else if (pkt.isRegisterSet) {
      // another device sent a set packet to this register
      // so most likely it's value changed
      // clear any data caching to force updating the value
      this.clearGetTimestamp();
    }
  }

  processReport(pkt) {
    const updated = !bufferEq(this.data, pkt.data);
    this._lastReportPkt = pkt;
    this._lastGetAttempts = 0; // reset counter

    this._lastGetTimestamp = this.service.device.bus.timestamp; // reset time counter too

    this.emit(REPORT_RECEIVE, this);

    if (updated) {
      this.emitPropagated(REPORT_UPDATE, this);
      this.emit(CHANGE);
    }
  }
  /**
   * @internal
   */


  compareTo(b) {
    return this.code - b.code || this.service.compareTo(b.service);
  }

}
/**
 * A Jacdac event client.
 * @category JDOM
 */


class JDEvent extends JDServiceMemberNode {
  /**
   * @internal
   */
  constructor(service, code) {
    super(service, code, isEvent);
    this._count = 0;
  }
  /**
   * Returns the ``EVENT_NODE_NAME`` identifier
   * @category JDOM
   */


  get nodeKind() {
    return EVENT_NODE_NAME;
  }
  /**
   * Gets the field node
   * @category Service Clients
   */


  get fields() {
    var _a;

    if (!this._fields) this._fields = (_a = this.specification) === null || _a === void 0 ? void 0 : _a.fields.map((field, index) => new JDField(this, index, field));
    return this._fields.slice();
  }
  /**
   * Gets the list of fields
   * @category JDOM
   */


  get children() {
    return this.fields;
  }
  /**
   * Gets the raw data attached to the last event packet
   * @category Data
   */


  get data() {
    var _a;

    return (_a = this._lastReportPkt) === null || _a === void 0 ? void 0 : _a.data;
  }
  /**
   * Gets the unpacked data attached to the last event packet, if the event specification is known.
   * @category Data
   */


  get unpacked() {
    var _a;

    const {
      packFormat
    } = this.specification || {};
    return packFormat && ((_a = this._lastReportPkt) === null || _a === void 0 ? void 0 : _a.jdunpack(packFormat));
  }
  /**
   * Gets a counter of occurences for this event.
   * @category Data
   */


  get count() {
    return this._count;
  }
  /**
   * Gets the timestamp of the last packet with data received for this event.
   * @category Data
   */


  get lastDataTimestamp() {
    var _a;

    return (_a = this._lastReportPkt) === null || _a === void 0 ? void 0 : _a.timestamp;
  }
  /**
   * @internal
   */


  get decoded() {
    var _a;

    return (_a = this._lastReportPkt) === null || _a === void 0 ? void 0 : _a.decoded;
  }
  /**
   * @internal
   */


  processEvent(pkt) {
    const {
      device
    } = this.service;
    const ec = (device.eventCounter || 0) + 1; // how many packets ahead and behind current are we?

    const ahead = pkt.eventCounter - ec & CMD_EVENT_COUNTER_MASK;
    const behind = ec - pkt.eventCounter & CMD_EVENT_COUNTER_MASK; // ahead == behind == 0 is the usual case, otherwise
    // behind < 60 means this is an old event (or retransmission of something we already processed)

    const old = behind < 60;
    const missed5 = ahead < 5;
    const isahead = ahead > 0; // ahead < 5 means we missed at most 5 events,
    // so we ignore this one and rely on retransmission
    // of the missed events, and then eventually the current event

    if (isahead && (old || missed5)) return;
    this._lastReportPkt = pkt;
    this._count++;
    this.emitPropagated(EVENT, this);
    this.emit(CHANGE); // update device counter

    device.eventCounter = pkt.eventCounter;
  }

}
/**
 * Base class for clients
 * @category Clients
 */


class JDClient extends JDEventSource {
  constructor() {
    super();
    this.unsubscribers = [];
    this.unmounted = false;
  } // eslint-disable-next-line @typescript-eslint/no-explicit-any


  log(msg) {
    console.log(msg);
  }

  mount(unsubscribe) {
    this.unmounted = false;
    if (unsubscribe && this.unsubscribers.indexOf(unsubscribe) < 0) this.unsubscribers.push(unsubscribe);
    return unsubscribe;
  }

  unmount() {
    const us = this.unsubscribers;
    this.unsubscribers = [];
    us.forEach(u => u());
    this.unmounted = true;
  }

}

function cryptoRandomUint32(length) {
  if (typeof window === "undefined") return undefined; // not supported

  const vals = new Uint32Array(length);
  window.crypto.getRandomValues(vals);
  return vals;
}

function anyRandomUint32(length) {
  let r = cryptoRandomUint32(length);

  if (!r) {
    r = new Uint32Array(length);

    for (let i = 0; i < r.length; ++i) r[i] = Math.random() * 4294967296 >>> 0;
  }

  return r;
}

function randomUInt(max) {
  const arr = anyRandomUint32(1);
  return arr[0] % max;
}

function randomBytes(n) {
  const buf = anyRandomUint32(n);
  const r = new Uint8Array(buf.length);

  for (let i = 0; i < n; ++i) r[i] = buf[i] & 0xff;

  return r;
}

function randomDeviceId() {
  const devId = anyRandomUint32(8);

  for (let i = 0; i < 8; ++i) devId[i] &= 0xff;

  return toHex(devId);
}

const {
  warn
} = console;

class OutPipe {
  constructor(device, port, hosted) {
    this.device = device;
    this.port = port;
    this.hosted = hosted;
    this._count = 0;
  }

  static from(bus, pkt, hosted) {
    const [idbuf, port] = pkt.jdunpack("b[8] u16");
    const id = toHex(idbuf);
    const dev = bus.device(id, false, pkt);
    return new OutPipe(dev, port, hosted);
  }

  get count() {
    return this._count;
  }

  get isOpen() {
    return this.device != null;
  }

  send(buf) {
    return this.sendData(buf, 0);
  }

  sendMeta(buf) {
    return this.sendData(buf, PIPE_METADATA_MASK);
  }

  async respondForEach(items, converter) {
    try {
      const n = items.length;

      for (let i = 0; i < n; ++i) {
        const item = items[i];
        const data = converter(item);
        await this.send(data);
      }
    } finally {
      await this.close();
    }
  }

  async sendData(buf, flags) {
    if (!this.device) {
      warn("sending data over closed pipe");
      return;
    }

    const cmd = this.port << PIPE_PORT_SHIFT | flags | this._count & PIPE_COUNTER_MASK;
    const pkt = Packet.from(cmd, buf);
    pkt.serviceIndex = JD_SERVICE_INDEX_PIPE;
    this.device.sendPktWithAck(pkt).then(() => {}, err => {
      console.log(err);
      this.free();
    });
    if (this.hosted) this.device.bus.processPacket(pkt);
    this._count++;
  }

  free() {
    this.device = null;
    this.port = null;
  }

  async close() {
    await this.sendData(new Uint8Array(0), PIPE_CLOSE_MASK);
    this.free();
  }

}

class InPipe extends JDClient {
  constructor(bus) {
    super();
    this.bus = bus;
    this._count = 0;
    this._handlePacket = this._handlePacket.bind(this);
    this.allocPort();
    this.mount(this.bus.selfDevice.subscribe(PACKET_RECEIVE, this._handlePacket));
  }

  get port() {
    return this._port;
  }

  get count() {
    return this._count;
  }

  get isOpen() {
    return this._port != null;
  }

  allocPort() {
    // eslint-disable-next-line no-constant-condition
    while (true) {
      this._port = 1 + randomUInt(511);
      const info = this.bus.selfDevice.port(this._port);

      if (!info.localPipe && !info.pipeType) {
        info.localPipe = this;
        break;
      }
    }
  }

  openCommand(cmd) {
    if (!this.isOpen) throwError("trying to access a closed pipe");
    const b = jdpack("b[8] u16 u16", [fromHex(this.bus.selfDeviceId), this._port, 0]);
    return Packet.from(cmd, b);
  }

  _handlePacket(pkt) {
    if (!pkt.isPipe) return;
    if (pkt.pipePort !== this._port) return;

    if ((pkt.serviceCommand & PIPE_COUNTER_MASK) == (this._count & PIPE_COUNTER_MASK)) {
      this._count++;
      this.emit(DATA, pkt);

      if (pkt.serviceCommand & PIPE_CLOSE_MASK) {
        this.close();
      }
    }
  }

  close() {
    if (this._port == null) return;
    this.emit(CLOSE);
    this._port = null;
    this.bus.selfDevice.port(this._port).localPipe = undefined;
    this.unmount();
  }

}

class InPipeReader extends InPipe {
  constructor(bus) {
    super(bus);
    this.done = signal();
    this.meta = [];
    this.output = [];
    this.mount(this.subscribe(DATA, pkt => {
      if (pkt.serviceCommand & PIPE_METADATA_MASK) this.meta.push(pkt);else this.output.push(pkt);
    }));
    this.mount(this.subscribe(CLOSE, this.done.signal));
  }

  async readData(timeout = 500) {
    const r = await this.readAll(timeout);
    return r.output.map(p => p.data).filter(b => !!(b === null || b === void 0 ? void 0 : b.length));
  }

  async readAll(timeout = 500) {
    const res = await this.bus.withTimeout(timeout, this.done.signalled);
    if (!res) throw new Error("Timeout reading pipe: " + timeout + "ms");
    return {
      meta: this.meta,
      output: this.output
    };
  }

}
/**
 * A Jacdac service client hosting registers, events.
 * @category JDOM
 */


class JDService extends JDNode {
  /**
   * @internal
   */
  constructor(device, serviceIndex) {
    super();
    this._reports = [];
    this._specification = null; // packets received since last announce

    this.registersUseAcks = false;
    this._clients = [];
    this.device = device;
    this.serviceIndex = serviceIndex;
    this.serviceClass = this.device.serviceClassAt(this.serviceIndex);
    const statusCodeChanged = this.event(exports.BaseEvent.StatusCodeChanged);
    statusCodeChanged.on(CHANGE, () => {
      // todo update status code with event payload
      const {
        data
      } = statusCodeChanged;
      console.debug(`${this}: status code changed event`, {
        data
      }); // schedule data update

      const statusCode = this.register(exports.BaseReg.StatusCode);
      statusCode === null || statusCode === void 0 ? void 0 : statusCode.clearGetTimestamp();
    });
  }
  /**
   * Gets the node identifier
   * @category JDOM
   */


  get id() {
    return `${this.nodeKind}:${this.device.deviceId}:${this.serviceIndex.toString(16)}`;
  }
  /**
   * Gets the ``SERVICE_NODE_NAME`` identifier
   * @category JDOM
   */


  get nodeKind() {
    return SERVICE_NODE_NAME;
  }
  /**
   * Gets the service name
   * @category JDOM
   */


  get name() {
    var _a;

    return (_a = serviceName(this.serviceClass)) === null || _a === void 0 ? void 0 : _a.toLowerCase();
  }
  /**
   * Gets the service name and parent names
   * @category JDOM
   */


  get friendlyName() {
    const parts = [this.device.friendlyName];
    if (this.device.services({
      serviceClass: this.serviceClass
    }).length > 1) parts.push(`[${this.serviceIndex.toString(16)}]`);
    return parts.join(".");
  }
  /**
   * Gets the service qualified name
   * @category JDOM
   */


  get qualifiedName() {
    return `${this.device.qualifiedName}[${this.serviceIndex.toString(16)}]`;
  }
  /**
   * Gets the device holding the service
   * @category JDOM
   */


  get parent() {
    return this.device;
  }

  get role() {
    return this._role;
  }

  set role(value) {
    if (value !== this._role) {
      this._role = value;
      this.emit(ROLE_CHANGE);
      this.emit(CHANGE);
    }
  }

  report(identifier) {
    return this._reports.find(r => r.registerIdentifier === identifier);
  }

  get reports() {
    return this._reports.slice(0);
  }

  get mixins() {
    // find all 0x2 services follow this service
    const r = [];
    const {
      serviceClasses,
      serviceLength
    } = this.device;

    for (let i = this.serviceIndex + 1; i < serviceLength && isMixinService(serviceClasses[i]); ++i) {
      r.push(this.device.service(i));
    }

    return r;
  }

  get isMixin() {
    return isMixinService(this.serviceClass);
  }

  get twin() {
    return this._twin;
  }

  set twin(server) {
    if (this._twin === server) return;
    if (this._twin) this._twin.twin = undefined;
    this._twin = server;
    server.twin = this;
    this.emit(CHANGE);
  }
  /**
   * Gets the ``reading`` register associated to this service, if the specification supports it.
   * @category Registers
   */


  get readingRegister() {
    var _a;

    if (!this._readingRegister) {
      const pkt = (_a = this.specification) === null || _a === void 0 ? void 0 : _a.packets.find(pkt => isReading(pkt));
      this._readingRegister = pkt && this.register(pkt.identifier);
    }

    return this._readingRegister;
  }
  /**
   * Gets the ``value`` register associated to this service, if the specification supports it.
   * @category Registers
   */


  get valueRegister() {
    var _a;

    if (!this._valueRegister) {
      const pkt = (_a = this.specification) === null || _a === void 0 ? void 0 : _a.packets.find(pkt => isValue(pkt));
      this._valueRegister = pkt && this.register(pkt.identifier);
    }

    return this._valueRegister;
  }
  /**
   * Gets the ``intensity`` register associated to this service, if the specification supports it.
   * @category Registers
   */


  get intensityRegister() {
    var _a;

    if (!this._intensityRegister) {
      const pkt = (_a = this.specification) === null || _a === void 0 ? void 0 : _a.packets.find(pkt => isIntensity(pkt));
      this._intensityRegister = pkt && this.register(pkt.identifier);
    }

    return this._intensityRegister;
  }
  /**
   * Gets the ``status_code`` register associated to this service, if the specification supports it.
   * @category Registers
   */


  get statusCodeRegister() {
    var _a;

    if (!this._statusCodeRegister) {
      const pkt = (_a = this.specification) === null || _a === void 0 ? void 0 : _a.packets.find(pkt => pkt.identifier === exports.SystemReg.StatusCode);
      this._statusCodeRegister = pkt && this.register(pkt.identifier);
    }

    return this._statusCodeRegister;
  }
  /**
   * Gets the service instance name, if resolved
   * @category Control
   */


  get instanceName() {
    const r = this.register(exports.SystemReg.InstanceName);
    return r === null || r === void 0 ? void 0 : r.stringValue;
  }
  /**
   * Resolves the service instance name, if resolved
   * @category Control
   */


  async resolveInstanceName() {
    const r = this.register(exports.SystemReg.InstanceName);
    await (r === null || r === void 0 ? void 0 : r.refresh());
    return r === null || r === void 0 ? void 0 : r.stringValue;
  }
  /**
   * Gets the specification of the service. Undefined if unknown
   * @category Services
   */


  get specification() {
    if (this._specification === null) this._specification = serviceSpecificationFromClassIdentifier(this.serviceClass);
    return this._specification;
  }

  get events() {
    var _a;

    return ((_a = this.specification) === null || _a === void 0 ? void 0 : _a.packets.filter(isEvent).map(info => this.event(info.identifier))) || [];
  }

  registers() {
    if (!this._registers) {
      const spec = this.specification;
      this._registers = ((spec === null || spec === void 0 ? void 0 : spec.packets) || []).filter(isRegister).map(pkt => new JDRegister(this, pkt.identifier));
    }

    return this._registers.slice(0);
  }
  /**
   * Gets the registers and events
   * @category JDOM
   */


  get children() {
    return [...this.registers(), ...this.events];
  }
  /**
   * Gets a register for the given code
   * @param registerCode register identifier as found in the specification
   * @returns a register instance (if found in specifiaction)
   * @category Registers
   */


  register(registerCode) {
    if (isNaN(registerCode)) return undefined; // cache known registers

    this.registers();

    let register = this._registers.find(reg => reg.code === registerCode); // we may not have a spec.


    if (!register) {
      const spec = this.specification;

      if (spec && !spec.packets.some(pkt => isRegister(pkt) && pkt.identifier === registerCode)) {
        if (Flags.diagnostics && !isOptionalReadingRegisterCode(registerCode)) console.debug(`attempting to access register ${exports.SystemReg[registerCode] || `0x${registerCode.toString(16)}`}`);
        return undefined;
      }

      this._registers.push(register = new JDRegister(this, registerCode));
    }

    return register;
  }
  /**
   * Gets an event for the given code
   * @param eventCode event identifier as found in the specification
   * @returns a event instance (if found in specifiaction)
   * @category Events
   */


  event(eventCode) {
    if (isNaN(eventCode)) return undefined;
    if (!this._events) this._events = [];

    let event = this._events.find(ev => ev.code === eventCode);

    if (!event) {
      const spec = this.specification;

      if (spec && !spec.packets.some(pkt => isEvent(pkt) && pkt.identifier === eventCode)) {
        if (Flags.diagnostics) console.debug(`attempting to access event ${exports.SystemEvent[eventCode] || `0x${eventCode.toString(16)}`}`);
        return undefined;
      }

      this._events.push(event = new JDEvent(this, eventCode));
    }

    return event;
  }
  /**
   * Send packet to the service server
   * @param pkt packet to send
   * @param ack acknolegment required
   * @category Packets
   */


  async sendPacketAsync(pkt, ack) {
    pkt.device = this.device;
    pkt.serviceIndex = this.serviceIndex;
    if (ack !== undefined) pkt.requiresAck = !!ack;
    if (pkt.requiresAck) await this.device.sendPktWithAck(pkt);else await pkt.sendCmdAsync(this.device);
    this.emit(PACKET_SEND, pkt); // invalid register after a command call to refresh their values asap

    if (pkt.isCommand && !pkt.isRegisterGet && !pkt.isRegisterSet) this.invalidateRegisterValues(pkt);
  }
  /**
   * Send a command to the service server
   * @param pkt packet to send
   * @param ack acknolegment required
   * @category Packets
   */


  sendCmdAsync(cmd, data, ack) {
    const pkt = data ? Packet.from(cmd, data) : Packet.onlyHeader(cmd);
    return this.sendPacketAsync(pkt, ack);
  }
  /**
   * Packs values and sends command to the service server
   * @param cmd packet to send
   * @param values unpacked values, layed as specified
   * @param ack acknolegment required
   * @category Packets
   */


  sendCmdPackedAsync(cmd, values, ack) {
    const spec = this.specification.packets.find(pkt => pkt.kind === "command" && pkt.identifier === cmd);
    const packFormat = spec === null || spec === void 0 ? void 0 : spec.packFormat;
    if (!packFormat) throw new Error("Unknown packing format");
    const data = values ? jdpack(packFormat, values) : undefined;
    return this.sendCmdAsync(cmd, data, ack);
  }
  /**
   * Send a command and await response to the service server
   * @param pkt packet to send
   * @param ack acknolegment required
   * @category Packets
   */


  sendCmdAwaitResponseAsync(pkt, timeout = 500) {
    const {
      bus
    } = this.device;
    return new Promise((resolve, reject) => {
      const handleRes = resp => {
        if (resp.serviceCommand == pkt.serviceCommand) {
          this.off(REPORT_RECEIVE, handleRes);
          if (resolve) resolve(resp);
          resolve = null;
        }
      };

      bus.delay(timeout).then(() => {
        if (!resolve) return;
        resolve = null;
        this.off(REPORT_RECEIVE, handleRes);
        reject(new Error(`timeout (${timeout}ms) waiting for response to ${pkt}`));
      });
      this.sendPacketAsync(pkt).then(() => {
        this.on(REPORT_RECEIVE, handleRes);
      }); // the handler remove either upon timeout,
      // or on first invocation of handleRes()
    });
  }
  /**
   * @internal
   */


  processPacket(pkt) {
    this.emit(PACKET_RECEIVE, pkt);

    if (pkt.isReport) {
      this.emit(REPORT_RECEIVE, pkt);

      if (pkt.isRegisterGet) {
        const id = pkt.registerIdentifier;
        const reg = this.register(id);
        if (reg) reg.processPacket(pkt);
      } else if (pkt.isEvent) {
        const ev = this.event(pkt.eventCode);
        if (ev) ev.processEvent(pkt);
      } else if (pkt.isCommand) {
        // this is a report...
        console.log("cmd report", {
          pkt
        });
      }
    } else if (pkt.isRegisterSet) {
      const id = pkt.registerIdentifier;
      const reg = this.register(id);
      if (reg) reg.processPacket(pkt);
    } else if (pkt.isCommand) {
      this.invalidateRegisterValues(pkt);
    }
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  invalidateRegisterValues(pkt) {
    //console.log(`clearing register get timestamp`, pkt)
    this.registers().filter(r => r.specification && !isConstRegister(r.specification)).forEach(r => r.clearGetTimestamp());
  }
  /**
   * @internal
   */


  compareTo(b) {
    return this.serviceClass - b.serviceClass || strcmp(this.device.deviceId, b.device.deviceId) || this.serviceIndex - b.serviceIndex;
  }

  get clients() {
    var _a;

    return ((_a = this._clients) === null || _a === void 0 ? void 0 : _a.slice(0)) || [];
  }

  addClient(client) {
    if (client && this._clients.indexOf(client) < 0) {
      this._clients.push(client);

      this.emit(SERVICE_CLIENT_ADDED, client);
    }
  }

  removeClient(client) {
    const i = this._clients.indexOf(client);

    if (i > -1) {
      this._clients.splice(i, 1);

      this.emit(SERVICE_CLIENT_REMOVED, client);
    }
  }

  async receiveWithInPipe(cmd, packFormat, timeout) {
    const inp = new InPipeReader(this.device.bus);
    await this.sendPacketAsync(inp.openCommand(cmd), true);
    const recv = [];

    for (const buf of await inp.readData(timeout)) {
      const values = jdunpack(buf, packFormat);
      recv.push(values);
    }

    return recv;
  }

}

function trgbToValues(trgb) {
  return [trgb >> 16 & 0xff, trgb >> 8 & 0xff, trgb & 0xff, trgb >> 24 & 0xff];
}

class LEDController extends JDEventSource {
  constructor(service, command) {
    super();
    this.service = service;
    this.command = command;
  }

  async blink(from, to, interval, repeat) {
    const on = jdpack("u8 u8 u8 u8", trgbToValues(from));
    const off = jdpack("u8 u8 u8 u8", trgbToValues(to));
    const {
      bus
    } = this.service.device;

    for (let i = 0; i < repeat; ++i) {
      await this.service.sendCmdAsync(this.command, on);
      await bus.delay(interval - 1);
      await this.service.sendCmdAsync(this.command, off);
      await bus.delay(interval - 1);
    }
  }

}
/**
 * Collects packet statistics about the device
 * @category JDOM
 */


class DeviceStatsMonitor extends JDEventSource {
  /**
   * @internal
   */
  constructor() {
    super(); // counter

    this._receivedPackets = 0;
    this._restarts = 0;
    this._announce = 0; // horizon

    this._data = Array(0xf << 2).fill(0).map(() => ({
      received: 0,
      total: 0,
      restarts: 0
    }));
    this._dataIndex = 0;
  }
  /**
   * Number of announce packets received by the device
   **/


  get announce() {
    return this._announce;
  }
  /**
   * Average packet dropped per announce period
   * @category Statistics
   */


  get dropped() {
    const r = this._data.filter(e => !!e.total) // ignore total 0
    .reduce((s, e) => s + (e.total - e.received), 0) / this._data.length || 0;
    return r;
  }
  /**
   * Number of restarts within the last 64 announce packets
   */


  get restarts() {
    const r = this._data.reduce((s, e) => s + e.restarts, 0);

    return r;
  }
  /**
   * Gets the current stats
   */


  get current() {
    const {
      dropped,
      restarts,
      announce
    } = this;
    return {
      dropped,
      restarts,
      announce
    };
  }
  /**
   * @internal
   */


  processAnnouncement(pkt) {
    this._announce++;
    const {
      current: oldCurrent
    } = this; // collect metrics

    const received = this._receivedPackets;
    const total = pkt.data[2];
    const restarts = this._restarts;
    this._data[this._dataIndex] = {
      received,
      total,
      restarts
    };
    this._dataIndex = (this._dataIndex + 1) % this._data.length; // reset counter

    this._receivedPackets = 0;
    this._restarts = 0;
    const {
      current
    } = this;
    if (oldCurrent.dropped !== current.dropped || oldCurrent.restarts !== current.restarts) this.emit(CHANGE);
  }
  /**
   * @internal
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  processPacket(pkt) {
    this._receivedPackets++;
  }
  /**
   * @internal
   */


  processRestart() {
    this._restarts++;
    this._announce = 0;
  }

}
/**
 * A Jacdac device hosting services.
 * @category JDOM
 */


class JDDevice extends JDNode {
  /**
   * @internal
   */
  constructor(bus, deviceId, pkt) {
    super();
    this._flashing = false;
    /**
     * Quality of service statistics for this device
     * @category Diagnostics
     */

    this.stats = new DeviceStatsMonitor();
    this.bus = bus;
    this.deviceId = deviceId;
    this.connected = true;
    this._lost = false;
    this._identifying = false;
    this._source = pkt === null || pkt === void 0 ? void 0 : pkt.sender;
    this._replay = !!(pkt === null || pkt === void 0 ? void 0 : pkt.replay);
  }
  /**
   * Gets a random device id for the lifetime of this object.
   */


  get anonymizedDeviceId() {
    if (!this._anonymizedId) this._anonymizedId = randomDeviceId();
    return this._anonymizedId;
  }
  /**
   * Gets a description of the device.
   * @returns a descriptive string for this device
   * @category Diagnostics
   */


  describe() {
    const ignoredServices = [SRV_CONTROL, SRV_LOGGER];
    return this.toString() + (this.isPhysical ? "" : " (sim)") + ": " + this.services().filter(srv => ignoredServices.indexOf(srv.serviceClass) < 0).map(s => {
      var _a;

      return s.instanceName || ((_a = s.specification) === null || _a === void 0 ? void 0 : _a.camelName) || s.serviceClass.toString(16);
    }).join(", ");
  }
  /**
   * Gets a unique identifier for this device in the bus
   * @category JDOM
   */


  get id() {
    return `${this.nodeKind}:${this.deviceId}`;
  }
  /**
   * Gets the short id of the device
   * @category JDOM
   */


  get name() {
    return this.shortId;
  }
  /**
   * Identifies node as a device
   * @category JDOM
   */


  get nodeKind() {
    return DEVICE_NODE_NAME;
  }
  /**
   * Indicates if the devices is a physical device, not emulated.
   * @category Transport
   */


  get isPhysical() {
    return this._source === USB_TRANSPORT || this._source === BLUETOOTH_TRANSPORT || this._source === SERIAL_TRANSPORT || this._source === PACKETIO_TRANSPORT || this._source === WEBSOCKET_TRANSPORT;
  }
  /**
   * Indicates the source of packets
   * @category Transport
   */


  get source() {
    return this._source;
  }
  /**
   * Indicates if the device is part of a trace replay
   * @category Transport
   */


  get replay() {
    return this._replay;
  }
  /**
   * Gets the device short name
   * @category JDOM
   */


  get friendlyName() {
    return this.shortId;
  }
  /**
   * Gets the device short name
   * @category JDOM
   */


  get qualifiedName() {
    return this.shortId;
  }
  /**
   * Indicates if service information is available.
   * This happens after a announce packet has been received.
   * @category Lifecycle
   */


  get announced() {
    var _a;

    return !!((_a = this._servicesData) === null || _a === void 0 ? void 0 : _a.length);
  }
  /**
   * Gets the control announce flag from the annouce packet.
   * @category Control
   */


  get announceFlags() {
    return this._servicesData ? read16(this._servicesData, 0) : 0;
  }
  /**
   * Gets the restart counter from the announce packet.
   * @category Control
   */


  get restartCounter() {
    return this.announceFlags & exports.ControlAnnounceFlags.RestartCounterSteady;
  }
  /**
   * Gets the status light announce flags from the announce packet.
   * @category Control
   */


  get statusLightFlags() {
    return this.announceFlags & exports.ControlAnnounceFlags.StatusLightRgbFade;
  }
  /**
   * Indicates if the device is announced as a client
   * @category Control
   */


  get isClient() {
    return !!(this.announceFlags & exports.ControlAnnounceFlags.IsClient);
  }
  /**
   * Gets the number of packets sent since the last announce packet,
   * as read from the announce packet.
   * @category Control
   */


  get packetCount() {
    var _a;

    return ((_a = this._servicesData) === null || _a === void 0 ? void 0 : _a[2]) || 0;
  }
  /**
   * Gets the device short identifier
   * @category JDOM
   */


  get shortId() {
    // TODO measure if caching is worth it
    if (!this._shortId) this._shortId = shortDeviceId(this.deviceId);
    return this._shortId;
  }
  /**
   * Gets the bus instance hosting this device.
   * @category JDOM
   */


  get parent() {
    return this.bus;
  }
  /**
   * Gets the firmware information if any.
   * @category Firmware
   */


  get firmwareInfo() {
    var _a, _b, _c;

    const ctrl = this.service(0);
    const deviceId = this.deviceId;
    const name = (_a = ctrl === null || ctrl === void 0 ? void 0 : ctrl.register(exports.ControlReg.DeviceDescription)) === null || _a === void 0 ? void 0 : _a.stringValue;
    const version = this.firmwareVersion;
    const productIdentifier = (_b = ctrl === null || ctrl === void 0 ? void 0 : ctrl.register(exports.ControlReg.ProductIdentifier)) === null || _b === void 0 ? void 0 : _b.uintValue;
    const bootloaderProductIdentifier = (_c = ctrl === null || ctrl === void 0 ? void 0 : ctrl.register(exports.ControlReg.BootloaderProductIdentifier)) === null || _c === void 0 ? void 0 : _c.uintValue;
    const ready = version && (productIdentifier !== undefined || bootloaderProductIdentifier !== undefined);
    return ready ? {
      deviceId,
      name,
      version,
      productIdentifier,
      bootloaderProductIdentifier
    } : undefined;
  }

  refreshFirmwareInfo() {
    var _a; // listen for specific registers


    const ctrl = (_a = this._services) === null || _a === void 0 ? void 0 : _a[0];
    const firmwareRegs = [(exports.ControlReg.ProductIdentifier, exports.ControlReg.FirmwareVersion, exports.ControlReg.BootloaderProductIdentifier)];
    firmwareRegs.forEach(reg => ctrl.register(reg).once(REPORT_UPDATE, () => {
      this.emitPropagated(DEVICE_FIRMWARE_INFO);
      this.emitPropagated(CHANGE);
    }));
  }
  /**
   * Indicates if no packet from this device has been observed in a while.
   * @category Lifecycle
   */


  get lost() {
    return this._lost;
  }
  /**
   * Sets the lost status
   * @category Lifecycle
   * @internal
   */


  set lost(v) {
    if (!!v === this._lost) return; // something changed

    this._lost = !!v;

    if (this.lost) {
      this.emit(LOST);
      this.bus.emit(DEVICE_LOST, this);
    } else {
      this.emit(FOUND);
      this.bus.emit(DEVICE_FOUND, this);
    }

    this.emit(CHANGE);
    this.bus.emit(DEVICE_CHANGE, this);
    this.bus.emit(CHANGE);
  }
  /**
   * A flashing sequence is in progress
   * @category Firmware
   */


  get flashing() {
    return this._flashing;
  }
  /**
   * Sets the flashing sequence state
   * @category Firmware
   */


  set flashing(value) {
    if (value !== this._flashing) {
      this._flashing = value;
      this.emit(CHANGE);
      this.bus.emit(DEVICE_CHANGE, this);
      this.bus.emit(CHANGE);
      if (this._flashing) this.bus.sendStopStreaming();
    }
  }
  /**
   * Gets the number of events received by the service clients in this device
   * @category Lifecycle
   */


  get eventCounter() {
    return this._eventCounter;
  }
  /**
   * @internal
   */


  set eventCounter(v) {
    this._eventCounter = v;
  }
  /**
   * Indicates if the device contains at least one service matching the service class
   * @param serviceClass service class to match
   * @returns true if at least one service present
   * @category Services
   */


  hasService(serviceClass) {
    if (!this.announced) return false;
    if (serviceClass === 0) return true; // skip first 4 bytes

    for (let i = 4; i < this._servicesData.length; i += 4) {
      const sc = getNumber(this._servicesData, exports.NumberFormat.UInt32LE, i);
      if (isInstanceOf(sc, serviceClass)) return true;
    }

    return false;
  }
  /**
   * Gets or allocates a pipe port
   * @param id identifier of the port
   * @returns a pipe port
   * @category Services
   */


  port(id) {
    if (!this._ports) this._ports = {};
    const key = id + "";
    const ex = this._ports[key];
    if (!ex) return this._ports[key] = {};
    return ex;
  }
  /**
   * Gets the number of services hosted by the device
   * @category Services
   */


  get serviceLength() {
    if (!this.announced) return 0;
    return this._servicesData.length >> 2;
  }
  /**
   * Gets the service class at a given index
   * @param index index of the service
   * @returns service class
   * @category Services
   */


  serviceClassAt(index) {
    if (index == 0) return 0;
    index <<= 2;
    if (!this.announced || index + 4 > this._servicesData.length) return undefined;
    return read32(this._servicesData, index);
  }
  /**
   * Gets the list of service classes
   * @category Services
   */


  get serviceClasses() {
    const r = [];
    const n = this.serviceLength;

    for (let i = 0; i < n; ++i) r.push(this.serviceClassAt(i));

    return r;
  }

  initServices(force) {
    if (force) this._services = undefined;

    if (!this._services && this._servicesData) {
      this._statusLight = undefined;
      const n = this.serviceLength;
      const s = [];

      for (let i = 0; i < n; ++i) s.push(new JDService(this, i));

      this._services = s;
      this.lastServiceUpdate = this.bus.timestamp;
      this.refreshFirmwareInfo();
    }
  }
  /**
   * Gets the service client at the given service index
   * @param serviceIndex index of the service client
   * @returns service client
   * @category Services
   */


  service(serviceIndex) {
    if (!this.announced) return undefined;
    this.initServices();
    serviceIndex = serviceIndex | 0;
    return this._services && this._services[serviceIndex];
  }
  /**
   * Gets a filtered list of service clients.
   * @param options filters for services
   * @returns services matching the filter
   * @category Services
   */


  services(options) {
    var _a;

    if (!this.announced) return [];
    if ((options === null || options === void 0 ? void 0 : options.serviceIndex) >= 0) return [this.service(options === null || options === void 0 ? void 0 : options.serviceIndex)];
    if ((options === null || options === void 0 ? void 0 : options.serviceName) && (options === null || options === void 0 ? void 0 : options.serviceClass) > -1) throw Error("serviceClass and serviceName cannot be used together");
    let sc = serviceClass(options === null || options === void 0 ? void 0 : options.serviceName);
    if (sc === undefined || sc < 0) sc = options === null || options === void 0 ? void 0 : options.serviceClass;
    if (sc === undefined) sc = -1;
    this.initServices();
    let r = ((_a = this._services) === null || _a === void 0 ? void 0 : _a.slice()) || [];
    if (sc > -1) r = r.filter(s => s.serviceClass == sc);
    if (options === null || options === void 0 ? void 0 : options.specification) r = r.filter(s => !!s.specification);
    const mixins = options === null || options === void 0 ? void 0 : options.mixins;
    if (mixins !== undefined) r = r.filter(s => s.isMixin === mixins);
    return r;
  }
  /**
   * Gets the list of child services.
   * @category JDOM
   */


  get children() {
    return this.services();
  }
  /**
   * @internal
   */


  sendCtrlCommand(cmd, payload = null) {
    const pkt = !payload ? Packet.onlyHeader(cmd) : Packet.from(cmd, payload);
    pkt.serviceIndex = JD_SERVICE_INDEX_CTRL;
    return pkt.sendCmdAsync(this);
  }
  /**
   * @internal
   */


  processAnnouncement(pkt) {
    this.stats.processAnnouncement(pkt);
    let changed = false;
    const w0 = this._servicesData ? getNumber(this._servicesData, exports.NumberFormat.UInt32LE, 0) : 0;
    const w1 = getNumber(pkt.data, exports.NumberFormat.UInt32LE, 0); // compare service data

    const servicesChanged = !bufferEq(pkt.data, this._servicesData, 4);
    this._servicesData = pkt.data; // check for restart

    if (w1 && (w1 & JD_ADVERTISEMENT_0_COUNTER_MASK) < (w0 & JD_ADVERTISEMENT_0_COUNTER_MASK)) {
      this.stats.processRestart();
      this.initServices(true);
      this.bus.emit(DEVICE_RESTART, this);
      this.emit(RESTART);
      changed = true;
    } // notify that services got updated


    if (servicesChanged) {
      if (!changed) this.initServices(true);
      this.bus.emit(DEVICE_ANNOUNCE, this);
      this.emit(ANNOUNCE);
      changed = true;
    } // notify that we've received an announce packet


    this.bus.emit(DEVICE_PACKET_ANNOUNCE, this);
    this.emit(PACKET_ANNOUNCE); // notify of any changes

    if (changed) {
      this.bus.emit(DEVICE_CHANGE, this);
      this.bus.emit(CHANGE);
      this.emit(CHANGE);
    }
  }
  /**
   * @internal
   */


  processPacket(pkt) {
    this.stats.processPacket(pkt);
    this.lost = false;
    this.emit(PACKET_RECEIVE, pkt);
    if (pkt.isReport) this.emit(PACKET_REPORT, pkt);else if (pkt.isEvent) this.emit(PACKET_EVENT, pkt);
    const service = this.service(pkt.serviceIndex);
    if (service) service.processPacket(pkt);
  }
  /**
   * @internal
   */


  disconnect() {
    this.connected = false;
    this.emit(DISCONNECT);
    this.emit(CHANGE);
  }
  /**
   * Gets a controller for the status light. Returns undefined if the device does not support a status light.
   * @category Control
   */


  get statusLight() {
    if (!this._statusLight && this.statusLightFlags !== exports.ControlAnnounceFlags.StatusLightNone) this._statusLight = new LEDController(this.service(0), exports.ControlCmd.SetStatusLight);
    return this._statusLight;
  }
  /**
   * Sends an ``identify`` command to the device
   * @category Lifecycle
   */


  async identify() {
    if (this._identifying) return;

    try {
      this._identifying = true;
      this.emit(CHANGE);
      const statusLight = this.statusLight;
      if (statusLight) await statusLight.blink(0x0000ff, 0, 262, 4);else {
        const ctrl = this.service(0);
        await ctrl.sendCmdAsync(exports.ControlCmd.Identify, undefined, false);
        await this.bus.delay(IDENTIFY_DURATION);
      }
    } catch (e) {
      this.emit(ERROR, e);
    } finally {
      this._identifying = false;
      this.emit(CHANGE);
    }
  }
  /**
   * Indicates the device should be identifying.
   * @category Lifecycle
   */


  get identifying() {
    return this._identifying;
  }
  /**
   * Sends a ``reset`` command to the device
   * @category Lifecycle
   */


  reset() {
    var _a;

    return (_a = this.service(0)) === null || _a === void 0 ? void 0 : _a.sendCmdAsync(exports.ControlCmd.Reset);
  }
  /**
   * Tries to retrive the product identifier from the device
   * @param retry number of devices
   * @returns promise that returns product identifier if received
   * @category Control
   */


  async resolveProductIdentifier(retry = 0) {
    var _a;

    const fwIdRegister = (_a = this.service(0)) === null || _a === void 0 ? void 0 : _a.register(exports.ControlReg.ProductIdentifier);
    if (!fwIdRegister) return undefined;

    while (retry-- >= 0 && fwIdRegister.data === undefined) await fwIdRegister.refresh(true);

    return fwIdRegister.uintValue;
  }
  /**
   * Returns the product identifier synchronously. If needed, tries to refresh the value in the background.
   * @category Control
   */


  get productIdentifier() {
    var _a;

    const reg = (_a = this.service(0)) === null || _a === void 0 ? void 0 : _a.register(exports.ControlReg.ProductIdentifier);
    const v = reg === null || reg === void 0 ? void 0 : reg.uintValue;
    if (reg && v === undefined) reg === null || reg === void 0 ? void 0 : reg.refresh(true);
    return v;
  }
  /**
   * Gets the elapsed time since boot in milli-seconds
   * @category Control
   */


  get uptime() {
    var _a, _b;

    const reg = (_a = this.service(0)) === null || _a === void 0 ? void 0 : _a.register(exports.ControlReg.Uptime);
    const v = (_b = reg === null || reg === void 0 ? void 0 : reg.unpackedValue) === null || _b === void 0 ? void 0 : _b[0];
    if (reg && v === undefined) reg === null || reg === void 0 ? void 0 : reg.refresh(true);
    let uptime = undefined;

    if (v !== undefined) {
      // compute offset
      uptime = v / 1000 + this.bus.timestamp - reg.lastDataTimestamp;
    }

    return uptime;
  }
  /**
   * Returns the firmware version synchronously. If needed, tries to refresh the value in the background.
   * @category Control
   */


  get firmwareVersion() {
    var _a;

    const reg = (_a = this.service(0)) === null || _a === void 0 ? void 0 : _a.register(exports.ControlReg.FirmwareVersion);
    const v = reg === null || reg === void 0 ? void 0 : reg.stringValue;
    if (reg && v === undefined) reg === null || reg === void 0 ? void 0 : reg.refresh(true);
    return v;
  }

  initAcks() {
    if (this._ackAwaiting) return;
    let drops = 0;
    let resends = 0;
    this._ackAwaiting = [];
    const cleanUp = this.subscribe(PACKET_REPORT, rep => {
      if (rep.serviceIndex != JD_SERVICE_INDEX_CRC_ACK) return;
      let numdone = 0;

      for (const aa of this._ackAwaiting) {
        if (aa.pkt && aa.pkt.crc == rep.serviceCommand) {
          //console.log(`ack`, aa.pkt)
          aa.pkt = null;
          numdone++;
          aa.okCb();
        }
      }

      if (numdone) this._ackAwaiting = this._ackAwaiting.filter(aa => !!aa.pkt);
    });

    const resend = () => {
      let numdrop = 0;

      for (const aa of this._ackAwaiting) {
        if (aa.pkt) {
          if (--aa.retriesLeft < 0) {
            drops++;
            aa.pkt.meta[META_ACK_FAILED] = true;
            aa.pkt = null;
            aa.errCb();
            numdrop++;
            if (Flags.diagnostics) console.debug(`ack: ${this.shortId} drop ${aa.pkt} (${drops} drops, ${resends} resends)`);
          } else {
            resends++;
            aa.pkt.sendCmdAsync(this);
            if (Flags.diagnostics) console.debug(`ack: ${this.shortId} resend ${aa.pkt} (${drops} drops, ${resends} resends)`);
          }
        }
      }

      if (numdrop) this._ackAwaiting = this._ackAwaiting.filter(aa => !!aa.pkt);
      if (Flags.diagnostics) console.debug(`ack: ${this.shortId} awaits ${this._ackAwaiting.length}`);

      if (this._ackAwaiting.length > 0) {
        this.bus.scheduler.setTimeout(resend, Math.random() * (ACK_MAX_DELAY - ACK_MIN_DELAY) + ACK_MIN_DELAY);
      } else {
        this._ackAwaiting = undefined;
        cleanUp();
      }
    }; // start loop


    this.bus.scheduler.setTimeout(resend, 40);
  }
  /**
   * @internal
   */


  sendPktWithAck(pkt) {
    // no acks possible when bus is passive
    pkt.requiresAck = !this.bus.passive;
    this.initAcks();
    return new Promise((resolve, reject) => {
      const ack = {
        pkt,
        retriesLeft: 4,
        okCb: resolve,
        errCb: () => {
          const e = new Error("No ACK for " + pkt.toString());
          setAckError(e);
          reject(e);
        }
      };

      this._ackAwaiting.push(ack);

      pkt.sendCmdAsync(this);
    });
  }
  /**
   * @internal
   */


  async floodPing(numPkts = 100, size = 32) {
    const pkt = Packet.jdpacked(exports.ControlCmd.FloodPing, "u32 u32 u8", [numPkts, 0x1000, size]);
    pkt.serviceIndex = JD_SERVICE_INDEX_CTRL;
    await this.sendPktWithAck(pkt);
  }

}
/* eslint-disable @typescript-eslint/no-explicit-any */

/** @internal */


class WallClockScheduler {
  constructor() {
    this._now = typeof performance !== "undefined" ? () => performance.now() : () => Date.now();
    this._startTime = this._now();
  }

  get timestamp() {
    return this._now() - this._startTime;
  }

  resetTime(delta = 0) {
    this._startTime = this._now() - delta;
  }

  setTimeout(handler, delay, ...args) {
    return setTimeout(handler, delay, args);
  }

  clearTimeout(handle) {
    clearTimeout(handle);
  }

  setInterval(handler, delay, ...args) {
    return setInterval(handler, delay, args);
  }

  clearInterval(handle) {
    clearInterval(handle);
  }

}

const BL_SUBPAGE_SIZE = 208;
const BL_RETRIES = 15;
const BL_SESSION_DELAY = 5;
const BL_PAGE_DELAY = 5;
let _startTime = 0;
const uf2ExtTags = {
  version: -0x9fc7bc,
  name: -0x650d9d,
  pageSize: 0x0be9f7,
  productIdentifier: 0xc8a729
};

function timestamp() {
  if (!_startTime) _startTime = Date.now();
  return Date.now() - _startTime;
}

function log(msg) {
  console.log(`BL [${timestamp()}ms]: ${msg}`);
}

class FlashClient {
  constructor(bus, adpkt) {
    this.bus = bus;
    const d = bufferToArray(adpkt.data, exports.NumberFormat.UInt32LE);
    this.pageSize = d[1];
    this.flashSize = d[2];
    this.dev_class = d[3];
    this.device = adpkt.device;
    this.handlePacket = this.handlePacket.bind(this);
  }

  handlePacket(pkt) {
    if (pkt.serviceCommand == exports.BootloaderCmd.PageData) this.lastStatus = pkt;
  }

  start() {
    this.device.on(PACKET_REPORT, this.handlePacket);
  }

  stop() {
    this.device.off(PACKET_REPORT, this.handlePacket);
  }

  async sendCommandAsync(p) {
    p.serviceIndex = 1;
    await p.sendCmdAsync(this.device);
  }

  async startFlashAsync() {
    this.sessionId = Math.random() * 0x10000000 | 0;

    for (const d of this.classClients) {
      d.start();
      log(`flashing ${d.device.shortId}; available flash=${d.flashSize / 1024}kb; page=${d.pageSize}b`);
    }

    const setsession = Packet.jdpacked(exports.BootloaderCmd.SetSession, "u32", [this.sessionId]);
    this.allPending();

    for (let i = 0; i < BL_RETRIES; ++i) {
      for (const d of this.classClients) {
        if (d.pending) {
          if (d.lastStatus && d.lastStatus.getNumber(exports.NumberFormat.UInt32LE, 0) == this.sessionId) {
            d.pending = false;
          } else {
            d.lastStatus = null;
            log(`set session ${this.sessionId} on ${d.device}`);
            await d.sendCommandAsync(setsession);
          }

          await this.bus.delay(BL_SESSION_DELAY);
        }
      }

      if (this.numPending() == 0) break;
      await this.waitForStatusAsync();
    }

    if (this.numPending()) throw new Error("Can't set session id");
  }

  async endFlashAsync() {
    for (const f of this.classClients) {
      await this.bus.delay(10);
      await f.device.sendCtrlCommand(exports.ControlCmd.Reset);
    }
  }

  allPending() {
    for (const c of this.classClients) {
      c.pending = true;
      c.lastStatus = null;
    }
  }

  numPending() {
    let num = 0;

    for (const c of this.classClients) if (c.pending) num++;

    return num;
  }

  async waitForStatusAsync() {
    for (let i = 0; i < 100; ++i) {
      if (this.classClients.every(c => c.lastStatus != null)) break;
      await this.bus.delay(5);
    }
  }

  async flashPage(page) {
    const pageAddr = page.targetAddress;
    const pageSize = this.pageSize;
    const numSubpage = (pageSize + BL_SUBPAGE_SIZE - 1) / BL_SUBPAGE_SIZE | 0;
    log(`flash ${prettySize(this.pageSize)} at ${(pageAddr & 0xffffff).toString(16)}`);
    if (page.data.length != this.pageSize) throw new Error("invalid page size");

    for (const f of this.classClients) f.lastStatus = null;

    this.allPending();

    for (let i = 0; i < BL_RETRIES; ++i) {
      log(`  attempt ${i}`);
      let currSubpage = 0;

      for (let suboff = 0; suboff < pageSize; suboff += BL_SUBPAGE_SIZE) {
        let sz = BL_SUBPAGE_SIZE;
        if (suboff + sz > pageSize) sz = pageSize - suboff;
        log(`send sub page ${currSubpage}/${numSubpage - 1} at ${suboff.toString(16)}[${sz}]`);
        const hd = jdpack("u32 u16 u8 u8 u32 u32 u32 u32 u32", [pageAddr, suboff, currSubpage++, numSubpage - 1, this.sessionId, 0, 0, 0, 0]);
        assert(hd.length == 4 * 7);
        const p = Packet.from(exports.BootloaderCmd.PageData, bufferConcat(hd, page.data.slice(suboff, suboff + sz))); // in first round, just broadcast everything
        // in other rounds, broadcast everything except for last packet

        if (i == 0 || currSubpage < numSubpage) await p.sendAsMultiCommandAsync(this.bus, SRV_BOOTLOADER);else {
          for (const f of this.classClients) if (f.pending) {
            f.lastStatus = null;
            await f.sendCommandAsync(p);
          }
        }
        await this.bus.delay(BL_PAGE_DELAY);
      }

      await this.waitForStatusAsync();

      for (const f of this.classClients) {
        if (f.pending) {
          let err = "";

          if (f.lastStatus) {
            const [session_id, page_error, pageAddrR] = jdunpack(f.lastStatus.data, "u32 u32 u32");
            if (session_id != this.sessionId) err = "invalid session_id";else if (pageAddrR != pageAddr) err = "invalid page address";else if (page_error) err = "err: " + (exports.BootloaderError[page_error] || page_error);
          } else {
            err = "timeout";
          }

          if (err) {
            f.lastStatus = null;
            log(`retry ${f.device}: ${err}`);
          } else {
            f.pending = false;
          }
        }
      }

      if (this.numPending() == 0) {
        log(`page ${pageAddr & 0xffffff} done, ${i}/${BL_RETRIES} retries`);
        return;
      }
    }

    throw new Error("too many retries");
  }

  async flashFirmwareBlob(fw, progress) {
    const waitCycles = 15;
    const total = fw.pages.length + waitCycles + 3;
    let idx = 0;

    const prog = () => {
      if (progress) progress(100 * idx / total);
      idx++;
    };

    try {
      prog();
      await this.startFlashAsync();
      prog();

      for (const page of fw.pages) {
        await this.flashPage(page);
        prog();
      }
    } finally {
      try {
        // even if something failed, try to reset everyone
        await this.endFlashAsync();
        prog(); // wait until we're out of bootloader mode; otherwise the subsequent scan will keep devices in BL mode

        for (let i = 0; i < waitCycles; ++i) {
          await this.bus.delay(150);
          prog();
        }
      } finally {
        // even if resetting failed, unregister event listeners
        for (const d of this.classClients) {
          d.stop();
        }
      }
    }
  }

}

const UF2_MAGIC_START0 = 0x0a324655;
const UF2_MAGIC_START1 = 0x9e5d5157;
const UF2_MAGIC_END = 0x0ab16f30;
/**
 * Parses a UF2 firmware binary into firmware blobs
 * @param uf2
 * @param store
 * @returns
 * @category Firmware
 */

function parseUF2Firmware(uf2, store) {
  const blobs = [];
  let currBlob;

  for (let off = 0; off < uf2.length; off += 512) {
    const header = uf2.slice(off, off + 32);
    const [magic0, magic1, flags, trgaddr, payloadSize, blkNo, numBlocks, familyID] = bufferToArray(header, exports.NumberFormat.UInt32LE);
    if (magic0 != UF2_MAGIC_START0 || magic1 != UF2_MAGIC_START1 || getNumber(uf2, exports.NumberFormat.UInt32LE, off + 512 - 4) != UF2_MAGIC_END) throw new Error("invalid UF2");

    if (blkNo == 0) {
      flush();
      currBlob = {
        pages: [],
        productIdentifier: familyID,
        version: "",
        pageSize: 1024,
        name: "FW " + familyID.toString(16),
        store
      };
    }

    if (flags & 0x8000) parseExtTags(uf2.slice(off + 32 + payloadSize, off + 512));
    const pageSize = currBlob.pageSize || 1024;
    let currPage = currBlob.pages[currBlob.pages.length - 1];

    if (!currPage || !(currPage.targetAddress <= trgaddr && trgaddr < currPage.targetAddress + pageSize)) {
      currPage = {
        targetAddress: trgaddr & ~(pageSize - 1),
        data: new Uint8Array(pageSize)
      };
      currPage.data.fill(0xff);
      currBlob.pages.push(currPage);
    }

    currPage.data.set(uf2.slice(off + 32, off + 32 + payloadSize), trgaddr - currPage.targetAddress);
  }

  flush();
  return blobs;

  function flush() {
    if (currBlob) blobs.push(currBlob);
  }

  function parseExtTags(buf) {
    let sz = 0;

    for (let i = 0; i < buf.length; i += sz) {
      sz = buf[i];
      if (sz == 0) break;
      const desig = getNumber(buf, exports.NumberFormat.UInt32LE, i) >>> 8;

      for (const key of Object.keys(uf2ExtTags)) {
        const tg = uf2ExtTags[key];

        if (desig == Math.abs(tg)) {
          let v;

          if (tg < 0) {
            v = bufferToString(buf.slice(i + 4, i + sz));
          } else {
            v = getNumber(buf, exports.NumberFormat.UInt32LE, i + 4);
          }

          const cbany = currBlob;
          cbany[key] = v;
          break;
        }
      }

      sz = sz + 3 & ~3;
    }
  }
}
/**
 * Parse a UF2 firmware file and extracts firmware blobs
 * @param blob
 * @param store
 * @returns
 * @category Firmware
 */


async function parseFirmwareFile(blob, store) {
  const data = await readBlobToUint8Array(blob);
  const buf = new Uint8Array(data);
  const uf2Blobs = parseUF2Firmware(buf, store);
  return uf2Blobs;
}

async function createFlashers(bus) {
  const flashers = [];
  const numTries = 10;
  const tryDelay = 10;

  const handlePkt = p => {
    // note that we may get this even if recovery==false due to someone else asking
    // (eg when the user set the recovery mode toggle)
    if (p.serviceIndex == 1 && p.serviceCommand == CMD_ADVERTISEMENT_DATA && p.getNumber(exports.NumberFormat.UInt32LE, 0) == SRV_BOOTLOADER) {
      if (!flashers.find(f => f.device.deviceId == p.deviceIdentifier)) {
        log(`new flasher`);
        flashers.push(new FlashClient(bus, p));
      }
    }
  };

  try {
    bus.on(PACKET_REPORT, handlePkt);

    for (let i = 0; i < numTries; ++i) {
      // also ask BL services if any
      const bl_announce = Packet.onlyHeader(CMD_ADVERTISEMENT_DATA);
      await bl_announce.sendAsMultiCommandAsync(bus, SRV_BOOTLOADER);
      await bus.delay(tryDelay);
    }
  } finally {
    bus.off(PACKET_REPORT, handlePkt);
  }

  return flashers;
}
/**
 * Indicates if a firmware blob is applicated to the device information
 * @param dev
 * @param blob
 * @returns
 * @category Firmware
 */


function updateApplicable(dev, blob) {
  return dev && blob && dev.bootloaderProductIdentifier == blob.productIdentifier && dev.version !== blob.version;
}
/**
 * Flash firmware blob onto device
 * @param bus
 * @param blob
 * @param updateCandidates
 * @param ignoreFirmwareCheck
 * @param progress
 * @returns
 * @category Firmware
 */


async function flashFirmwareBlob(bus, blob, updateCandidates, ignoreFirmwareCheck, progress) {
  if (!(updateCandidates === null || updateCandidates === void 0 ? void 0 : updateCandidates.length)) return;
  _startTime = Date.now();
  log(`resetting ${updateCandidates.length} device(s)`);

  for (const d of updateCandidates) {
    const device = bus.device(d.deviceId);
    log(`resetting ${device}`);
    await device.sendCtrlCommand(exports.ControlCmd.Reset);
  }

  const allFlashers = await createFlashers(bus);
  const flashers = allFlashers.filter(f => !!ignoreFirmwareCheck || f.dev_class == blob.productIdentifier);

  if (!flashers.length) {
    log(`no devices to flash`);
    return;
  }

  if (flashers.length != updateCandidates.length) console.error(`expected ${updateCandidates.length} flashers, got ${flashers.length}`);
  flashers[0].classClients = flashers;
  log(`flashing ${blob.name}`);
  await flashers[0].flashFirmwareBlob(blob, progress);
}
/**
 * This command can be sent every 50ms to keep devices in bootloader mode
 * @param bus
 * @category Firmware
 */


async function sendStayInBootloaderCommand(bus) {
  const bl_announce = Packet.onlyHeader(exports.BootloaderCmd.Info);
  await bl_announce.sendAsMultiCommandAsync(bus, SRV_BOOTLOADER);
}

function defaultFieldPayload(specification) {
  let r = undefined;

  switch (specification.type) {
    case "bool":
      r = 0;
      break;

    case "i8":
    case "i16":
    case "i32":
    case "u8":
    case "u16":
    case "u32":
      {
        const min = pick(specification.typicalMin, specification.absoluteMin, undefined);
        const max = pick(specification.typicalMax, specification.absoluteMax, undefined);
        if (max !== undefined && min !== undefined) r = (max + min) / 2;else r = 0;
        break;
      }

    case "bytes":
      {
        r = new Uint8Array(0);
        break;
      }

    case "string":
    case "string0":
      {
        r = "";
        break;
      }
  }

  if (/^(u0|i1)\.\d+$/.test(specification.type)) r = 0;
  return r;
}

function defaultPayload(specification) {
  const {
    fields
  } = specification;
  const rs = fields.map(defaultFieldPayload);
  return rs;
}
/**
 * A register "server" instance, used to assembly service servers.
 * @category Servers
 */


class JDRegisterServer extends JDEventSource {
  constructor(service, identifier, defaultValue) {
    var _a, _b;

    super();
    this.service = service;
    this.identifier = identifier;
    this.skipBoundaryCheck = false;
    this.skipErrorInjection = false;
    const serviceSpecification = this.service.specification;
    this.specification = serviceSpecification.packets.find(pkt => isRegister(pkt) && pkt.identifier === this.identifier);
    let v = defaultValue;
    if (!v && !this.specification.optional) v = defaultPayload(this.specification);

    if (v !== undefined && !v.some(vi => vi === undefined)) {
      this.data = jdpack(this.packFormat, v);
    } // keep a copy to handle reset


    this.resetData = (_a = this.data) === null || _a === void 0 ? void 0 : _a.slice(0); // don't check boundaries if there are none

    this.skipBoundaryCheck = !((_b = this.specification) === null || _b === void 0 ? void 0 : _b.fields.some(field => isSet(field.absoluteMin) || isSet(field.absoluteMax)));
  }

  get packFormat() {
    return this.specification.packFormat;
  }

  values() {
    return jdunpack(this.data, this.packFormat);
  }

  normalize(values) {
    var _a; // enforce boundaries from spec


    if (!this.skipBoundaryCheck) {
      (_a = this.specification) === null || _a === void 0 ? void 0 : _a.fields.forEach((field, fieldi) => {
        if (field.isSimpleType) {
          let value = values[fieldi]; // clamp within bounds

          const min = field.absoluteMin;
          if (min !== undefined) value = Math.max(min, value);
          const max = field.absoluteMax;
          if (max !== undefined) value = Math.min(max, value); // update

          values[fieldi] = value;
        }
      });
    } // enforce other boundaries


    this.emit(PACKET_DATA_NORMALIZE, values);
  }

  shouldNormalize() {
    return !this.skipBoundaryCheck || this.listenerCount(PACKET_DATA_NORMALIZE);
  }

  setValues(values, skipChangeEvent) {
    if (this.readOnly) return;
    if (this.shouldNormalize()) this.normalize(values);
    const d = jdpack(this.packFormat, values);

    if (!bufferEq(this.data, d)) {
      this.data = d;
      if (!skipChangeEvent) this.emit(CHANGE);
    }
  }

  reset() {
    var _a;

    this.data = (_a = this.resetData) === null || _a === void 0 ? void 0 : _a.slice(0);
  }

  async sendGetAsync() {
    var _a;

    this.emit(REGISTER_PRE_GET);
    let d = this.data;
    if (!d) return;
    const error = !this.skipErrorInjection && ((_a = this.errorRegister) === null || _a === void 0 ? void 0 : _a.values()[0]);

    if (error && !isNaN(error)) {
      // apply error artifically
      const vs = this.values();

      for (let i = 0; i < vs.length; ++i) {
        vs[i] += Math.random() * error;
      }

      d = jdpack(this.packFormat, vs);
    }

    await this.service.sendPacketAsync(Packet.from(this.identifier | CMD_GET_REG, d));
  }

  handlePacket(pkt) {
    if (this.identifier !== pkt.registerIdentifier) return false;

    if (pkt.isRegisterGet) {
      this.sendGetAsync();
    } else if (this.identifier >> 8 !== 0x1) {
      // set, non-const
      let changed = false;
      let d = pkt.data; // unpack and check boundaries

      if (this.shouldNormalize()) {
        try {
          // unpack, apply boundaries, repack
          const values = jdunpack(d, this.packFormat);
          this.normalize(values);
          d = jdpack(this.packFormat, values);
        } catch (e) {
          // invalid format, refuse
          this.emit(PACKET_INVALID_DATA, pkt);
        }
      } // test if anything changed


      if (!bufferEq(this.data, d)) {
        this.data = d;
        changed = true;
      }

      this.lastSetTime = this.service.timestamp;
      this.emit(REPORT_RECEIVE);
      if (changed) this.emit(CHANGE);
    }

    return true;
  }

}

const CALIBRATION_DELAY = 5000;
/**
 * Base class for service server implementations
 * @category Servers
 */

class JDServiceServer extends JDEventSource {
  constructor(serviceClass, options) {
    super();
    this.serviceClass = serviceClass;
    this.serviceIndex = -1; // set by device

    this._registers = [];
    this.commands = {};
    this._locked = false;
    const {
      instanceName,
      variant,
      valueValues,
      intensityValues,
      registerValues,
      isActive
    } = options || {};
    this.specification = serviceSpecificationFromClassIdentifier(this.serviceClass);
    this.statusCode = this.addRegister(exports.SystemReg.StatusCode, [exports.SystemStatusCodes.Ready, 0]);
    if (valueValues) this.addRegister(exports.SystemReg.Value, valueValues);

    if (intensityValues) {
      const intensity = this.addRegister(exports.SystemReg.Intensity, intensityValues);
      if (isActive) intensity.on(CHANGE, () => {
        const ev = isActive(intensity.values());
        if (ev !== undefined) this.sendEvent(isActive(intensity.values()) ? exports.SystemEvent.Active : exports.SystemEvent.Inactive);
      });
    }

    if (variant) this.addRegister(exports.SystemReg.Variant, [variant]);
    this.instanceName = this.addRegister(exports.SystemReg.InstanceName, [instanceName || ""]); // any extra

    registerValues === null || registerValues === void 0 ? void 0 : registerValues.forEach(({
      code,
      values
    }) => this.addRegister(code, values)); // emit event when status code changes

    this.statusCode.on(CHANGE, () => this.sendEvent(exports.BaseEvent.StatusCodeChanged, this.statusCode.data)); // if the device has a calibrate command, regiser handler
    // and put device in calibrationneeded state

    if (this.specification.packets.find(pkt => pkt.kind === "command" && pkt.identifier === exports.SystemCmd.Calibrate)) {
      this.addCommand(exports.SystemCmd.Calibrate, this.handleCalibrate.bind(this));
      this.statusCode.setValues([exports.SystemStatusCodes.CalibrationNeeded, 0], true);
    }

    this.handleTwinPacket = this.handleTwinPacket.bind(this);
  }

  get device() {
    return this._device;
  }

  set device(value) {
    if (this._device !== value) {
      this._device = value;
      this.emit(DEVICE_CHANGE);
      this.emit(CHANGE);
    }
  }

  get twin() {
    return this._twin;
  }

  set twin(service) {
    if (service === this._twin) return;

    if (this._twin) {
      this._twin.off(PACKET_RECEIVE, this.handleTwinPacket);

      this._twin.off(PACKET_SEND, this.handleTwinPacket);

      this._twinCleanup.forEach(tw => tw()); // unsubscribe

    }

    this._twin = service;
    this._twinCleanup = service ? [] : undefined;

    if (this._twin) {
      this._twin.on(PACKET_RECEIVE, this.handleTwinPacket);

      this._twin.on(PACKET_SEND, this.handleTwinPacket);

      this._twin.registers().forEach(twinReg => {
        const reg = this.register(twinReg.code);

        if (reg) {
          reg === null || reg === void 0 ? void 0 : reg.setValues(twinReg.unpackedValue);

          this._twinCleanup.push(twinReg.subscribe(REPORT_UPDATE, () => reg.setValues(twinReg.unpackedValue)));
        }
      });
    }

    this.emit(CHANGE);
  }

  handleTwinPacket(pkt) {
    this.handlePacket(pkt);
  }

  get registers() {
    return this._registers.slice(0);
  }

  get timestamp() {
    var _a, _b, _c;

    const bus = ((_a = this.device) === null || _a === void 0 ? void 0 : _a.bus) || ((_c = (_b = this._twin) === null || _b === void 0 ? void 0 : _b.device) === null || _c === void 0 ? void 0 : _c.bus);
    return bus === null || bus === void 0 ? void 0 : bus.timestamp;
  }

  register(code) {
    return this._registers.find(reg => reg.identifier === code);
  }

  addExistingRegister(reg) {
    this._registers.push(reg);

    return reg;
  }

  addRegister(identifier, defaultValue) {
    let reg = this._registers.find(r => r.identifier === identifier);

    if (!reg && !this._locked) {
      // make sure this register is supported
      if (!this.specification.packets.find(pkt => isRegister(pkt) && pkt.identifier === identifier)) return undefined;
      reg = new JDRegisterServer(this, identifier, defaultValue);

      this._registers.push(reg);
    }

    return reg;
  }

  reset() {
    this.registers.forEach(reg => reg.reset());
  }
  /**
   * Locks the current set of registers
   */


  lock() {
    this._locked = true;
  }

  addCommand(identifier, handler) {
    if (this._locked) console.error(`adding command to locked service`);
    this.commands[identifier] = handler;
  }

  async handlePacket(pkt) {
    if (pkt.isRegisterGet || pkt.isRegisterSet) {
      // find register to handle
      const rid = pkt.registerIdentifier;

      let reg = this._registers.find(r => r.identifier === rid);

      if (!reg) {
        // try adding
        reg = this.addRegister(rid);
      }

      reg === null || reg === void 0 ? void 0 : reg.handlePacket(pkt);
    } else if (pkt.isCommand) {
      const cmd = this.commands[pkt.serviceCommand];
      if (cmd) cmd(pkt);else if (cmd === undefined) console.log(`ignored command`, {
        pkt
      });
    } // ignored?

  }

  async sendPacketAsync(pkt) {
    if (this.twin) return;
    pkt.serviceIndex = this.serviceIndex;
    await this.device.sendPacketAsync(pkt);
  }

  async sendEvent(eventCode, data) {
    if (this.twin) return;
    const {
      device
    } = this;
    const {
      bus
    } = device;
    if (!bus) return;
    const now = bus.timestamp;
    const cmd = device.createEventCmd(eventCode);
    const pkt = Packet.from(cmd, data || new Uint8Array(0));
    await this.sendPacketAsync(pkt);
    device.delayedSend(pkt, now + 20);
    device.delayedSend(pkt, now + 100);
  }

  async handleCalibrate() {
    const [status] = this.statusCode.values();
    if (status !== exports.SystemStatusCodes.Ready) return;
    this.calibrate();
  }

  async calibrate() {
    // notify that calibration started
    this.statusCode.setValues([exports.SystemStatusCodes.Calibrating, 0]); // wait 5 seconds

    await this.device.bus.delay(CALIBRATION_DELAY); // finish calibraion

    this.statusCode.setValues([exports.SystemStatusCodes.Ready, 0]);
  }

}

class SensorServer extends JDServiceServer {
  constructor(serviceClass, options) {
    super(serviceClass, options);
    this.serviceClass = serviceClass;
    this.lastStream = 0;
    this.lastErrorReadingChanged = false;
    const {
      readingValues,
      streamingInterval,
      preferredStreamingInterval,
      readingError
    } = options || {};
    this.reading = this.addRegister(exports.SystemReg.Reading, readingValues);
    this.streamingSamples = this.addRegister(exports.SensorReg.StreamingSamples);
    this.streamingInterval = this.addRegister(exports.SensorReg.StreamingInterval, [streamingInterval || preferredStreamingInterval || this.reading.specification.preferredInterval || STREAMING_DEFAULT_INTERVAL]);
    if (preferredStreamingInterval !== undefined) this.preferredStreamingInterval = this.addRegister(exports.SensorReg.StreamingPreferredInterval, [preferredStreamingInterval]);

    if (readingError !== undefined) {
      this.readingError = this.addRegister(exports.SystemReg.ReadingError, readingError);
      this.reading.errorRegister = this.readingError;
      this.readingError.on(CHANGE, () => this.lastErrorReadingChanged = true);
    }

    this.on(REFRESH, this.refreshRegisters.bind(this));
  }

  refreshRegisters() {
    var _a, _b, _c, _d, _e;

    const [samples] = this.streamingSamples.values();
    if (samples <= 0 || !this.reading.data) return; // is it time to stream?

    let interval = (_b = (_a = this.streamingInterval) === null || _a === void 0 ? void 0 : _a.values()) === null || _b === void 0 ? void 0 : _b[0];
    if (interval === undefined) interval = (_d = (_c = this.preferredStreamingInterval) === null || _c === void 0 ? void 0 : _c.values()) === null || _d === void 0 ? void 0 : _d[0];
    if (interval === undefined) interval = this.reading.specification.preferredInterval;
    if (interval === undefined) interval = STREAMING_DEFAULT_INTERVAL;
    const now = this.device.bus.timestamp;

    if (now - this.lastStream > interval) {
      // let's stream a value!
      this.lastStream = now;
      this.streamingSamples.setValues([samples - 1]);
      this.reading.sendGetAsync();
      this.emit(READING_SENT); // if the error changed, send value as well.

      if (this.lastErrorReadingChanged) {
        (_e = this.readingError) === null || _e === void 0 ? void 0 : _e.sendGetAsync();
        this.lastErrorReadingChanged = false;
      }
    }
  }

}
/**
 * @internal
 */


function dateToClock(n) {
  const year = n.getFullYear();
  const month = n.getMonth() + 1;
  const date = n.getDate();
  const day = n.getDay();
  const hour = n.getHours();
  const min = n.getMinutes();
  const sec = n.getSeconds();
  return [year, month, date, day, hour, min, sec];
}

class RealTimeClockServer extends SensorServer {
  constructor() {
    super(SRV_REAL_TIME_CLOCK, {
      readingValues: dateToClock(new Date()),
      variant: exports.RealTimeClockVariant.Computer,
      streamingInterval: 1000
    });
    this.lastSecond = 0;
    this.error = this.addRegister(exports.RealTimeClockReg.Error, [0]);
    this.precision = this.addRegister(exports.RealTimeClockReg.Precision, [0]);
    this.addCommand(exports.RealTimeClockCmd.SetTime, this.handleSetTime.bind(this));
    this.on(REFRESH, this.refreshTime.bind(this));
  }

  static async syncTime(bus) {
    const values = dateToClock(new Date());
    const pkt = Packet.jdpacked(exports.RealTimeClockCmd.SetTime, "u16 u8 u8 u8 u8 u8 u8", values);
    await pkt.sendAsMultiCommandAsync(bus, SRV_REAL_TIME_CLOCK);
  }

  handleSetTime(pkt) {
    console.log(`set time`, {
      pkt
    });
  }

  refreshTime() {
    const d = new Date();
    const s = d.getSeconds();

    if (s !== this.lastSecond) {
      const r = dateToClock(d);
      this.reading.setValues(r);
      this.lastSecond = s;
    }
  }

}
/**
 * Connection states for transports
 * @category Transport
 */


exports.ConnectionState = void 0;

(function (ConnectionState) {
  ConnectionState["Connected"] = "connected";
  ConnectionState["Connecting"] = "connecting";
  ConnectionState["Disconnecting"] = "disconnecting";
  ConnectionState["Disconnected"] = "disconnected";
})(exports.ConnectionState || (exports.ConnectionState = {}));
/**
 * A transport marshalls Jacdac packets between a physical device on the TypeScript bus.
 * @category Transport
 */


class Transport extends JDEventSource {
  constructor(type, options) {
    var _a, _b, _c, _d;

    super();
    this.type = type;
    this.disposed = false;
    this._connectionState = exports.ConnectionState.Disconnected;
    this._checkPulse = !!(options === null || options === void 0 ? void 0 : options.checkPulse);
    this._cleanups = [(_b = (_a = options === null || options === void 0 ? void 0 : options.connectObservable) === null || _a === void 0 ? void 0 : _a.subscribe({
      next: async () => {
        var _a, _b;

        if ((_a = this.bus) === null || _a === void 0 ? void 0 : _a.disconnected) {
          await delay(TRANSPORT_CONNECT_RETRY_DELAY);

          if ((_b = this.bus) === null || _b === void 0 ? void 0 : _b.disconnected) {
            if (typeof document !== "undefined" && document.visibilityState === "visible") this.connect(true);
          }
        }
      }
    })) === null || _b === void 0 ? void 0 : _b.unsubscribe, (_d = (_c = options === null || options === void 0 ? void 0 : options.disconnectObservable) === null || _c === void 0 ? void 0 : _c.subscribe({
      next: () => {
        this.disconnect();
      }
    })) === null || _d === void 0 ? void 0 : _d.unsubscribe].filter(c => !!c);
  }

  get bus() {
    return this._bus;
  }

  set bus(bus) {
    assert(!this._bus && !!bus);
    this._bus = bus;

    if (this._checkPulse) {
      this._bus.on(SELF_ANNOUNCE, this.checkPulse.bind(this));
    }
  }
  /**
   * Gets the bus connection state.
   */


  get connectionState() {
    return this._connectionState;
  }

  setConnectionState(state) {
    if (this._connectionState !== state) {
      //console.debug(`${this._connectionState} -> ${state}`)
      this._connectionState = state;
      this._connectionTime = state === exports.ConnectionState.Connected ? this.bus.timestamp : undefined;
      this._lastReceivedTime = undefined;
      this.emit(CONNECTION_STATE, this._connectionState);
      this.bus.emit(CONNECTION_STATE, this);

      switch (this._connectionState) {
        case exports.ConnectionState.Connected:
          this.emit(CONNECT);
          break;

        case exports.ConnectionState.Connecting:
          this.emit(CONNECTING);
          break;

        case exports.ConnectionState.Disconnecting:
          this.emit(DISCONNECTING);
          break;

        case exports.ConnectionState.Disconnected:
          this.emit(DISCONNECT);
          break;
      }

      this.emit(CHANGE);
      this.bus.emit(CHANGE);
    }
  }

  get connecting() {
    return this.connectionState == exports.ConnectionState.Connecting;
  }

  get disconnecting() {
    return this.connectionState == exports.ConnectionState.Disconnecting;
  }

  get connected() {
    return this._connectionState == exports.ConnectionState.Connected;
  }

  get disconnected() {
    return this._connectionState == exports.ConnectionState.Disconnected;
  }

  async checkPulse() {
    assert(this._checkPulse);
    if (!this.connected) return; // ignore while connected

    if (this.bus.safeBoot) return; // don't mess with flashing bootloaders

    const devices = this.bus.devices();
    if (devices.some(dev => dev.flashing)) // don't mess with flashing
      return; // detect if the proxy device is lost

    const t = this.bus.timestamp - (this._lastReceivedTime || this._connectionTime);

    if (t > TRANSPORT_PULSE_TIMEOUT) {
      this.emit(LOST);
      console.debug(`${this.type}: lost connection with device`);
      if (this._lastReceivedTime !== undefined) await this.reconnect();else await this.disconnect(true);
    }
  }

  async sendPacketAsync(p) {
    if (!this.connected) {
      this.emit(PACKET_SEND_DISCONNECT, p);
    } else {
      await this.transportSendPacketAsync(p);
    }
  }

  connect(background) {
    console.debug(`${this.type}: connect ${background ? `(background)` : ""}`);
    if (this.disposed) throw new Error("attempted to connect to a disposed transport"); // already connected

    if (this.connectionState == exports.ConnectionState.Connected) {
      console.debug(`${this.type}: already connected`);
      return Promise.resolve();
    } // connecting


    if (!this._connectPromise) {
      // already disconnecting, retry when disconnected
      if (this._disconnectPromise) {
        console.debug(`${this.type}: queuing connect after disconnecting`);
        const p = this._disconnectPromise;
        this._disconnectPromise = undefined;
        this._connectPromise = p.then(() => this.connect());
      } else {
        // starting a fresh connection
        console.debug(`${this.type}: connecting`);
        this._connectPromise = Promise.resolve();
        this.setConnectionState(exports.ConnectionState.Connecting);
        this._connectPromise = this._connectPromise.then(() => this.transportConnectAsync(background));

        const p = this._connectPromise = this._connectPromise.then(() => {
          if (p == this._connectPromise) {
            this._connectPromise = undefined;
            this.setConnectionState(exports.ConnectionState.Connected);
          } else {
            console.debug(`${this.type}: connection aborted in flight`, {
              state: this._connectionState,
              old: this._connectPromise,
              new: p
            }); // already reported
          }
        }).catch(e => {
          if (p == this._connectPromise) {
            this._connectPromise = undefined;
            this.setConnectionState(exports.ConnectionState.Disconnected);
            if (!background) this.errorHandler(CONNECT, e);else console.debug(`${this.type}: background connect failed`);
          } else {
            console.debug(`${this.type}: connection error aborted in flight`);
          }
        });
      }
    } else {
      console.debug(`${this.type}: connect with existing promise`);
    }

    return this._connectPromise;
  }

  disconnect(background) {
    // already disconnected
    if (this.connectionState == exports.ConnectionState.Disconnected) return Promise.resolve();

    if (!this._disconnectPromise) {
      // connection in progress, wait and disconnect when done
      if (this._connectPromise) {
        console.debug(`${this.type}: cancelling connection and disconnect`);
        this._connectPromise = undefined;
      }

      console.debug(`${this.type}: disconnecting`);
      this._disconnectPromise = Promise.resolve();
      this.setConnectionState(exports.ConnectionState.Disconnecting);
      this._disconnectPromise = this._disconnectPromise.then(() => this.transportDisconnectAsync(background));
      this._disconnectPromise = this._disconnectPromise.catch(e => {
        this._disconnectPromise = undefined;
        this.errorHandler(DISCONNECT, e);
      }).finally(() => {
        this._disconnectPromise = undefined;
        this.setConnectionState(exports.ConnectionState.Disconnected);
      });
    } else {
      console.debug(`${this.type}: disconnect with existing promise`);
    }

    return this._disconnectPromise;
  }

  async reconnect() {
    console.debug(`${this.type}: reconnect`);
    await this.disconnect(true);
    await this.connect(true);
  }

  handlePacket(payload) {
    const {
      timestamp
    } = this.bus;
    this._lastReceivedTime = timestamp;
    const pkt = Packet.fromBinary(payload, timestamp);
    pkt.sender = this.type;
    this.bus.processPacket(pkt);
  }

  handleFrame(payload) {
    const {
      timestamp
    } = this.bus;
    this._lastReceivedTime = timestamp;
    const pkts = Packet.fromFrame(payload, timestamp);

    for (const pkt of pkts) {
      pkt.sender = this.type;
      this.bus.processPacket(pkt);
    }
  } // eslint-disable-next-line @typescript-eslint/no-explicit-any


  errorHandler(context, exception) {
    this.emit(ERROR, {
      context,
      exception
    });
    this.bus.emit(ERROR, {
      transport: this,
      context,
      exception
    });
    this.emit(CHANGE); // when a microbit flash is initiated via file download, the device will
    // stop responding. we should not try to reconnect while this is the case

    this.disconnect(true);
  }

  dispose() {
    this.disposed = true;

    this._cleanups.forEach(c => c());

    this._cleanups = [];
  }

}

class BusStatsMonitor extends JDEventSource {
  /**
   * @internal
   */
  constructor(bus) {
    super();
    this.bus = bus;
    this._prev = Array(4).fill(0).map(() => ({
      packets: 0,
      announce: 0,
      acks: 0,
      bytes: 0
    }));
    this._previ = 0;
    this._temp = {
      packets: 0,
      announce: 0,
      acks: 0,
      bytes: 0
    };
    bus.on(PACKET_SEND, this.handlePacketSend.bind(this));
    bus.on(PACKET_PROCESS, this.handlePacketProcess.bind(this));
    bus.on(SELF_ANNOUNCE, this.handleSelfAnnounce.bind(this));
  }
  /**
   * Computes the current packet statistics of the bus
   */


  get current() {
    var _a;

    const r = {
      packets: 0,
      announce: 0,
      acks: 0,
      bytes: 0
    };
    const n = this._prev.length;

    for (let i = 0; i < this._prev.length; ++i) {
      const p = this._prev[i];
      r.packets += p.packets;
      r.announce += p.announce;
      r.acks += p.acks;
      r.bytes += p.bytes;
    } // announce every 500ms


    const n2 = n / 2;
    r.packets /= n2;
    r.announce /= n2;
    r.acks /= n2;
    r.bytes /= n2;
    return Object.assign({
      devices: this.bus.devices({
        ignoreInfrastructure: true
      }).length,
      simulators: this.bus.serviceProviders().length,
      transport: (_a = this.bus.transports.find(transport => transport.connected)) === null || _a === void 0 ? void 0 : _a.type
    }, r);
  }

  accumulate(pkt) {
    var _a, _b;

    this._temp.packets++;
    this._temp.bytes += (((_a = pkt.header) === null || _a === void 0 ? void 0 : _a.length) || 0) + (((_b = pkt.data) === null || _b === void 0 ? void 0 : _b.length) || 0);
    if (pkt.isAnnounce) this._temp.announce++;
    if (pkt.isCRCAck) this._temp.acks++;
  }

  handleSelfAnnounce() {
    const changed = JSON.stringify(this._prev) !== JSON.stringify(this._temp);
    this._prev[this._previ] = this._temp;
    this._previ = (this._previ + 1) % this._prev.length;
    this._temp = {
      packets: 0,
      announce: 0,
      acks: 0,
      bytes: 0
    };
    if (changed) this.emit(CHANGE);
  }

  handlePacketSend(pkt) {
    this.accumulate(pkt);
  }

  handlePacketProcess(pkt) {
    this.accumulate(pkt);
  }

}
/**
 * A control service server
 * @category Servers
 */


class ControlServer extends JDServiceServer {
  constructor(options) {
    super(SRV_CONTROL);
    this.statusLightColor = undefined;
    const {
      resetIn
    } = options || {};
    this.startTime = Date.now();
    this.deviceDescription = this.addRegister(exports.ControlReg.DeviceDescription);
    this.mcuTemperature = this.addRegister(exports.ControlReg.McuTemperature, [25]);
    this.uptime = this.addRegister(exports.ControlReg.Uptime);
    if (resetIn) this.resetIn = this.addRegister(exports.ControlReg.ResetIn, [0]);
    this.addCommand(exports.ControlCmd.Services, this.announce.bind(this));
    this.addCommand(exports.ControlCmd.Identify, this.identify.bind(this));
    this.addCommand(exports.ControlCmd.Reset, this.handleReset.bind(this));
    this.addCommand(exports.ControlCmd.Noop, null);
    this.addCommand(exports.ControlCmd.SetStatusLight, this.handleSetStatusLight.bind(this));
  }

  async announce() {
    // restartCounter, flags, packetCount, serviceClass
    const pkt = Packet.jdpacked(exports.ControlCmd.Services, "u16 u8 x[1] u32[]", [this.device.restartCounter | exports.ControlAnnounceFlags.StatusLightRgbNoFade | exports.ControlAnnounceFlags.SupportsACK, this.device.packetCount + 1, this.device.services().slice(1).map(srv => srv.serviceClass)]);
    await this.sendPacketAsync(pkt); // micros

    this.uptime.setValues([(Date.now() - this.startTime) * 100], true); // check if we need to reset

    if (this.resetIn) {
      const [resetIn] = this.resetIn.values();

      if (resetIn) {
        const resetTimestamp = resetIn / 1000 + this.resetIn.lastSetTime;

        if (resetTimestamp < this.device.bus.timestamp) {
          // reset in expired
          console.debug(`${this} reset in expired`, {
            resetIn,
            lastSet: this.resetIn.lastSetTime,
            resetTimestamp
          });
          this.device.reset();
        }
      }
    }
  }

  async identify() {
    this.emit(IDENTIFY);
  }

  handleReset() {
    this.startTime = Date.now();
    this.device.reset();
  }

  handleSetStatusLight(pkt) {
    const [toRed, toGreen, toBlue] = jdunpack(pkt.data, "u8 u8 u8 u8");
    this.statusLightColor = toRed << 16 | toGreen << 8 | toBlue;
    this.emit(CHANGE);
  }

}
/**
 * Implements a device with service servers.
 * @category Servers
 */


class JDServiceProvider extends JDEventSource {
  constructor(template, deviceId) {
    super();
    this.template = template;
    this.deviceId = deviceId;
    if (!this.deviceId) this.deviceId = randomDeviceId();
    this.shortId = shortDeviceId(this.deviceId);
    this.handleSelfAnnounce = this.handleSelfAnnounce.bind(this);
    this.handlePacket = this.handlePacket.bind(this);
  }

  get bus() {
    return this._bus;
  }

  set bus(value) {
    if (value !== this._bus) {
      this.stop();
      this._bus = value;
      if (this._bus) this.start();
    }
  }

  start() {
    if (this._bus) {
      this._bus.on(SELF_ANNOUNCE, this.handleSelfAnnounce);

      this._bus.on([PACKET_PROCESS, PACKET_SEND], this.handlePacket);
    }
  }

  stop() {
    if (this._bus) {
      this._bus.off(SELF_ANNOUNCE, this.handleSelfAnnounce);

      this._bus.off([PACKET_PROCESS, PACKET_SEND], this.handlePacket);

      this._bus = undefined;
    }
  }

  handleSelfAnnounce() {}

}
/**
 * Implements a device with service servers.
 * @category Servers
 */


class JDServerServiceProvider extends JDServiceProvider {
  constructor(template, services, options) {
    super(template, options === null || options === void 0 ? void 0 : options.deviceId);
    this._restartCounter = 0;
    this._packetCount = 0;
    this._eventCounter = undefined;
    this.controlService = new ControlServer(options);
    this._services = [];
    this.updateServices(services);
    this.on(REFRESH, this.refreshRegisters.bind(this));
  }

  updateServices(services) {
    var _a; // clear previous services


    (_a = this._services) === null || _a === void 0 ? void 0 : _a.slice(1).forEach(srv => srv.device = undefined); // store new services

    this._services = [this.controlService, ...services];

    if (this._services.length >= MAX_SERVICES_LENGTH) {
      this.emit(ERROR, `too many services (${this._services.length}) > ${MAX_SERVICES_LENGTH}`);
      console.warn(`jacdac: dropping services to ${MAX_SERVICES_LENGTH}`);
      this._services = this._services.slice(0, MAX_SERVICES_LENGTH);
    }

    this._services.forEach((srv, i) => {
      srv.device = this;
      srv.serviceIndex = i;
    });

    this.emit(CHANGE);
  }

  removeService(service) {
    if ((service === null || service === void 0 ? void 0 : service.device) !== this) return; // not in this device;

    const newServices = this._services.slice(1);

    const index = newServices.indexOf(service);

    if (index > -1) {
      newServices.splice(index, 1);
      this.updateServices(newServices);
    }
  }

  start() {
    super.start();
    this._packetCount = 0;
  }

  stop() {
    this._delayedPackets = undefined;
    super.stop();
  }

  handleSelfAnnounce() {
    super.handleSelfAnnounce();
    if (this._restartCounter < 0xf) this._restartCounter++; // async

    this.controlService.announce(); // also send status codes, for non-zero codes

    const activeServices = this.services().filter(srv => !isBufferEmpty(srv.statusCode.data));
    activeServices.forEach(srv => srv.statusCode.sendGetAsync()); // reset counter

    this._packetCount = 0;
  }

  get restartCounter() {
    return this._restartCounter;
  }

  get packetCount() {
    return this._packetCount;
  }

  services() {
    return this._services.slice(0);
  }

  service(serviceIndex) {
    return serviceIndex !== undefined && this._services[serviceIndex];
  }

  toString() {
    return `host ${this.shortId}`;
  }

  get eventCounter() {
    return this._eventCounter;
  }

  createEventCmd(evCode) {
    if (!this._eventCounter) this._eventCounter = 0;
    this._eventCounter = this._eventCounter + 1 & CMD_EVENT_COUNTER_MASK;
    if (evCode >> 8) throw new Error("invalid event code");
    return CMD_EVENT_MASK | this._eventCounter << CMD_EVENT_COUNTER_POS | evCode;
  }

  async sendPacketAsync(pkt) {
    if (!this.bus) return Promise.resolve(); // qos counter

    this._packetCount++;
    pkt.deviceIdentifier = this.deviceId; // compute crc and send

    const p = pkt.sendCoreAsync(this.bus); // send to current bus

    this.bus.processPacket(pkt); // return priomise

    return p;
  }

  delayedSend(pkt, timestamp) {
    if (!this._delayedPackets) {
      this._delayedPackets = []; // start processing loop

      setTimeout(this.processDelayedPackets.bind(this), 10);
    }

    const dp = {
      timestamp,
      pkt
    };

    this._delayedPackets.push(dp);

    this._delayedPackets.sort((l, r) => -l.timestamp + r.timestamp);
  }

  processDelayedPackets() {
    var _a, _b; // consume packets that are ready


    while ((_a = this._delayedPackets) === null || _a === void 0 ? void 0 : _a.length) {
      const {
        timestamp,
        pkt
      } = this._delayedPackets[0];
      if (timestamp > this.bus.timestamp) break;

      this._delayedPackets.shift(); // do we wait?


      try {
        this.sendPacketAsync(pkt);
      } catch (e) {
        // something went wrong, clear queue
        this._delayedPackets = undefined;
        throw e;
      }
    } // keep waiting or stop


    if (!((_b = this._delayedPackets) === null || _b === void 0 ? void 0 : _b.length)) this._delayedPackets = undefined; // we're done
    else setTimeout(this.processDelayedPackets.bind(this), 10);
  }

  handlePacket(pkt) {
    const devIdMatch = pkt.deviceIdentifier == this.deviceId;

    if (pkt.requiresAck && devIdMatch) {
      pkt.requiresAck = false; // make sure we only do it once

      const crc = pkt.crc;
      const ack = Packet.onlyHeader(crc);
      ack.serviceIndex = JD_SERVICE_INDEX_CRC_ACK;
      this.sendPacketAsync(ack);
    }

    if (pkt.isMultiCommand) {
      if (!pkt.isCommand) return; // only commands supported

      const multiCommandClass = pkt.serviceClass;

      for (const h of this._services) {
        if (h.serviceClass == multiCommandClass) {
          // pretend it's directly addressed to us
          const npkt = pkt.cloneForDevice(this.deviceId, h.serviceIndex);
          h.handlePacket(npkt);
        }
      }
    } else if (devIdMatch) {
      if (!pkt.isCommand) return; // huh? someone's pretending to be us?

      const h = this._services[pkt.serviceIndex];

      if (h) {
        // log(`handle pkt at ${h.name} cmd=${pkt.service_command}`)
        h.handlePacket(pkt);
      }
    } else {
      if (pkt.isCommand) return; // it's a command, and it's not for us
      // reception of ACKs is handled by JDDevice class
    }
  }

  refreshRegisters() {
    this._services.forEach(srv => srv.emit(REFRESH));
  }

  reset() {
    var _a;

    this._restartCounter = 0;
    this._packetCount = 0;
    (_a = this._services) === null || _a === void 0 ? void 0 : _a.forEach(srv => srv.reset());
    this.emit(RESET);
  }

}

class ProtocolTestServer extends JDServiceServer {
  constructor() {
    super(SRV_PROTO_TEST);
    this.init(exports.ProtoTestReg.RwBool, exports.ProtoTestReg.RoBool, exports.ProtoTestCmd.CBool, exports.ProtoTestEvent.EBool, false);
    this.init(exports.ProtoTestReg.RwI32, exports.ProtoTestReg.RoI32, exports.ProtoTestCmd.CI32, exports.ProtoTestEvent.EI32, 0);
    this.init(exports.ProtoTestReg.RwU32, exports.ProtoTestReg.RoU32, exports.ProtoTestCmd.CU32, exports.ProtoTestEvent.EU32, 0);
    this.init(exports.ProtoTestReg.RwString, exports.ProtoTestReg.RoString, exports.ProtoTestCmd.CString, exports.ProtoTestEvent.EString, "");
    this.rwBytes = this.init(exports.ProtoTestReg.RwBytes, exports.ProtoTestReg.RoBytes, exports.ProtoTestCmd.CBytes, exports.ProtoTestEvent.EBytes, new Uint8Array(0));
    this.init(exports.ProtoTestReg.RwI8U8U16I32, exports.ProtoTestReg.RoI8U8U16I32, exports.ProtoTestCmd.CI8U8U16I32, exports.ProtoTestEvent.EI8U8U16I32, 0, 0, 0, 0);
    this.init(exports.ProtoTestReg.RwU8String, exports.ProtoTestReg.RoU8String, exports.ProtoTestCmd.CU8String, exports.ProtoTestEvent.EU8String, 0, "");
    this.addCommand(exports.ProtoTestCmd.CReportPipe, this.handleReportPipe.bind(this));
  }

  init(rwi, roi, ci, ei, ...values) {
    const rw = this.addRegister(rwi, values);
    const ro = this.addRegister(roi, rw.values());
    rw.on(CHANGE, () => {
      ro.setValues(rw.values());
      this.sendEvent(ei, rw.data);
    });
    this.addCommand(ci, pkt => rw.setValues(jdunpack(pkt.data, rw.specification.packFormat)));
    return rw;
  }

  async handleReportPipe(pkt) {
    const pipe = OutPipe.from(this.device.bus, pkt, true);
    await pipe.respondForEach(this.rwBytes.data, b => {
      const buf = new Uint8Array(1);
      buf[0] = b;
      return jdpack("b", [buf]);
    });
  }

}
/**
 * Server implementation for the button service
 * @category Servers
 */


class ButtonServer extends SensorServer {
  constructor(instanceName, analog) {
    super(SRV_BUTTON, {
      instanceName,
      readingValues: [ButtonServer.INACTIVE_VALUE],
      streamingInterval: 50
    });
    this.analog = this.addRegister(exports.ButtonReg.Analog, [!!analog]);
    this.on(REFRESH, this.handleRefresh.bind(this));
  }

  get threshold() {
    return this._threshold;
  }

  set threshold(value) {
    if (value !== this._threshold) {
      this._threshold = value;
      this.analog.setValues([!!this._threshold]);
      this.emit(CHANGE);
    }
  }

  isActive() {
    var _a, _b; // TODO: debouncing


    const [v] = this.reading.values();
    const t = ((_b = (_a = this.threshold) === null || _a === void 0 ? void 0 : _a.values()) === null || _b === void 0 ? void 0 : _b[0]) || 0.5;
    return v > t;
  }

  async handleRefresh() {
    const now = this.device.bus.timestamp;

    if (this.isActive()) {
      // down event
      if (this._downTime === undefined) {
        this._downTime = now;
        this._nextHold = this._downTime + ButtonServer.HOLD_TIME;
        await this.sendEvent(exports.ButtonEvent.Down); // hold
      } else if (now > this._nextHold) {
        const time = now - this._downTime;
        this._nextHold = this.device.bus.timestamp + ButtonServer.HOLD_TIME;
        await this.sendEvent(exports.ButtonEvent.Hold, jdpack("u32", [time]));
      }
    } else {
      // up event
      if (this._downTime !== undefined) {
        const time = now - this._downTime;
        this._downTime = undefined;
        this._nextHold = undefined;
        await this.sendEvent(exports.ButtonEvent.Up, jdpack("u32", [time]));
      }
    }
  }

  async down() {
    this.reading.setValues([ButtonServer.ACTIVE_VALUE]);
  }

  async up() {
    this.reading.setValues([ButtonServer.INACTIVE_VALUE]);
  }

}

ButtonServer.HOLD_TIME = 500;
ButtonServer.INACTIVE_VALUE = 0;
ButtonServer.ACTIVE_VALUE = 1;
/**
 * Encodes a buzzer tone information into a data payload
 * @param frequency sound frequency in Hz
 * @param ms sound duration in milliseconds
 * @param volume volume from [0..1]
 * @returns data payload
 * @category Data Packing
 */

function tonePayload(frequency, ms, volume) {
  const period = Math.round(1000000 / frequency);
  const duty = period * volume >> 11;
  return jdpack("u16 u16 u16", [period, duty, ms]);
}
/**
 * Server implementation for the buzzer service
 * @category Servers
 */


class BuzzerServer extends JDServiceServer {
  constructor(options) {
    super(SRV_BUZZER, options);
    this.volume = this.addRegister(exports.BuzzerReg.Volume, [0.2]);
    this.addCommand(exports.BuzzerCmd.PlayTone, this.handlePlayTone.bind(this));
  }

  handlePlayTone(pkt) {
    const [period,, duration] = jdunpack(pkt.data, "u16 u16 u16");
    const frequency = 1000000 / period;
    const [volume] = this.volume.values();
    this.emit(BuzzerServer.PLAY_TONE, {
      frequency,
      duration,
      volume
    });
  }

}

BuzzerServer.PLAY_TONE = "playTone";

class CharacterScreenServer extends JDServiceServer {
  constructor(options) {
    super(SRV_CHARACTER_SCREEN);
    const {
      message = "",
      rows = 2,
      columns = 16,
      variant,
      textDirection,
      brightness = 100
    } = options || {};
    this.message = this.addRegister(exports.CharacterScreenReg.Message, [message]);
    this.brightness = this.addRegister(exports.CharacterScreenReg.Brightness, [brightness]);
    this.rows = this.addRegister(exports.CharacterScreenReg.Rows, [rows]);
    this.columns = this.addRegister(exports.CharacterScreenReg.Columns, [columns]);
    this.variant = this.addRegister(exports.CharacterScreenReg.Variant, [variant || exports.CharacterScreenVariant.LCD]);
    this.message = this.addRegister(exports.CharacterScreenReg.Message, [""]);
    this.textDirection = this.addRegister(exports.CharacterScreenReg.TextDirection, [textDirection || exports.CharacterScreenTextDirection.LeftToRight]);
    this.addCommand(exports.CharacterScreenCmd.SetLine, this.handleSetLine.bind(this));
    this.addCommand(exports.CharacterScreenCmd.Clear, this.handleClear.bind(this));
  }

  handleClear() {
    this.message.setValues([""]);
  }

  handleSetLine(pkt) {
    const [line, lineMessage] = pkt.jdunpack("u16 s");
    const [rows] = this.rows.values();
    if (line >= rows) return;
    const [columns] = this.columns.values();
    const [message = ""] = this.message.values();
    const lines = message.split("\n");
    lines[line] = lineMessage.slice(0, columns); // clip as needed

    const newMessage = lines.map(l => l || "").join("\n");
    this.message.setValues([newMessage]);
  }

}
/**
 * @internal
 */


const JOYSTICK_DPAD_BUTTONS = exports.JoystickButtons.Left | exports.JoystickButtons.Right | exports.JoystickButtons.Up | exports.JoystickButtons.Down;
/**
 * @internal
 */

const JOYSTICK_ARCADE_BUTTONS = JOYSTICK_DPAD_BUTTONS | exports.JoystickButtons.A | exports.JoystickButtons.B | exports.JoystickButtons.Menu | exports.JoystickButtons.Select | exports.JoystickButtons.Exit;
/**
 * @internal
 */

const JOYSTICK_DPAD_A_BUTTONS = JOYSTICK_DPAD_BUTTONS | exports.JoystickButtons.A;
/**
 * @internal
 */

const JOYSTICK_DPAD_AB_BUTTONS = JOYSTICK_DPAD_A_BUTTONS | exports.JoystickButtons.B;
/**
 * @internal
 */

const JOYSTICK_GAMEPAD_EXTRA_BUTTONS = exports.JoystickButtons.B | exports.JoystickButtons.Select | exports.JoystickButtons.Menu | exports.JoystickButtons.Reset; // https://w3c.github.io/gamepad/#remapping

const standardGamepadMapping = [[exports.JoystickButtons.Left, 14], [exports.JoystickButtons.Right, 15], [exports.JoystickButtons.Up, 12], [exports.JoystickButtons.Down, 13], [exports.JoystickButtons.A, 0], [exports.JoystickButtons.B, 1], [exports.JoystickButtons.Select, 8], [exports.JoystickButtons.Menu, 9]];

class JoystickServer extends SensorServer {
  constructor(options) {
    super(SRV_JOYSTICK, {
      instanceName: options === null || options === void 0 ? void 0 : options.instanceName,
      readingValues: [0, 0, 0],
      streamingInterval: 50
    });
    const {
      variant = exports.JoystickVariant.Thumb,
      buttonsAvailable = 0
    } = options || {};
    this.variant = this.addRegister(exports.JoystickReg.Variant, [variant]);
    this.buttonsAvailable = this.addRegister(exports.JoystickReg.ButtonsAvailable, [buttonsAvailable]);
  }

  get isDigital() {
    const [value] = this.buttonsAvailable.values();
    return (value & JOYSTICK_DPAD_BUTTONS) === JOYSTICK_DPAD_BUTTONS;
  }

  async down(buttons) {
    const [currentButtons, x, y] = this.reading.values();
    const newButtons = currentButtons | buttons;
    await this.updateReading(newButtons, x, y);
  }

  async up(buttons) {
    const [currentButtons, x, y] = this.reading.values();
    const newButtons = currentButtons & ~buttons;
    await this.updateReading(newButtons, x, y);
  }

  async updateDirection(x, y) {
    const [button] = this.reading.values();
    await this.updateReading(button, x, y);
  }
  /**
   * Read the state of a browser gamepad and apply it to the sensor
   * @param gamepad
   */


  async update(gamepad) {
    const {
      buttons,
      axes
    } = gamepad;
    const [buttonsAvailable] = this.buttonsAvailable.values();
    let newButtons = 0;

    for (const [b, id] of standardGamepadMapping) {
      if ((b & buttonsAvailable) == b && !!buttons[id].pressed) {
        newButtons |= b;
      }
    }

    let newX = 0,
        newY = 0;

    if (!this.isDigital) {
      const [axeLeftRight, axeUpDown] = axes;
      newX = axeLeftRight;
      newY = axeUpDown;
    }

    await this.updateReading(newButtons, newX, newY);
  }

  async updateReading(buttons, x, y) {
    const [oldButtons] = this.reading.values();

    if (this.isDigital) {
      x = buttons & exports.JoystickButtons.Left ? -1 : buttons & exports.JoystickButtons.Right ? 1 : 0;
      y = buttons & exports.JoystickButtons.Up ? -1 : buttons & exports.JoystickButtons.Down ? 1 : 0;
    } else {
      const threshold = -1;
      if (x < -threshold) buttons |= exports.JoystickButtons.Left;else if (x > threshold) buttons |= exports.JoystickButtons.Right;else buttons &= ~(exports.JoystickButtons.Left | exports.JoystickButtons.Right);
      if (y < -threshold) buttons |= exports.JoystickButtons.Up;else if (y > threshold) buttons |= exports.JoystickButtons.Down;else buttons &= ~(exports.JoystickButtons.Up | exports.JoystickButtons.Down);
    }

    this.reading.setValues([buttons, x, y]);

    if (buttons !== oldButtons) {
      await this.sendEvent(exports.JoystickEvent.ButtonsChanged, jdpack("u32", [buttons]));
    }
  }

}

class DotMatrixServer extends JDServiceServer {
  constructor(columns, rows, options) {
    super(SRV_DOT_MATRIX);
    const {
      brightness,
      variant
    } = options || {};
    this.dots = this.addRegister(exports.DotMatrixReg.Dots, [new Uint8Array(0)]);
    this.rows = this.addRegister(exports.DotMatrixReg.Rows, [rows]);
    this.columns = this.addRegister(exports.DotMatrixReg.Columns, [columns]);
    if (brightness !== undefined) this.brightness = this.addRegister(exports.DotMatrixReg.Brightness, [128]);
    if (variant !== undefined) this.variant = this.addRegister(exports.DotMatrixReg.Variant, [variant]);
    this.rows.skipBoundaryCheck = true;
    this.rows.skipErrorInjection = true;
    if (variant === exports.DotMatrixVariant.LED) this.addRegister(exports.SensorReg.StreamingPreferredInterval, [50]);
    this.rows.on(CHANGE, this.updateDotsBuffer.bind(this));
    this.columns.on(CHANGE, this.updateDotsBuffer.bind(this));
    this.updateDotsBuffer();
  }

  updateDotsBuffer() {
    var _a; // columns must be byte aligned


    const [rows] = this.rows.values();
    const [columns] = this.columns.values(); // there's probably a much smarter way to do this

    const columnspadded = columns + (8 - columns % 8); // total bits needed

    const n = rows * columnspadded;

    if (((_a = this.dots.data) === null || _a === void 0 ? void 0 : _a.length) !== n) {
      this.dots.data = new Uint8Array(n);
      this.dots.emit(CHANGE);
    }
  }

}
/*
 * `0xD0: set_all(C+)` - set all pixels in current range to given color pattern
 * `0xD1: fade(C+)` - set `N` pixels to color between colors in sequence
 * `0xD2: fade_hsv(C+)` - similar to `fade()`, but colors are specified and faded in HSV
 * `0xD3: rotate_fwd(K)` - rotate (shift) pixels by `K` positions away from the connector
 * `0xD4: rotate_back(K)` - same, but towards the connector
 * `0xD5: show(M=50)` - send buffer to strip and wait `M` milliseconds
 * `0xD6: range(P=0, N=length)` - range from pixel `P`, `N` pixels long
 * `0xD7: mode(K=0)` - set update mode
 * `0xD8: mode1(K=0)` - set update mode for next command only
 */


const LIGHT_PROG_SET_ALL = 0xd0;
const LIGHT_PROG_FADE = 0xd1;
const LIGHT_PROG_FADE_HSV = 0xd2;
const LIGHT_PROG_ROTATE_FWD = 0xd3;
const LIGHT_PROG_ROTATE_BACK = 0xd4;
const LIGHT_PROG_SHOW = 0xd5;
const LIGHT_PROG_RANGE = 0xd6;
const LIGHT_PROG_MODE = 0xd7;
const LIGHT_PROG_MODE1 = 0xd8;
const LIGHT_MODE_REPLACE = 0x00;
const LIGHT_MODE_ADD_RGB = 0x01;
const LIGHT_MODE_SUBTRACT_RGB = 0x02;
const LIGHT_MODE_MULTIPLY_RGB = 0x03;
const LIGHT_MODE_LAST = 0x03;
const LIGHT_PROG_COLN = 0xc0;
const LIGHT_PROG_COL1 = 0xc1;
const LIGHT_PROG_COL2 = 0xc2;
const LIGHT_PROG_COL3 = 0xc3;
const LIGHT_PROG_COL1_SET = 0xcf;
const PROG_EOF = 0;
const PROG_CMD = 1;
const PROG_NUMBER = 3;
const PROG_COLOR_BLOCK = 4;

function rgb(r, g, b) {
  return {
    r,
    g,
    b
  };
}

function hsv(hue, sat, val) {
  // scale down to 0..192
  hue = hue * 192 >> 8; // reference: based on FastLED's hsv2rgb rainbow algorithm
  // [https://github.com/FastLED/FastLED](MIT)

  const invsat = 255 - sat;
  const brightness_floor = val * invsat >> 8;
  const color_amplitude = val - brightness_floor;
  const section = hue / 0x40 >> 0; // [0..2]

  const offset = hue % 0x40 >> 0; // [0..63]

  const rampup = offset;
  const rampdown = 0x40 - 1 - offset;
  const rampup_amp_adj = rampup * color_amplitude / (256 / 4) >> 0;
  const rampdown_amp_adj = rampdown * color_amplitude / (256 / 4) >> 0;
  const rampup_adj_with_floor = rampup_amp_adj + brightness_floor;
  const rampdown_adj_with_floor = rampdown_amp_adj + brightness_floor;
  let r = 0,
      g = 0,
      b = 0;

  if (section) {
    if (section == 1) {
      // section 1: 0x40..0x7F
      r = brightness_floor;
      g = rampdown_adj_with_floor;
      b = rampup_adj_with_floor;
    } else {
      // section 2; 0x80..0xBF
      r = rampup_adj_with_floor;
      g = brightness_floor;
      b = rampdown_adj_with_floor;
    }
  } else {
    // section 0: 0x00..0x3F
    r = rampdown_adj_with_floor;
    g = rampup_adj_with_floor;
    b = brightness_floor;
  }

  return rgb(r, g, b);
}

function mulcol(c, m) {
  let c2 = c * m >> 7;
  if (m < 128 && c == c2) c2--;else if (m > 128 && c == c2) c2++;
  return c2;
}

function clamp(c) {
  if (c < 0) return 0;
  if (c > 255) return 255;
  return c;
}

function SCALE0(c, i) {
  return (c & 0xff) * (1 + (i & 0xff)) >> 8;
}

class LedPixelServer extends JDServiceServer {
  constructor(options) {
    super(SRV_LED_PIXEL, options);
    this.pxbuffer = new Uint8Array(0);
    this.prog_mode = 0;
    this.prog_tmpmode = 0;
    this.range_start = 0;
    this.range_end = 0;
    this.range_len = 0;
    this.range_ptr = 0;
    this.prog_ptr = 0;
    this.prog_size = 0;
    this.prog_data = new Uint8Array(0);
    this.dirty = true;
    this.inited = false;
    this.power_enable = false;
    const {
      numColumns,
      maxPower = 200,
      maxPixels = 300,
      numPixels = 15
    } = options || {};
    this.brightness = this.addRegister(exports.LedPixelReg.Brightness, [15]);
    this.actualBrightness = this.addRegister(exports.LedPixelReg.ActualBrightness, [15]);
    this.lightType = this.addRegister(exports.LedPixelReg.LightType, [exports.LedPixelLightType.WS2812B_GRB]);
    this.numPixels = this.addRegister(exports.LedPixelReg.NumPixels, [numPixels]);
    this.maxPower = this.addRegister(exports.LedPixelReg.MaxPower, [maxPower]);
    this.maxPixels = this.addRegister(exports.LedPixelReg.MaxPixels, [maxPixels]);
    this.variant = this.addRegister(exports.LedPixelReg.Variant, [exports.LedPixelVariant.Strip]);
    this.numRepeats = this.addRegister(exports.LedPixelReg.NumRepeats, [0]);
    if (numColumns !== undefined) this.numColumns = this.addRegister(exports.LedPixelReg.NumColumns, [numColumns]);
    this.brightness.on(CHANGE, () => this.intensity = this.requested_intensity);
    this.numPixels.on(CHANGE, this.allocRxBuffer.bind(this));
    this.maxPixels.on(CHANGE, this.allocRxBuffer.bind(this));
    this.addCommand(exports.LedPixelCmd.Run, this.handleRun.bind(this));
    this.allocRxBuffer();
  }
  /**
   * Gets an array of RGB color numbers
   */


  get colors() {
    return this.pxbuffer;
  }

  get maxpower() {
    const [r] = this.maxPower.values() || [200];
    return r;
  }

  get maxpixels() {
    const [r] = this.maxPixels.values() || [];
    return r;
  }

  get numpixels() {
    const [r] = this.numPixels.values() || [0];
    return r;
  }

  get requested_intensity() {
    const [r] = this.brightness.values() || [0];
    return r;
  }

  get intensity() {
    const [r] = this.actualBrightness.values() || [0];
    return r;
  }

  set intensity(v) {
    this.actualBrightness.setValues([v]);
  }

  jd_power_enable(value) {
    this.power_enable = value;
  }

  is_enabled() {
    return this.numpixels > 0 && this.requested_intensity > 0;
  }

  allocRxBuffer() {
    const {
      numpixels = 0,
      maxpixels,
      pxbuffer
    } = this;
    if (maxpixels !== undefined && numpixels > maxpixels) this.numPixels.setValues([this.maxpixels]);
    const n = numpixels * 3; // don't need to prealloc here

    if (pxbuffer || n !== pxbuffer.length) this.pxbuffer = new Uint8Array(n);
  }

  reset_range() {
    this.range_ptr = this.range_start;
  }

  set_next(c) {
    if (this.range_ptr >= this.range_end) return false;
    const p = this.pxbuffer;
    const pi = this.range_ptr++ * 3; // fast path

    if (this.prog_tmpmode == LIGHT_MODE_REPLACE) {
      p[pi + 0] = c.r;
      p[pi + 1] = c.g;
      p[pi + 2] = c.b;
      return true;
    }

    let r = p[pi + 0],
        g = p[pi + 1],
        b = p[pi + 2];

    switch (this.prog_tmpmode) {
      case LIGHT_MODE_ADD_RGB:
        r += c.r;
        g += c.g;
        b += c.b;
        break;

      case LIGHT_MODE_SUBTRACT_RGB:
        r -= c.r;
        g -= c.g;
        b -= c.b;
        break;

      case LIGHT_MODE_MULTIPLY_RGB:
        r = mulcol(r, c.r);
        g = mulcol(g, c.g);
        b = mulcol(b, c.b);
        break;
    }

    p[pi + 0] = clamp(r);
    p[pi + 1] = clamp(g);
    p[pi + 2] = clamp(b);
    return true;
  }

  limit_intensity() {
    const {
      numpixels,
      requested_intensity,
      maxpower,
      pxbuffer
    } = this;
    let n = numpixels * 3;
    const prev_intensity = this.intensity;
    let intensity = this.intensity;
    intensity += 1 + (intensity >> 5);
    if (requested_intensity !== undefined && intensity > requested_intensity) intensity = requested_intensity;
    let current_full = 0;
    let current = 0;
    let current_prev = 0;
    let di = 0;

    while (n--) {
      const v = pxbuffer[di++];
      current += SCALE0(v, intensity);
      current_prev += SCALE0(v, prev_intensity);
      current_full += v;
    } // 46uA per step of LED


    current *= 46;
    current_prev *= 46;
    current_full *= 46; // 14mA is the chip at 48MHz, 930uA per LED is static

    const base_current = 14000 + 930 * numpixels;
    const current_limit = maxpower * 1000 - base_current;

    if (current <= current_limit) {
      this.intensity = intensity; // LOG("curr: %dmA; not limiting %d", (base_current + current) / 1000, state->intensity);

      return;
    }

    if (current_prev <= current_limit) {
      return; // no change needed
    }

    let inten = current_limit / (current_full >> 8) - 1;
    if (inten < 0) inten = 0;
    this.intensity = inten;
  }

  prog_fetch_color() {
    const ptr = this.prog_ptr;
    if (ptr + 3 > this.prog_size) return rgb(0, 0, 0);
    const d = this.prog_data;
    this.prog_ptr = ptr + 3;
    return rgb(d[ptr + 0], d[ptr + 1], d[ptr + 2]);
  }

  prog_fetch() {
    if (this.prog_ptr >= this.prog_size) return {
      prog: PROG_EOF
    };
    const d = this.prog_data;
    const c = d[this.prog_ptr++];

    if (!(c & 0x80)) {
      return {
        dst: c,
        prog: PROG_NUMBER
      };
    } else if ((c & 0xc0) == 0x80) {
      return {
        dst: (c & 0x3f) << 8 | d[this.prog_ptr++],
        prog: PROG_NUMBER
      };
    } else switch (c) {
      case LIGHT_PROG_COL1:
        return {
          dst: 1,
          prog: PROG_COLOR_BLOCK
        };

      case LIGHT_PROG_COL2:
        return {
          dst: 2,
          prog: PROG_COLOR_BLOCK
        };

      case LIGHT_PROG_COL3:
        return {
          dst: 3,
          prog: PROG_COLOR_BLOCK
        };

      case LIGHT_PROG_COLN:
        return {
          dst: d[this.prog_ptr++],
          prog: PROG_COLOR_BLOCK
        };

      default:
        return {
          dst: c,
          prog: PROG_CMD
        };
    }
  }

  prog_fetch_num(defl) {
    const prev = this.prog_ptr;
    const fr = this.prog_fetch();
    const {
      dst: res,
      prog: r
    } = fr;
    if (r == PROG_NUMBER) return res;else {
      this.prog_ptr = prev; // rollback

      return defl;
    }
  }

  prog_fetch_cmd() {
    let cmd; // skip until there's a command

    for (;;) {
      const c = this.prog_fetch();

      switch (c.prog) {
        case PROG_CMD:
          return c.dst;

        case PROG_COLOR_BLOCK:
          while (cmd--) this.prog_fetch_color();

          break;

        case PROG_EOF:
          return 0;
      }
    }
  }

  prog_set(len) {
    this.reset_range();
    const start = this.prog_ptr;

    for (;;) {
      this.prog_ptr = start;
      let ok = false;

      for (let i = 0; i < len; ++i) {
        // don't break the loop immediately if !ok - make sure the prog counter advances
        ok = this.set_next(this.prog_fetch_color());
      }

      if (!ok) break;
    }
  }

  prog_fade(len, usehsv) {
    if (len < 2) {
      this.prog_set(len);
      return;
    }

    let colidx = 0;
    const endp = this.prog_ptr + 3 * len;
    let col0 = this.prog_fetch_color();
    let col1 = this.prog_fetch_color();
    const colstep = (len - 1 << 16) / this.range_len;
    let colpos = 0;
    this.reset_range();

    for (;;) {
      while (colidx < colpos >> 16) {
        colidx++;
        col0 = col1;
        col1 = this.prog_fetch_color();
      }

      const fade1 = colpos & 0xffff;
      const fade0 = 0xffff - fade1;
      const col = rgb(col0.r * fade0 + col1.r * fade1 + 0x8000 >> 16, col0.g * fade0 + col1.g * fade1 + 0x8000 >> 16, col0.b * fade0 + col1.b * fade1 + 0x8000 >> 16);
      if (!this.set_next(usehsv ? hsv(col.r, col.g, col.b) : col)) break;
      colpos += colstep;
    }

    this.prog_ptr = endp;
  }

  prog_rot(shift) {
    if (shift <= 0 || shift >= this.range_len) return;
    const range_start = this.range_start;
    const range_end = this.range_end;
    const buf = this.pxbuffer;
    let first = range_start * 3;
    let middle = (range_start + shift) * 3;
    const last = range_end * 3;
    let next = middle;

    while (first != next) {
      const tmp = buf[first];
      const tmp1 = buf[first + 1];
      const tmp2 = buf[first + 2];
      buf[first] = buf[next];
      buf[first + 1] = buf[next + 1];
      buf[first + 2] = buf[next + 2];
      buf[next] = tmp;
      buf[next + 1] = tmp1;
      buf[next + 2] = tmp2;
      first += 3;
      next += 3;
      if (next === last) next = middle;else if (first === middle) middle = next;
    }
  }

  fetch_mode() {
    const m = this.prog_fetch_num(0);
    if (m > LIGHT_MODE_LAST) return 0;
    return m;
  }

  prog_process() {
    const data = this.prog_data;
    if (this.prog_ptr >= this.prog_size) return false; // check that the program wasn't restarted
    // concurrently

    while (data === this.prog_data) {
      const cmd = this.prog_fetch_cmd();
      if (!cmd) break;

      if (cmd == LIGHT_PROG_SHOW) {
        const k = this.prog_fetch_num(50);
        this.dirty = true;
        setTimeout(this.animationFrame.bind(this), k); // check data is still current;

        return data === this.prog_data;
      }

      switch (cmd) {
        case LIGHT_PROG_COL1_SET:
          this.range_ptr = this.range_start + this.prog_fetch_num(0);
          this.set_next(this.prog_fetch_color());
          break;

        case LIGHT_PROG_FADE:
        case LIGHT_PROG_FADE_HSV:
        case LIGHT_PROG_SET_ALL:
          {
            const {
              dst: len,
              prog: pcmd
            } = this.prog_fetch();
            if (pcmd != PROG_COLOR_BLOCK || len == 0) continue; // bailout

            if (cmd == LIGHT_PROG_SET_ALL) this.prog_set(len);else this.prog_fade(len, cmd == LIGHT_PROG_FADE_HSV);
            break;
          }

        case LIGHT_PROG_ROTATE_BACK:
        case LIGHT_PROG_ROTATE_FWD:
          {
            let k = this.prog_fetch_num(1);
            const len = this.range_len;
            if (len == 0) continue;

            while (k >= len) k -= len;

            if (cmd == LIGHT_PROG_ROTATE_FWD && k != 0) k = len - k;
            this.prog_rot(k);
            break;
          }

        case LIGHT_PROG_MODE1:
          this.prog_tmpmode = this.fetch_mode();
          break;

        case LIGHT_PROG_MODE:
          this.prog_mode = this.fetch_mode();
          break;

        case LIGHT_PROG_RANGE:
          {
            let start = this.prog_fetch_num(0);
            const len = this.prog_fetch_num(this.numpixels);
            const numpixels = this.numpixels;
            if (start > numpixels) start = numpixels;
            let end = start + len;
            if (end > numpixels) end = numpixels;
            this.range_start = start;
            this.range_end = end;
            this.range_len = end - start;
            break;
          }
      }

      if (cmd != LIGHT_PROG_MODE1) this.prog_tmpmode = this.prog_mode;
    }

    return false;
  }
  /**
   * Perform an animation step
   */


  animationFrame() {
    if (!this.prog_process()) return; // concurrently udpated

    if (!this.is_enabled()) return;

    if (this.dirty) {
      this.dirty = false;

      if (isBufferEmpty(this.pxbuffer)) {
        this.jd_power_enable(false);
        return;
      } else {
        this.jd_power_enable(true);
      }

      this.limit_intensity(); // we're ready to render...

      this.emit(RENDER);
    }
  }

  sync_config() {
    if (!this.is_enabled()) {
      this.jd_power_enable(false);
      return;
    }

    if (!this.inited) {
      this.inited = true; // initialize?
      // px_init(this.lighttype);
    }

    this.jd_power_enable(true);
  }

  handleRun(pkt) {
    this.prog_data = pkt.data;
    this.prog_size = this.prog_data.length;
    this.prog_ptr = 0;
    this.range_start = 0;
    this.range_end = this.range_len = this.numpixels;
    this.prog_tmpmode = this.prog_mode = 0;
    this.sync_config();
    this.animationFrame();
  }

}

class MatrixKeypadServer extends SensorServer {
  constructor(columns, rows, labels) {
    super(SRV_MATRIX_KEYPAD, {
      readingValues: [[]]
    });
    this.columns = this.addRegister(exports.MatrixKeypadReg.Columns, [columns]);
    this.rows = this.addRegister(exports.MatrixKeypadReg.Rows, [rows]);
    this.labels = this.addRegister(exports.MatrixKeypadReg.Labels, labels ? [labels.map(l => [l])] : undefined);
  }

  async down(button) {
    const [values] = this.reading.values();
    const valuei = values.findIndex(v => v[0] === button);

    if (valuei < 0) {
      values.push([button]);
      this.reading.setValues([values]);
    }
  }

  async up(button) {
    const [values] = this.reading.values();
    const valuei = values.findIndex(v => v[0] === button);

    if (valuei > -1) {
      values.splice(valuei, 1);
      this.reading.setValues([values]);
    }
  }

}

class MotorServer extends JDServiceServer {
  constructor(instanceName) {
    super(SRV_MOTOR, {
      instanceName
    });
    this.duty = this.addRegister(exports.MotorReg.Duty, [0]);
    this.enabled = this.addRegister(exports.MotorReg.Enabled, [false]);
    this.loadTorque = this.addRegister(exports.MotorReg.LoadTorque);
    this.loadSpeed = this.addRegister(exports.MotorReg.LoadSpeed);
  }

}

class LevelDetector extends JDClient {
  constructor(service) {
    super();
    this.service = service;
    this.reset();
    if (this.service.inactiveThreshold) this.mount(this.service.inactiveThreshold.subscribe(CHANGE, this.reset.bind(this)));
    if (this.service.activeThreshold) this.mount(this.service.activeThreshold.subscribe(CHANGE, this.reset.bind(this)));
    this.mount(this.service.reading.subscribe(CHANGE, this.update.bind(this)));
  }

  reset() {
    this._state = exports.SystemReadingThreshold.Neutral;
  }

  update() {
    var _a, _b;

    const [level] = this.service.reading.values();

    if (level === undefined) {
      this.setState(exports.SystemReadingThreshold.Neutral);
      return;
    }

    const [active] = (_a = this.service.activeThreshold) === null || _a === void 0 ? void 0 : _a.values();

    if (active !== undefined && level >= active) {
      this.setState(exports.SystemReadingThreshold.Active);
      return;
    }

    const [inactive] = (_b = this.service.inactiveThreshold) === null || _b === void 0 ? void 0 : _b.values();

    if (inactive !== undefined && level <= inactive) {
      this.setState(exports.SystemReadingThreshold.Inactive);
      return;
    } // neutral


    this.setState(exports.SystemReadingThreshold.Neutral);
  }

  setState(state) {
    if (state === this._state) return;
    this._state = state;

    switch (state) {
      case exports.SystemReadingThreshold.Active:
        this.service.sendEvent(exports.SystemEvent.Active);
        break;

      case exports.SystemReadingThreshold.Inactive:
        this.service.sendEvent(exports.SystemEvent.Inactive);
        break;

      case exports.SystemReadingThreshold.Neutral:
        this.service.sendEvent(exports.SystemEvent.Neutral);
        break;
    }
  }

}
/**
 * Base class for analog sensor servers
 * @category Servers
 */


class AnalogSensorServer extends SensorServer {
  constructor(serviceClass, options) {
    super(serviceClass, options);
    const {
      minReading,
      maxReading,
      inactiveThreshold,
      activeThreshold,
      readingResolution
    } = options || {};
    if (minReading !== undefined) this.addRegister(exports.SystemReg.MinReading, [minReading]);
    if (maxReading !== undefined) this.addRegister(exports.SystemReg.MaxReading, [maxReading]);
    if (readingResolution !== undefined) this.addRegister(exports.SystemReg.ReadingResolution, [readingResolution]);

    if (inactiveThreshold !== undefined || this.activeThreshold !== undefined) {
      if (inactiveThreshold !== undefined) this.inactiveThreshold = this.addRegister(exports.SystemReg.InactiveThreshold, [inactiveThreshold]);
      if (activeThreshold !== undefined) this.activeThreshold = this.addRegister(exports.SystemReg.ActiveThreshold, [activeThreshold]);
      this.levelDetector = new LevelDetector(this);
    }
  }

}

class RainGaugeServer extends AnalogSensorServer {
  constructor(options) {
    super(SRV_RAIN_GAUGE, {
      readingValues: [0]
    });
    this._tiltCount = 0;
    this._level = 0;
    const {
      bucketSize
    } = options || {};
    this.precipitationPrecision = this.addRegister(exports.RainGaugeReg.PrecipitationPrecision, [bucketSize || 0.2794]);
    this._level = 0;
  }

  get tiltCount() {
    return this._tiltCount;
  }

  get level() {
    return this._level;
  }

  async rain(fraction) {
    if (!fraction) return;
    this._level += fraction;
    if (this._level >= 0.7) await this.tilt();else this.emit(CHANGE);
  }

  async tilt() {
    this._tiltCount++;
    this._level = 0;
    const [bucket] = this.precipitationPrecision.values();
    const [current] = this.reading.values();
    this.reading.setValues([current + (bucket || 0.2)]);
    this.emit(CHANGE);
  }

}

class ReflectedLightServer extends AnalogSensorServer {
  constructor(options) {
    super(SRV_REFLECTED_LIGHT, {
      readingValues: [0]
    });
    const {
      variant
    } = options || {};
    this.variant = this.addRegister(exports.ReflectedLightReg.Variant, [variant || exports.ReflectedLightVariant.InfraredDigital]);
  }

}

class RotaryEncoderServer extends SensorServer {
  constructor() {
    super(SRV_ROTARY_ENCODER, {
      readingValues: [0],
      streamingInterval: 50
    });
    this.clicksPerTurn = this.addRegister(exports.RotaryEncoderReg.ClicksPerTurn, [12]);
  }

  async rotate(clicks) {
    const [position] = this.reading.values();
    this.reading.setValues([position + (clicks >> 0)]);
  }

}

class ServoServer extends JDServiceServer {
  constructor(options) {
    super(SRV_SERVO, options);
    const {
      minAngle = -90,
      maxAngle = 90,
      responseSpeed,
      stallTorque
    } = options || {};
    this.angle = this.addRegister(exports.ServoReg.Angle, [0]);
    this.currentAngle = this.addRegister(exports.ServoReg.CurrentAngle, [0]);
    this.enabled = this.addRegister(exports.ServoReg.Enabled, [false]);
    this.minAngle = this.addRegister(exports.ServoReg.MinAngle, minAngle !== undefined ? [minAngle] : undefined);
    this.maxAngle = this.addRegister(exports.ServoReg.MaxAngle, maxAngle !== undefined ? [maxAngle] : undefined);
    this.offset = this.addRegister(exports.ServoReg.Offset, [0]);
    this.responseSpeed = this.addRegister(exports.ServoReg.ResponseSpeed, responseSpeed !== undefined ? [responseSpeed] : undefined);
    this.stallTorque = this.addRegister(exports.ServoReg.StallTorque, stallTorque !== undefined ? [stallTorque] : undefined);
    this.angle.on(PACKET_DATA_NORMALIZE, values => {
      let angle = values[0];
      const [minAngle] = this.minAngle.values();
      const [maxAngle] = this.maxAngle.values();
      if (minAngle !== undefined) angle = Math.max(minAngle, angle);
      if (maxAngle !== undefined) angle = Math.min(maxAngle, angle);
      values[0] = angle;
    });
    this.angle.on(CHANGE, () => this.currentAngle.setValues(this.angle.values()));
  }

}

class SettingsServer extends JDServiceServer {
  constructor(storageKey) {
    super(SRV_SETTINGS);
    this.storageKey = storageKey;
    this.addCommand(exports.SettingsCmd.Get, this.handleGet.bind(this));
    this.addCommand(exports.SettingsCmd.Set, this.handleSet.bind(this));
    this.addCommand(exports.SettingsCmd.Delete, this.handleDelete.bind(this));
    this.addCommand(exports.SettingsCmd.ListKeys, this.handleListKeys.bind(this));
    this.addCommand(exports.SettingsCmd.List, this.handleList.bind(this));
    this.addCommand(exports.SettingsCmd.Clear, this.handleClear.bind(this));
    this.settings = this.read();
  }

  getPayload(key) {
    const value = this.settings[key];
    const secret = /^$/.test(key);
    let payload;

    if (value === undefined) {
      payload = new Uint8Array(0);
    } else if (secret) {
      const payload = new Uint8Array(1);
      payload[0] = 0;
    } else {
      payload = fromHex(value);
    }

    return payload;
  }

  async handleGet(pkt) {
    const [key] = pkt.jdunpack("s");
    const payload = this.getPayload(key);
    const resp = Packet.jdpacked(exports.SettingsCmd.Get, "z b", [key, payload]);
    await this.sendPacketAsync(resp);
  }

  async handleSet(pkt) {
    const [key, value] = pkt.jdunpack("z b");
    console.log({
      cmd: "set",
      key,
      value
    });
    this.settings[key] = toHex(value);
    await this.save();
  }

  async handleDelete(pkt) {
    const [key] = pkt.jdunpack("s");
    delete this.settings[key];
    await this.save();
  }

  async handleListKeys(pkt) {
    const pipe = OutPipe.from(this.device.bus, pkt, true);
    await pipe.respondForEach(Object.keys(this.settings), k => jdpack("s", [k]));
  }

  async handleList(pkt) {
    const pipe = OutPipe.from(this.device.bus, pkt, true);
    await pipe.respondForEach(Object.keys(this.settings), k => {
      const payload = this.getPayload(k);
      return jdpack("z b", [k, payload]);
    });
  }

  handleClear() {
    this.settings = {};
    this.save();
  }

  read() {
    if (!this.storageKey) return {};

    try {
      const payload = typeof window !== "undefined" && window.localStorage.getItem(this.storageKey);
      return JSON.parse(payload || "{}");
    } catch (e) {
      console.log(e);
      return {};
    }
  }

  async save() {
    if (this.storageKey) {
      try {
        if (typeof window !== "undefined") window.localStorage.setItem(this.storageKey, JSON.stringify(this.settings));
      } catch (e) {
        console.log(e);
      }
    }

    await this.sendEvent(exports.SettingsEvent.Change);
  }

}

class SpeechSynthesisServer extends JDServiceServer {
  constructor() {
    var _a;

    super(SRV_SPEECH_SYNTHESIS);
    this.synthesis = typeof window !== "undefined" && window.speechSynthesis;
    this.enabled = this.addRegister(exports.SpeechSynthesisReg.Enabled, [!((_a = this.synthesis) === null || _a === void 0 ? void 0 : _a.paused)]);
    this.pitch = this.addRegister(exports.SpeechSynthesisReg.Pitch, [1]);
    this.rate = this.addRegister(exports.SpeechSynthesisReg.Rate, [1]);
    this.lang = this.addRegister(exports.SpeechSynthesisReg.Lang, [""]);
    this.volume = this.addRegister(exports.SpeechSynthesisReg.Volume, [0.5]);
    this.addCommand(exports.SpeechSynthesisCmd.Speak, this.handleSpeak.bind(this));
    this.addCommand(exports.SpeechSynthesisCmd.Cancel, this.handleCancel.bind(this));
  }

  handleSpeak(pkt) {
    const [text] = pkt.jdunpack("s");
    if (!this.synthesis || !text) return;
    const [pitch] = this.pitch.values();
    const [rate] = this.pitch.values();
    const [lang] = this.lang.values();
    const [volume] = this.volume.values();
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.pitch = pitch;
    utterance.rate = rate;
    utterance.lang = lang;
    utterance.volume = volume;
    this.synthesis.speak(utterance);
  }

  handleCancel(pkt) {
    var _a;

    (_a = this.synthesis) === null || _a === void 0 ? void 0 : _a.cancel();
  }

}

class SwitchServer extends SensorServer {
  constructor(options) {
    super(SRV_SWITCH, {
      readingValues: [false],
      streamingInterval: 50
    });
    const {
      autoOffDelay,
      variant
    } = options || {};
    this.variant = this.addRegister(exports.SwitchReg.Variant, variant !== undefined ? [variant] : undefined);
    this.autoOffDelay = this.addRegister(exports.SwitchReg.AutoOffDelay, autoOffDelay !== undefined ? [autoOffDelay] : undefined);
  }

  async toggle() {
    const [v] = this.reading.values();
    if (!v) await this.switchOn();else await this.switchOff();
  }

  async switchOn() {
    const [v] = this.reading.values();

    if (!v) {
      this.reading.setValues([true]);
      await this.sendEvent(exports.SwitchEvent.On);
      this.startAutoOff();
    }
  }

  async switchOff() {
    const [v] = this.reading.values();

    if (v) {
      this.reading.setValues([false]);
      await this.sendEvent(exports.SwitchEvent.Off);
      this.stopAutoOff();
    }
  }

  startAutoOff() {
    this.stopAutoOff();

    if (this.autoOffDelay.data !== undefined) {
      const [delay] = this.autoOffDelay.values();
      this.autoOffInterval = setTimeout(this.switchOn.bind(this), delay);
    }
  }

  stopAutoOff() {
    if (this.autoOffInterval) {
      clearTimeout(this.autoOffInterval);
      this.autoOffInterval = undefined;
    }
  }

}

class TrafficLightServer extends JDServiceServer {
  constructor(options) {
    super(SRV_TRAFFIC_LIGHT, options);
    this.red = this.addRegister(exports.TrafficLightReg.Red, [true]);
    this.orange = this.addRegister(exports.TrafficLightReg.Orange, [false]);
    this.green = this.addRegister(exports.TrafficLightReg.Green, [false]);
  }

}

class LEDServer extends JDServiceServer {
  constructor(options) {
    super(SRV_LED, options);
    const {
      ledCount = 1,
      variant = exports.LedVariant.ThroughHole,
      luminousIntensity,
      waveLength,
      color = [255, 0, 0],
      maxPower = 200
    } = options || {};
    this.color = this.addRegister(exports.LedReg.Color, color);
    this.color.on(REGISTER_PRE_GET, this.updateColor.bind(this));
    this.maxPower = this.addRegister(exports.LedReg.MaxPower, [maxPower]);
    this.ledCount = this.addRegister(exports.LedReg.LedCount, [ledCount]);
    if (luminousIntensity !== undefined) this.luminousIntensity = this.addRegister(exports.LedReg.LuminousIntensity, [luminousIntensity]);
    if (waveLength !== undefined) this.waveLength = this.addRegister(exports.LedReg.WaveLength, [waveLength]);
    this.variant = this.addRegister(exports.LedReg.Variant, [variant]);
    this.addCommand(exports.LedCmd.Animate, this.handleAnimate.bind(this)); // animation

    this.on(REFRESH, this.updateColor.bind(this));
  }

  updateColor() {
    if (!this._animation) return; // nothing to do
    // compute new color

    const {
      red,
      green,
      blue,
      toRed,
      toGreen,
      toBlue,
      speed,
      start
    } = this._animation;
    const now = this.device.bus.timestamp;
    const elapsed = now - start; // see control.md

    const total = 512 / speed * 100 | 0;
    const progress = elapsed / total; // may overshoot

    const alpha = Math.min(1, progress);
    const oneAlpha = 1 - alpha;
    const newRed = red * oneAlpha + alpha * toRed | 0;
    const newGreen = green * oneAlpha + alpha * toGreen | 0;
    const newBlue = blue * oneAlpha + alpha * toBlue | 0;
    this.color.setValues([newRed, newGreen, newBlue]); // clear animation when done

    if (progress > 1) this._animation = undefined;
  }

  handleAnimate(pkt) {
    const [toRed, toGreen, toBlue, speed] = pkt.jdunpack("u8 u8 u8 u8");

    if (speed == 0) {
      this.color.setValues([toRed, toGreen, toBlue]);
      this._animation = undefined;
    } else {
      const [red, green, blue] = this.color.values();
      this._animation = {
        red,
        green,
        blue,
        toRed,
        toGreen,
        toBlue,
        speed,
        start: this.device.bus.timestamp
      };
    }
  }

}

class SoundPlayerServer extends JDServiceServer {
  constructor(sounds) {
    super(SRV_SOUND_PLAYER);
    this.sounds = sounds;
    this.volume = this.addRegister(exports.SoundPlayerReg.Volume, [0.5]);
    this.addCommand(exports.SoundPlayerCmd.ListSounds, this.handleListSounds.bind(this));
    this.addCommand(exports.SoundPlayerCmd.Play, this.handlePlay.bind(this));
  }

  async handleListSounds(pkt) {
    const pipe = OutPipe.from(this.device.bus, pkt, true);
    await pipe.respondForEach(this.sounds, sound => jdpack("u32 s", sound));
  }

  handlePlay(pkt) {
    var _a;

    const [name] = pkt.jdunpack("s");
    (_a = this.onPlay) === null || _a === void 0 ? void 0 : _a.call(this, name);
  }

}

class RandomNumberGeneratorServer extends JDServiceServer {
  constructor() {
    super(SRV_RNG, {
      variant: exports.RngVariant.WebCrypto
    });
    this.reading = this.addRegister(exports.RngReg.Random, [new Uint8Array(64)]);
    this.reading.on(REGISTER_PRE_GET, this.handleRefresh.bind(this));
  }

  handleRefresh() {
    // generate new data
    const data = new Uint8Array(64);
    if (typeof window !== "undefined") window.crypto.getRandomValues(data);
    this.reading.setValues([data], true);
  }

}

class CompassServer extends AnalogSensorServer {
  constructor() {
    super(SRV_COMPASS, {
      readingValues: [0],
      minReading: 0,
      maxReading: 360,
      readingError: [1]
    });
    this.enabled = this.addRegister(exports.CompassReg.Enabled, [false]);
    this.enabled.on(CHANGE, () => {
      const [status] = this.statusCode.values();

      if (status === exports.SystemStatusCodes.CalibrationNeeded) {
        console.log("start calibration");
        this.calibrate();
      }
    });
  }

}

class DMXServer extends JDServiceServer {
  constructor() {
    super(SRV_DMX, {
      intensityValues: [0]
    });
    this.addCommand(exports.DmxCmd.Send, this.handleSend.bind(this));
  }

  handleSend(pkt) {
    // ignore
    console.log(`dmx send`, toHex(pkt.data));
  }

}
/**
 * @internal
 */


function inIFrame() {
  try {
    return typeof window !== "undefined" && window.self !== window.top;
  } catch (e) {
    return typeof window !== "undefined";
  }
} // keep in sync with CODAL


const RADIO_MAX_PACKET_SIZE = 32; //const MAX_FIELD_DOUBLE_NAME_LENGTH = 8;

const MAX_PAYLOAD_LENGTH = 20;
const PACKET_PREFIX_LENGTH = 9;
const VALUE_PACKET_NAME_LEN_OFFSET = 13;
const DOUBLE_VALUE_PACKET_NAME_LEN_OFFSET = 17; // Packet Spec:
// | 0              | 1 ... 4       | 5 ... 8           | 9 ... 28
// ----------------------------------------------------------------
// | packet type    | system time   | serial number     | payload
//
// Serial number defaults to 0 unless enabled by user
// payload: number (9 ... 12)

const PACKET_TYPE_NUMBER = 0; // payload: number (9 ... 12), name length (13), name (14 ... 26)

const PACKET_TYPE_VALUE = 1; // payload: string length (9), string (10 ... 28)

const PACKET_TYPE_STRING = 2; // payload: buffer length (9), buffer (10 ... 28)

const PACKET_TYPE_BUFFER = 3; // payload: number (9 ... 16)

const PACKET_TYPE_DOUBLE = 4; // payload: number (9 ... 16), name length (17), name (18 ... 26)

const PACKET_TYPE_DOUBLE_VALUE = 5;

function getStringOffset(packetType) {
  switch (packetType) {
    case PACKET_TYPE_STRING:
      return PACKET_PREFIX_LENGTH;

    case PACKET_TYPE_VALUE:
      return VALUE_PACKET_NAME_LEN_OFFSET;

    case PACKET_TYPE_DOUBLE_VALUE:
      return DOUBLE_VALUE_PACKET_NAME_LEN_OFFSET;

    default:
      return undefined;
  }
}
/*
function getMaxStringLength(packetType: number) {
    switch (packetType) {
        case PACKET_TYPE_STRING:
            return MAX_PAYLOAD_LENGTH - 2;
        case PACKET_TYPE_VALUE:
        case PACKET_TYPE_DOUBLE_VALUE:
            return MAX_FIELD_DOUBLE_NAME_LENGTH;
        default:
            return undefined;
    }
}
*/


function truncateString(str) {
  // TODO
  return str;
}

class RadioPacket {
  constructor(data) {
    this.data = data;
    if (!data) this.data = new Uint8Array(RADIO_MAX_PACKET_SIZE + 4);
  }

  static getPacket(data) {
    if (!data) return undefined; // last 4 bytes is RSSi

    return new RadioPacket(data);
  }

  static mkPacket(packetType) {
    const res = new RadioPacket();
    res.data[0] = packetType;
    return res;
  }

  get signal() {
    return getNumber(this.data, exports.NumberFormat.Int32LE, this.data.length - 4);
  }

  get packetType() {
    return this.data[0];
  }

  get time() {
    return getNumber(this.data, exports.NumberFormat.Int32LE, 1);
  }

  set time(val) {
    setNumber(this.data, exports.NumberFormat.Int32LE, 1, val);
  }

  get serial() {
    return getNumber(this.data, exports.NumberFormat.Int32LE, 5);
  }

  set serial(val) {
    setNumber(this.data, exports.NumberFormat.Int32LE, 5, val);
  }

  get stringPayload() {
    const offset = getStringOffset(this.packetType);
    return offset ? this.data.slice(offset + 1, this.data[offset]).toString() : undefined;
  }

  set stringPayload(val) {
    const offset = getStringOffset(this.packetType);

    if (offset) {
      const buf = stringToBuffer(truncateString(val));
      this.data[offset] = buf.length;
      memcpy(this.data, offset + 1, buf);
    }
  }

  get numberPayload() {
    switch (this.packetType) {
      case PACKET_TYPE_NUMBER:
      case PACKET_TYPE_VALUE:
        return getNumber(this.data, exports.NumberFormat.Int32LE, PACKET_PREFIX_LENGTH);

      case PACKET_TYPE_DOUBLE:
      case PACKET_TYPE_DOUBLE_VALUE:
        return getNumber(this.data, exports.NumberFormat.Float64LE, PACKET_PREFIX_LENGTH);
    }

    return undefined;
  }

  set numberPayload(val) {
    switch (this.packetType) {
      case PACKET_TYPE_NUMBER:
      case PACKET_TYPE_VALUE:
        setNumber(this.data, exports.NumberFormat.Int32LE, PACKET_PREFIX_LENGTH, val);
        break;

      case PACKET_TYPE_DOUBLE:
      case PACKET_TYPE_DOUBLE_VALUE:
        setNumber(this.data, exports.NumberFormat.Float64LE, PACKET_PREFIX_LENGTH, val);
        break;
    }
  }

  get bufferPayload() {
    const len = this.data[PACKET_PREFIX_LENGTH];
    return this.data.slice(PACKET_PREFIX_LENGTH + 1, PACKET_PREFIX_LENGTH + 1 + len);
  }

  set bufferPayload(b) {
    const len = Math.min(b.length, MAX_PAYLOAD_LENGTH - 1);
    this.data[PACKET_PREFIX_LENGTH] = len;
    memcpy(this.data, PACKET_PREFIX_LENGTH + 1, b, 0, len);
  }

  hasString() {
    return this.packetType === PACKET_TYPE_STRING || this.packetType === PACKET_TYPE_VALUE || this.packetType === PACKET_TYPE_DOUBLE_VALUE;
  }

  hasNumber() {
    return this.packetType === PACKET_TYPE_NUMBER || this.packetType === PACKET_TYPE_DOUBLE || this.packetType === PACKET_TYPE_VALUE || this.packetType === PACKET_TYPE_DOUBLE_VALUE;
  }

}
/**
 * A server implementation of the bit:radio service
 * @category Servers
 */


class BitRadioServer extends JDServiceServer {
  constructor() {
    super(SRV_BIT_RADIO);
    this.enabled = this.addRegister(exports.BitRadioReg.Enabled, [false]);
    this.group = this.addRegister(exports.BitRadioReg.Group, [1]);
    this.transmissionPower = this.addRegister(exports.BitRadioReg.TransmissionPower, [6]);
    this.frequencyBand = this.addRegister(exports.BitRadioReg.FrequencyBand, [7]);
    this.addCommand(exports.BitRadioCmd.SendString, this.handleSendString.bind(this));
    this.addCommand(exports.BitRadioCmd.SendNumber, this.handleSendNumber.bind(this));
    this.addCommand(exports.BitRadioCmd.SendValue, this.handleSendValue.bind(this));
    this.addCommand(exports.BitRadioCmd.SendBuffer, this.handleSendBuffer.bind(this));
  }

  handleSendString(pkt) {
    const [message] = pkt.jdunpack("s");
    const rpkt = RadioPacket.mkPacket(PACKET_TYPE_STRING);
    rpkt.stringPayload = message;
    this.sendRadioPacket(rpkt);
  }

  handleSendNumber(pkt) {
    const [value] = pkt.jdunpack("f64");
    const rpkt = RadioPacket.mkPacket(PACKET_TYPE_DOUBLE);
    rpkt.numberPayload = value;
    this.sendRadioPacket(rpkt);
  }

  handleSendValue(pkt) {
    const [value, name] = pkt.jdunpack("f64 s");
    const rpkt = RadioPacket.mkPacket(PACKET_TYPE_DOUBLE_VALUE);
    rpkt.stringPayload = name;
    rpkt.numberPayload = value;
    this.sendRadioPacket(rpkt);
  }

  handleSendBuffer(pkt) {
    const {
      data
    } = pkt;
    const rpkt = RadioPacket.mkPacket(PACKET_TYPE_BUFFER);
    rpkt.bufferPayload = data;
    this.sendRadioPacket(rpkt);
  }

  sendRadioPacket(rpkt) {
    const [on] = this.enabled.values();
    if (!on) return; // radio is off

    const {
      bus
    } = this.device;
    const {
      timestamp
    } = bus;
    const [group] = this.group.values();
    rpkt.time = timestamp;
    rpkt.serial = 0; // todo

    const msg = {
      type: "radiopacket",
      broadcast: true,
      // TODO
      rssi: -75,
      // TODO
      serial: 0,
      time: bus.timestamp,
      payload: {
        groupId: group,
        type: 0,
        bufferData: rpkt.data
      }
    }; // send message to parent

    console.log(`bitradio: send`, msg);

    if (inIFrame()) {
      window.parent.postMessage(msg, "*");
    }
  }

}

class PowerServer extends JDServiceServer {
  constructor(options) {
    super(SRV_POWER, options);
    this.enabled = this.addRegister(exports.PowerReg.Allowed, [false]);
    this.maxPower = this.addRegister(exports.PowerReg.MaxPower, [500]);
    this.overload = this.addRegister(exports.PowerReg.PowerStatus, [false]);
  }

}

class CapacitiveButtonServer extends JDServiceServer {
  constructor(options) {
    super(SRV_CAPACITIVE_BUTTON, options);
    const {
      threshold = 0.5
    } = options || {};
    this.threshold = this.addRegister(exports.CapacitiveButtonReg.Threshold, [threshold]);
  }

}

class HIDKeyboardServer extends JDServiceServer {
  constructor(options) {
    super(SRV_HID_KEYBOARD, options);
    this.addCommand(exports.HidKeyboardCmd.Clear, this.handleClear.bind(this));
    this.addCommand(exports.HidKeyboardCmd.Key, this.handleKey.bind(this));
  }

  get lastKey() {
    return this._lastKey;
  }

  handleKey(pkt) {
    const [rest] = pkt.jdunpack("r: u16 u8 u8");
    this._lastKey = rest;
    this.emit(CHANGE);
  }

  handleClear() {
    if (this._lastKey) {
      this._lastKey = undefined;
      this.emit(CHANGE);
    }
  }

}
/**
 * @internal
 */


const selectors = {
  a: 0x04,
  b: 0x05,
  c: 0x06,
  d: 0x07,
  e: 0x08,
  f: 0x09,
  g: 0x0a,
  h: 0x0b,
  i: 0x0c,
  j: 0x0d,
  k: 0x0e,
  l: 0x0f,
  m: 0x10,
  n: 0x11,
  o: 0x12,
  p: 0x13,
  q: 0x14,
  r: 0x15,
  s: 0x16,
  t: 0x17,
  u: 0x18,
  v: 0x19,
  w: 0x1a,
  x: 0x1b,
  y: 0x1c,
  z: 0x1d,
  "1": 0x1e,
  "2": 0x1f,
  "3": 0x20,
  "4": 0x21,
  "5": 0x22,
  "6": 0x23,
  "7": 0x24,
  "8": 0x25,
  "9": 0x26,
  "0": 0x27,
  "!": 0x1e,
  "@": 0x1f,
  "#": 0x20,
  $: 0x21,
  "%": 0x22,
  "^": 0x23,
  "&": 0x24,
  "*": 0x25,
  "(": 0x26,
  ")": 0x27,
  enter: 0x28,
  escape: 0x29,
  backspace: 0x2a,
  tab: 0x2b,
  space: 0x2c,
  " ": 0x2c,
  "-": 0x2d,
  _: 0x2d,
  "=": 0x2e,
  "+": 0x2e,
  "[": 0x2f,
  "{": 0x2f,
  "]": 0x30,
  "}": 0x30,
  "\\": 0x31,
  "|": 0x31,
  // non-US #
  "~": 0x32,
  ";": 0x33,
  ":": 0x33,
  "'": 0x34,
  '"': 0x34,
  "`": 0x35,
  ",": 0x36,
  //"<": 0x37,
  ".": 0x37,
  //">": 0x37,
  "/": 0x38,
  "?": 0x38,
  capslock: 0x39,
  f1: 0x3a,
  f2: 0x3b,
  f3: 0x3c,
  f4: 0x3d,
  f5: 0x3e,
  f6: 0x3f,
  f7: 0x40,
  f8: 0x41,
  f9: 0x42,
  f10: 0x43,
  f11: 0x44,
  f12: 0x45,
  printscreen: 0x46,
  scrolllock: 0x47,
  pause: 0x48,
  insert: 0x49,
  home: 0x4a,
  pageup: 0x4b,
  delete: 0x4c,
  end: 0x4d,
  pagedown: 0x4e,
  arrowright: 0x4f,
  arrowleft: 0x50,
  arrowdown: 0x51,
  arrowup: 0x52,
  numlock: 0x53,
  numpaddivide: 0x54,
  numpadmultiply: 0x55,
  numpadsubstract: 0x56,
  numpadadd: 0x57,
  numpadenter: 0x58,
  numpad1: 0x59,
  numpad2: 0x5a,
  numpad3: 0x5b,
  numpad4: 0x5c,
  numpad5: 0x5d,
  numpad6: 0x5e,
  numpad7: 0x5f,
  numpad8: 0x60,
  numpad9: 0x61,
  numpad0: 0x62,
  numpaddecimal: 0x63,
  numpadequal: 0x67,
  f13: 0x68,
  f14: 0x69,
  f15: 0x6a,
  f16: 0x6b,
  f17: 0x6c,
  f18: 0x6d,
  f19: 0x6e,
  f20: 0x6f,
  f21: 0x70,
  f22: 0x71,
  f23: 0x72,
  f24: 0x73,
  execute: 0x74,
  help: 0x75,
  contextmenu: 0x76,
  select: 0x77,
  stop: 0x78,
  again: 0x79,
  undo: 0x7a,
  cut: 0x7b,
  copy: 0x7c,
  paste: 0x7d,
  find: 0x7e,
  mute: 0x7f,
  volumeup: 0x80,
  volumedown: 0x81,
  numpadcomma: 0x85
};
/**
 * @internal
 */

const reverseSelectors = Object.keys(selectors).reduce((r, key) => {
  if (!r[selectors[key]]) r[selectors[key]] = key;
  return r;
}, {});
/**
 * @internal
 */

const modifierCodes = {
  controlleft: exports.HidKeyboardModifiers.LeftControl,
  altleft: exports.HidKeyboardModifiers.LeftAlt,
  shiftleft: exports.HidKeyboardModifiers.LeftShift,
  metaleft: exports.HidKeyboardModifiers.LeftGUI,
  controlright: exports.HidKeyboardModifiers.RightControl,
  altright: exports.HidKeyboardModifiers.RightAlt,
  shiftright: exports.HidKeyboardModifiers.RightShift,
  metaright: exports.HidKeyboardModifiers.RightGUI
};
/**
 * @internal
 */

function renderKeyboardKey(selector, modifiers, pretty) {
  const flags = pretty ? ["Ctrl", "Shift", "Alt", "Cmd", "Ctrl Right", "Shift Right", "AltRight", "Cmd Right"] : ["{controlleft}", "{shiftleft}", "{altleft}", "{metaleft}", "{controlright}", "{shiftright}", "{altright}", "{metaright}"];
  const sep = pretty ? " + " : " ";
  const values = [];
  flags.forEach((flag, i) => {
    if (modifiers & 1 << i) {
      values.push(flag);
    }
  });
  const sel = reverseSelectors[selector];
  if (sel !== undefined) values.push(pretty ? sel.toUpperCase() : !pretty && sel.length > 1 ? `{${sel}}` : sel);
  const value = values.filter(v => !!v).join(sep);
  return value;
}
/**
 * @internal
 */


function renderHidMouseButtons(buttons) {
  const btns = [buttons & exports.HidMouseButton.Left ? "left" : "", buttons & exports.HidMouseButton.Right ? "right" : "", buttons & exports.HidMouseButton.Middle ? "middle" : ""].filter(b => !!b).join(", ");
  return btns;
}

class HIDMouseServer extends JDServiceServer {
  constructor(options) {
    super(SRV_HID_MOUSE, options);
    this.addCommand(exports.HidMouseCmd.Move, this.handleMove.bind(this));
    this.addCommand(exports.HidMouseCmd.SetButton, this.handleSetButton.bind(this));
    this.addCommand(exports.HidMouseCmd.Wheel, this.handleWheel.bind(this));
  }

  get lastCommand() {
    return this._lastCommand;
  }

  setLastCommand(s) {
    if (this._lastCommand !== s) {
      this._lastCommand = s;
      this.emit(CHANGE);
    }
  }

  handleMove(pkt) {
    const [dx, dy, time] = pkt.jdunpack("i16 i16 u16");
    this.setLastCommand(`move ${dx} ${dy} ${time}`);
  }

  handleSetButton(pkt) {
    const [buttons, event] = pkt.jdunpack("u16 u8");
    const btns = renderHidMouseButtons(buttons);
    this.setLastCommand(`set buttons ${btns || "?"} ${(exports.HidMouseButtonEvent[event] || "?").toLocaleLowerCase()}`);
  }

  handleWheel(pkt) {
    const [dy, time] = pkt.jdunpack("i16 u16");
    this.setLastCommand(`wheel ${dy} ${time}`);
  }

}

class DimmerServer extends JDServiceServer {
  constructor(instanceName, options = {}) {
    super(SRV_DIMMER, {
      instanceName
    });
    const {
      variant = exports.DimmerVariant.Light
    } = options;
    this.intensity = this.addRegister(exports.DimmerReg.Intensity, [0]);
    this.variant = this.addRegister(exports.DimmerReg.Variant, [variant]);
  }

}
/* eslint-disable @typescript-eslint/no-unused-vars */


function splitPair(kv) {
  const i = kv.indexOf("=");
  if (i < 0) return [kv, ""];else return [kv.slice(0, i), kv.slice(i + 1)];
}

function parsePropertyBag(msg, separator) {
  const r = {};
  msg.split(separator || "&").map(kv => splitPair(kv)).forEach(parts => r[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]));
  return r;
}

class AzureIoTHubHealthServer extends JDServiceServer {
  constructor(options) {
    super(SRV_AZURE_IOT_HUB_HEALTH, options);
    this.hubName = this.addRegister(exports.AzureIotHubHealthReg.HubName, [""]);
    this.hubDeviceId = this.addRegister(exports.AzureIotHubHealthReg.HubDeviceId, [""]);
    this.connectionStatus = this.addRegister(exports.AzureIotHubHealthReg.ConnectionStatus, [exports.AzureIotHubHealthConnectionStatus.Connected]);
    this.connectionStatus.on(CHANGE, () => this.sendEvent(exports.AzureIotHubHealthEvent.ConnectionStatusChange));
    this.connectionString = "";
    this.addCommand(exports.AzureIotHubHealthCmd.Connect, this.handleConnect.bind(this));
    this.addCommand(exports.AzureIotHubHealthCmd.Disconnect, this.handleDisconnect.bind(this));
    this.addCommand(exports.AzureIotHubHealthCmd.SetConnectionString, this.handleSetConnectionString.bind(this));
  }

  async handleConnect() {
    this.connectionStatus.setValues([exports.AzureIotHubHealthConnectionStatus.Connecting]);
    await delay(500);
    if (!this.connectionString) this.connectionStatus.setValues([401]);else this.connectionStatus.setValues([exports.AzureIotHubHealthConnectionStatus.Connected]);
  }

  async handleDisconnect() {
    this.connectionStatus.setValues([exports.AzureIotHubHealthConnectionStatus.Disconnecting]);
    await delay(500);
    this.connectionStatus.setValues([exports.AzureIotHubHealthConnectionStatus.Disconnected]);
  }

  async handleSetConnectionString(pkt) {
    const newConnectionString = pkt.stringData;

    if (newConnectionString !== this.connectionString) {
      await this.handleDisconnect();
      this.connectionString = newConnectionString;
      const connStringParts = parsePropertyBag(this.connectionString, ";");
      this.hubName.setValues([connStringParts["HostName"] || ""]);
      this.hubDeviceId.setValues([connStringParts["DeviceId"] || ""]); // notify connection string changed

      this.sendEvent(exports.AzureIotHubHealthEvent.ConnectionStatusChange);
    }
  }

}

class VibrationMotorServer extends JDServiceServer {
  constructor() {
    super(SRV_VIBRATION_MOTOR);
    this._animationStep = -1;
    this.enabled = this.addRegister(exports.VibrationMotorReg.Enabled, [false]);
    this.addCommand(exports.VibrationMotorCmd.Vibrate, this.handleVibrate.bind(this));
    this.on(REFRESH, this.handleRefresh.bind(this));
  }

  handleRefresh() {
    if (!this._animation) return; // nothing to do

    const {
      start,
      pattern
    } = this._animation;
    const now = this.device.bus.timestamp;
    const elapsed = now - start;
    let t = 0;

    for (let i = 0; i < pattern.length; ++i) {
      const [duration, speed] = pattern[i];
      const dt = duration << 3;
      t += dt;

      if (t - dt <= elapsed && t > elapsed) {
        // we're playing this note
        if (this._animationStep !== i) {
          this._animationStep = i;
          this.emit(VibrationMotorServer.VIBRATE_PATTERN, {
            duration,
            speed
          });
        }

        break;
      }
    }

    if (elapsed > t) {
      // animation finished
      this._animation = undefined;
      this._animationStep = -1;
      this.emit(VibrationMotorServer.VIBRATE_PATTERN, {
        duration: 0,
        speed: 0
      });
      this.emit(CHANGE);
    }
  }

  handleVibrate(pkt) {
    const [pattern] = pkt.jdunpack("r: u8 u0.8");
    this._animation = {
      start: this.device.bus.timestamp,
      pattern
    };
    this._animationStep = -1;

    if (pattern.length) {
      const [duration, speed] = pattern[0];
      this._animationStep = 0;
      this.emit(VibrationMotorServer.VIBRATE_PATTERN, {
        duration,
        speed
      });
    }

    this.emit(CHANGE);
  }

}

VibrationMotorServer.VIBRATE_PATTERN = "vibratePattern";

class WifiServer extends JDServiceServer {
  constructor() {
    super(SRV_WIFI, {
      intensityValues: [true]
    });
    this._lastScanResults = [{
      ssid: "HOME",
      bssid: new Uint8Array(0),
      rssi: -42,
      channel: 10,
      flags: exports.WifiAPFlags.WPS | exports.WifiAPFlags.IEEE_802_11B
    }];
    this._knownNetworks = [{
      ssid: "HOME",
      password: "home",
      priority: 0,
      flags: exports.WifiAPFlags.WPS | exports.WifiAPFlags.IEEE_802_11B
    }];
    this.enabled = this.addRegister(exports.WifiReg.Enabled, [true]);
    this.connected = this.addRegister(exports.WifiReg.Connected, [false]);
    this.ssid = this.addRegister(exports.WifiReg.Ssid, [""]);
    this.ipAddress = this.addRegister(exports.WifiReg.IpAddress, [new Uint8Array(0)]);
    this.eui48 = this.addRegister(exports.WifiReg.Eui48, [randomBytes(6)]);
    this.addCommand(exports.WifiCmd.Scan, this.handleScan.bind(this));
    this.addCommand(exports.WifiCmd.Reconnect, this.handleReconnect.bind(this));
    this.addCommand(exports.WifiCmd.LastScanResults, this.handleLastScanResults.bind(this));
    this.addCommand(exports.WifiCmd.ListKnownNetworks, this.handleListKnownNetworks.bind(this));
    this.addCommand(exports.WifiCmd.AddNetwork, this.handleAddNetwork.bind(this));
    this.addCommand(exports.WifiCmd.ForgetAllNetworks, this.handleForgetAllNetworks.bind(this));
    this.addCommand(exports.WifiCmd.ForgetNetwork, this.handleForgetNetwork.bind(this));
    this.addCommand(exports.WifiCmd.SetNetworkPriority, this.handleSetNetworkPriority.bind(this));
    this.ipAddress.on(CHANGE, this.handleIpChange.bind(this));
    this.enabled.on(CHANGE, this.handleEnabledChange.bind(this));
  }

  handleEnabledChange() {
    const [enabled] = this.enabled.values();
    if (!enabled) this.disconnect();else this.connect();
  }

  handleIpChange() {
    const [ip] = this.ipAddress.values();
    console.debug(`wifi: ip ${toHex(ip)}`);
    if (ip === null || ip === void 0 ? void 0 : ip.length) this.sendEvent(exports.WifiEvent.GotIp);else this.sendEvent(exports.WifiEvent.LostIp);
  }

  get scannedKnownNetworks() {
    return this._lastScanResults.filter(n => this._knownNetworks.some(kn => kn.ssid === n.ssid));
  }

  handleReconnect() {
    console.debug(`wifi: reconnect`, {
      scan: this._lastScanResults,
      known: this._knownNetworks,
      networks: this.scannedKnownNetworks,
      enabled: this.enabled.values()[0],
      connected: this.connected.values()[0]
    });
    this.disconnect();

    if (this.scannedKnownNetworks.length) {
      console.debug(`wifi: reconnect, connect`);
      this.enabled.setValues([true]);
    }
  }

  connect() {
    console.debug(`wifi: connect`, {
      scan: this._lastScanResults,
      known: this._knownNetworks,
      networks: this.scannedKnownNetworks
    });
    const network = this.scannedKnownNetworks[0];
    const {
      ssid
    } = network || {};
    this.ssid.setValues([ssid || ""]);
    this.enabled.setValues([!!ssid]);
    this.connected.setValues([!!ssid]);
    this.ipAddress.setValues([randomBytes(4)]);
  }

  disconnect() {
    console.debug(`wifi: disconnect`);
    this.ssid.setValues([""]);
    this.connected.setValues([false]);
    this.enabled.setValues([false]);
    this.ipAddress.setValues([new Uint8Array(0)]);
  }

  scan() {
    this._lastScanResults = [{
      ssid: "HOME",
      bssid: new Uint8Array(0),
      rssi: -42,
      channel: 10,
      flags: exports.WifiAPFlags.WPS | exports.WifiAPFlags.IEEE_802_11B
    }, Math.random() > 0.5 && {
      ssid: "OFFICE",
      bssid: new Uint8Array(0),
      rssi: -70,
      channel: 11,
      flags: exports.WifiAPFlags.IEEE_802_11N
    }].filter(res => !!res);
    this.sendEvent(exports.WifiEvent.ScanComplete, jdpack("u16 u16", [this._lastScanResults.length, this.scannedKnownNetworks.length]));
  }

  handleScan() {
    this.scan();
  }

  async handleLastScanResults(pkt) {
    const pipe = OutPipe.from(this.device.bus, pkt, true);
    console.debug(`list scan results`, this._lastScanResults);
    await pipe.respondForEach(this._lastScanResults, ({
      flags,
      rssi,
      channel,
      bssid,
      ssid
    }) => jdpack("u32 x[4] i8 u8 b[6] s[33]", [flags, rssi, channel, bssid, ssid]));
  }

  async handleListKnownNetworks(pkt) {
    const pipe = OutPipe.from(this.device.bus, pkt, true);
    console.debug(`list knowns`, this._knownNetworks);
    await pipe.respondForEach(this._knownNetworks, ({
      priority,
      flags,
      ssid
    }) => jdpack("i16 i16 s", [priority, flags, ssid]));
  }

  handleAddNetwork(pkt) {
    console.debug(`wifi: add network`);
    const [ssid, password] = pkt.jdunpack("z z");

    let network = this._knownNetworks.find(n => n.ssid === ssid);

    if (!network) {
      const scanned = this._lastScanResults.find(s => s.ssid === ssid);

      this._knownNetworks.push(network = {
        ssid,
        flags: scanned === null || scanned === void 0 ? void 0 : scanned.flags,
        priority: 0,
        password: ""
      });
    }

    network.password = password;
    this.sendEvent(exports.WifiEvent.NetworksChanged);
  }

  handleForgetAllNetworks() {
    this._knownNetworks = [];
    this.disconnect();
    this.sendEvent(exports.WifiEvent.NetworksChanged);
  }

  handleForgetNetwork(pkt) {
    const [ssid] = pkt.jdunpack("s");
    this._knownNetworks = this._knownNetworks.filter(network => network.ssid !== ssid);
    const [currentSsid] = this.ssid.values();
    if (ssid === currentSsid) this.disconnect();
    this.sendEvent(exports.WifiEvent.NetworksChanged);
  }

  handleSetNetworkPriority(pkt) {
    const [priority, ssid] = pkt.jdunpack("i16 s");

    const network = this._knownNetworks.find(network => network.ssid === ssid);

    if (network) network.priority = priority;
    this.sendEvent(exports.WifiEvent.NetworksChanged);
  }

}

const indoorThermometerOptions = {
  instanceName: "indoor",
  readingValues: [21.5],
  streamingInterval: 1000,
  minReading: -5,
  maxReading: 50,
  readingError: [0.25],
  variant: exports.ThermometerVariant.Indoor
};
const outdoorThermometerOptions = {
  instanceName: "temperature",
  readingValues: [21.5],
  streamingInterval: 60000,
  minReading: -40,
  maxReading: 120,
  readingError: [0.25],
  variant: exports.ThermometerVariant.Outdoor
};
const outdoorHumidityOptions = {
  instanceName: "humidity",
  streamingInterval: 60000,
  readingValues: [40],
  readingError: [0.1]
};
const medicalThermometerOptions = {
  instanceName: "medical",
  readingValues: [37.5],
  streamingInterval: 1000,
  minReading: 35,
  maxReading: 42,
  readingError: [0.5],
  variant: exports.ThermometerVariant.Body
};
const barometerOptions = {
  instanceName: "pressure",
  readingValues: [1013],
  readingError: [0.4]
};
const sonarOptions = {
  variant: exports.DistanceVariant.Ultrasonic,
  minReading: 0.02,
  maxReading: 4,
  readingValues: [1]
};
const SG90_STALL_TORQUE = 1.8;
/**
 * @internal
 */

const SG90_RESPONSE_SPEED = 0.12; // deg/60deg

const microServoOptions = {
  stallTorque: SG90_STALL_TORQUE,
  responseSpeed: SG90_RESPONSE_SPEED,
  minAngle: -90,
  maxAngle: 90
};
const microServo270Options = {
  stallTorque: SG90_STALL_TORQUE,
  responseSpeed: SG90_RESPONSE_SPEED,
  minAngle: -135,
  maxAngle: 135
};
const microServo360Options = {
  stallTorque: SG90_STALL_TORQUE,
  responseSpeed: SG90_RESPONSE_SPEED * 2,
  minAngle: -180,
  maxAngle: 180
};
const windDirectionOptions = {
  readingValues: [0],
  readingError: [5],
  streamingInterval: 1000
};
const windSpeedOptions = {
  readingValues: [0],
  readingError: [0.5],
  streamingInterval: 1000,
  registerValues: [{
    code: exports.WindSpeedReg.MaxWindSpeed,
    values: [55]
  }]
};
const eCO2Options = {
  readingValues: [4000],
  streamingInterval: 1000,
  variant: exports.ECO2Variant.VOC
};
const CO2Options = {
  readingValues: [4000],
  streamingInterval: 1000,
  variant: exports.ECO2Variant.NDIR
};
const tvocOptions = {
  readingValues: [500],
  streamingInterval: 1000
};
const microbitSounds = [[0, "giggle"], [0, "happy"], [0, "hello"], [0, "mysterious"], [0, "sad"], [0, "slide"], [0, "soaring"], [0, "spring"], [0, "twinkle"], [0, "yawn"]];
const soundLevel = {
  readingValues: [0],
  inactiveThreshold: 10,
  activeThreshold: 70,
  intensityValues: [false],
  registerValues: [{
    code: exports.SoundLevelReg.MinDecibels,
    values: [-100]
  }, {
    code: exports.SoundLevelReg.MaxDecibels,
    values: [-30]
  }]
};
const soundSpectrum = {
  readingValues: [new Uint8Array(0)],
  intensityValues: [false],
  registerValues: [{
    code: exports.SoundSpectrumReg.FftPow2Size,
    values: [5]
  }, {
    code: exports.SoundSpectrumReg.MinDecibels,
    values: [-100]
  }, {
    code: exports.SoundSpectrumReg.MaxDecibels,
    values: [-30]
  }, {
    code: exports.SoundSpectrumReg.SmoothingTimeConstant,
    values: [0.8]
  }]
};
const _providerDefinitions = [{
  name: "7-segment (4 segments)",
  serviceClasses: [SRV_SEVEN_SEGMENT_DISPLAY],
  services: () => [new JDServiceServer(SRV_SEVEN_SEGMENT_DISPLAY, {
    intensityValues: [0xffff],
    valueValues: [fromHex("ff112233")],
    registerValues: [{
      code: exports.SevenSegmentDisplayReg.DigitCount,
      values: [4]
    }, {
      code: exports.SevenSegmentDisplayReg.DecimalPoint,
      values: [true]
    }]
  })]
}, {
  name: "7-segment (8 segments)",
  serviceClasses: [SRV_SEVEN_SEGMENT_DISPLAY],
  services: () => [new JDServiceServer(SRV_SEVEN_SEGMENT_DISPLAY, {
    intensityValues: [0xffff],
    valueValues: [fromHex("0102040810204080")],
    registerValues: [{
      code: exports.SevenSegmentDisplayReg.DigitCount,
      values: [8]
    }, {
      code: exports.SevenSegmentDisplayReg.DecimalPoint,
      values: [true]
    }]
  })]
}, {
  name: "accelerometer",
  serviceClasses: [SRV_ACCELEROMETER],
  services: () => [new SensorServer(SRV_ACCELEROMETER, {
    readingValues: [0.5, 0.5, -(1 - (0.5 * 0.5 + 0.5 * 0.5))],
    preferredStreamingInterval: 20
  })]
}, {
  name: "barometer",
  serviceClasses: [SRV_BAROMETER],
  services: () => [new AnalogSensorServer(SRV_BAROMETER, barometerOptions)]
}, {
  name: "bitradio",
  serviceClasses: [SRV_BIT_RADIO],
  services: () => [new BitRadioServer()]
}, {
  name: "button",
  serviceClasses: [SRV_BUTTON],
  services: () => [new ButtonServer()]
}, {
  name: "button (2x)",
  serviceClasses: [SRV_BUTTON],
  services: () => [new ButtonServer("B0"), new ButtonServer("B1")]
}, {
  name: "button (4x)",
  serviceClasses: [SRV_BUTTON],
  services: () => Array(4).fill(0).map((_, i) => new ButtonServer(`B${i}`))
}, {
  name: "buzzer",
  serviceClasses: [SRV_BUZZER],
  services: () => [new BuzzerServer()]
}, {
  name: "capacitive button",
  serviceClasses: [SRV_BUTTON],
  services: () => {
    const button = new ButtonServer();
    const config = new CapacitiveButtonServer();
    button.threshold = config.threshold;
    return [button, config];
  }
}, {
  name: "capacitive button (6x)",
  serviceClasses: [SRV_BUTTON],
  services: () => Array(6).fill(0).map((_, i) => new ButtonServer(`C${i}`, true))
}, {
  name: "capacitive button (12x)",
  serviceClasses: [SRV_BUTTON],
  services: () => Array(12).fill(0).map((_, i) => new ButtonServer(`C${i}`, true))
}, {
  name: "character screen (LDC, 16x2)",
  serviceClasses: [SRV_CHARACTER_SCREEN],
  services: () => [new CharacterScreenServer({
    message: "hello\nworld!"
  })]
}, {
  name: "character screen (OLED, 32x8, RTL)",
  serviceClasses: [SRV_CHARACTER_SCREEN],
  services: () => [new CharacterScreenServer({
    message: "hello\nworld!",
    columns: 32,
    rows: 8,
    variant: exports.CharacterScreenVariant.OLED,
    textDirection: exports.CharacterScreenTextDirection.RightToLeft
  })]
}, {
  name: "character screen (Braille, 4x1)",
  serviceClasses: [SRV_CHARACTER_SCREEN],
  services: () => [new CharacterScreenServer({
    message: "hi",
    columns: 4,
    rows: 1,
    variant: exports.CharacterScreenVariant.Braille,
    textDirection: exports.CharacterScreenTextDirection.LeftToRight
  })]
}, {
  name: "color",
  serviceClasses: [SRV_COLOR],
  services: () => [new SensorServer(SRV_COLOR, {
    readingValues: [0.5, 0, 0.5],
    preferredStreamingInterval: 1000
  })]
}, {
  name: "compass",
  serviceClasses: [SRV_COMPASS],
  services: () => [new CompassServer()]
}, {
  name: "dimmer (fan)",
  serviceClasses: [SRV_DIMMER],
  services: () => [new DimmerServer("fan", {
    variant: exports.DimmerVariant.Fan
  })]
}, {
  name: "dimmer (light)",
  serviceClasses: [SRV_DIMMER],
  services: () => [new DimmerServer("light", {
    variant: exports.DimmerVariant.Light
  })]
}, {
  name: "distance (sonar)",
  serviceClasses: [SRV_DISTANCE],
  services: () => [new AnalogSensorServer(SRV_DISTANCE, sonarOptions)]
}, {
  name: "DMX",
  serviceClasses: [SRV_DMX],
  services: () => [new DMXServer()]
}, {
  name: "eCO₂",
  serviceClasses: [SRV_E_CO2],
  services: () => [new AnalogSensorServer(SRV_E_CO2, eCO2Options)]
}, {
  name: "eCO₂ + TVOC",
  serviceClasses: [SRV_E_CO2, SRV_TVOC],
  services: () => [new AnalogSensorServer(SRV_E_CO2, eCO2Options), new AnalogSensorServer(SRV_TVOC, tvocOptions)]
}, {
  name: "eCO₂ + humidity + thermometer",
  serviceClasses: [SRV_E_CO2, SRV_HUMIDITY, SRV_THERMOMETER],
  services: () => [new AnalogSensorServer(SRV_E_CO2, CO2Options), new AnalogSensorServer(SRV_HUMIDITY, outdoorHumidityOptions), new AnalogSensorServer(SRV_THERMOMETER, indoorThermometerOptions)]
}, {
  name: "flex sensor (2.2 inch)",
  serviceClasses: [SRV_FLEX],
  services: () => [new AnalogSensorServer(SRV_FLEX, {
    variant: exports.FlexVariant.Linear22Inch,
    readingValues: [0.5]
  })]
}, {
  name: "gyroscope",
  serviceClasses: [SRV_GYROSCOPE],
  services: () => [new SensorServer(SRV_GYROSCOPE, {
    readingValues: [0, 0, 0]
  })]
}, {
  name: "heart rate",
  serviceClasses: [SRV_HEART_RATE],
  services: () => [new AnalogSensorServer(SRV_HEART_RATE, {
    readingValues: [80],
    streamingInterval: 100,
    variant: exports.HeartRateVariant.Finger
  })]
}, {
  name: "humidity",
  serviceClasses: [SRV_HUMIDITY],
  services: () => [new AnalogSensorServer(SRV_HUMIDITY, outdoorHumidityOptions)]
}, {
  name: "humidity + temperature",
  serviceClasses: [SRV_HUMIDITY, SRV_THERMOMETER],
  services: () => [new AnalogSensorServer(SRV_THERMOMETER, outdoorThermometerOptions), new AnalogSensorServer(SRV_HUMIDITY, outdoorHumidityOptions)]
}, {
  name: "humidity + temperature + barometer",
  serviceClasses: [SRV_HUMIDITY, SRV_THERMOMETER, SRV_BAROMETER],
  services: () => [new AnalogSensorServer(SRV_THERMOMETER, outdoorThermometerOptions), new AnalogSensorServer(SRV_HUMIDITY, outdoorHumidityOptions), new AnalogSensorServer(SRV_BAROMETER, barometerOptions)]
}, {
  name: "illuminance",
  serviceClasses: [SRV_ILLUMINANCE],
  services: () => [new AnalogSensorServer(SRV_ILLUMINANCE, {
    readingValues: [1]
  })]
}, {
  name: "joystick (stick + A + B)",
  serviceClasses: [SRV_JOYSTICK],
  services: () => [new JoystickServer({
    variant: exports.JoystickVariant.Thumb,
    buttonsAvailable: exports.JoystickButtons.A | exports.JoystickButtons.B
  })]
}, {
  name: "joystick (stick)",
  serviceClasses: [SRV_JOYSTICK],
  services: () => [new JoystickServer({
    variant: exports.JoystickVariant.Thumb
  })]
}, {
  name: "joystick (stick+A)",
  serviceClasses: [SRV_JOYSTICK],
  services: () => [new JoystickServer({
    variant: exports.JoystickVariant.Thumb,
    buttonsAvailable: exports.JoystickButtons.A
  })]
}, {
  name: "joystick (Dpad + all buttons)",
  serviceClasses: [SRV_JOYSTICK],
  services: () => [new JoystickServer({
    variant: exports.JoystickVariant.Gamepad,
    buttonsAvailable: JOYSTICK_ARCADE_BUTTONS
  })]
}, {
  name: "joystick (only DPad+A/B)",
  serviceClasses: [SRV_JOYSTICK],
  services: () => [new JoystickServer({
    variant: exports.JoystickVariant.Gamepad,
    buttonsAvailable: JOYSTICK_DPAD_AB_BUTTONS
  })]
}, {
  name: "RGB LED (RGB through hole)",
  serviceClasses: [SRV_LED],
  services: () => [new LEDServer({
    variant: exports.LedVariant.ThroughHole,
    ledCount: 1,
    color: [255, 0, 0]
  })]
}, {
  name: "LED (5x blue through hole)",
  serviceClasses: [SRV_LED],
  services: () => [new LEDServer({
    variant: exports.LedVariant.ThroughHole,
    waveLength: 450,
    ledCount: 5,
    color: [0, 0, 255]
  })]
}, {
  name: "LED matrix (5x5 micro:bit)",
  serviceClasses: [SRV_DOT_MATRIX],
  services: () => [new DotMatrixServer(5, 5, {
    brightness: 128,
    variant: exports.DotMatrixVariant.LED
  })]
}, {
  name: "LED matrix (8x8)",
  serviceClasses: [SRV_DOT_MATRIX],
  services: () => [new DotMatrixServer(8, 8, {
    brightness: 128,
    variant: exports.DotMatrixVariant.LED
  })]
}, {
  name: "LED matrix (11x7)",
  serviceClasses: [SRV_DOT_MATRIX],
  services: () => [new DotMatrixServer(11, 7, {
    brightness: 128,
    variant: exports.DotMatrixVariant.LED
  })]
}, {
  name: "Braille matrix (8x4)",
  serviceClasses: [SRV_DOT_MATRIX],
  services: () => [new DotMatrixServer(8, 4, {
    variant: exports.DotMatrixVariant.Braille
  })]
}, {
  name: "LED pixel ring 10",
  serviceClasses: [SRV_LED_PIXEL],
  services: () => [new LedPixelServer({
    numPixels: 10,
    variant: exports.LedPixelVariant.Ring
  })]
}, {
  name: "LED pixel ring 12",
  serviceClasses: [SRV_LED_PIXEL],
  services: () => [new LedPixelServer({
    numPixels: 12,
    variant: exports.LedPixelVariant.Ring
  })]
}, {
  name: "LED pixel ring 16",
  serviceClasses: [SRV_LED_PIXEL],
  services: () => [new LedPixelServer({
    numPixels: 16,
    variant: exports.LedPixelVariant.Ring
  })]
}, {
  name: "LED pixel ring 24",
  serviceClasses: [SRV_LED_PIXEL],
  services: () => [new LedPixelServer({
    numPixels: 24,
    variant: exports.LedPixelVariant.Ring
  })]
}, {
  name: "LED pixel jewel 7",
  serviceClasses: [SRV_LED_PIXEL],
  services: () => [new LedPixelServer({
    numPixels: 7,
    variant: exports.LedPixelVariant.Jewel
  })]
}, {
  name: "LED pixel stick 8",
  serviceClasses: [SRV_LED_PIXEL],
  services: () => [new LedPixelServer({
    numPixels: 8,
    variant: exports.LedPixelVariant.Stick
  })]
}, {
  name: "LED pixel strip 30",
  serviceClasses: [SRV_LED_PIXEL],
  services: () => [new LedPixelServer({
    numPixels: 60,
    maxPower: 1000,
    variant: exports.LedPixelVariant.Strip
  })]
}, {
  name: "LED pixel strip 60",
  serviceClasses: [SRV_LED_PIXEL],
  services: () => [new LedPixelServer({
    numPixels: 60,
    maxPower: 2000,
    variant: exports.LedPixelVariant.Strip
  })]
}, {
  name: "LED pixel strip 150",
  serviceClasses: [SRV_LED_PIXEL],
  services: () => [new LedPixelServer({
    numPixels: 150,
    maxPower: 5000,
    variant: exports.LedPixelVariant.Strip
  })]
}, {
  name: "LED pixel strip 300",
  serviceClasses: [SRV_LED_PIXEL],
  services: () => [new LedPixelServer({
    numPixels: 300,
    maxPower: 5000,
    variant: exports.LedPixelVariant.Strip
  })]
}, {
  name: "LED pixel matrix (4x4)",
  serviceClasses: [SRV_LED_PIXEL],
  services: () => [new LedPixelServer({
    numPixels: 16,
    variant: exports.LedPixelVariant.Matrix
  })]
}, {
  name: "LED pixel matrix (8x8)",
  serviceClasses: [SRV_LED_PIXEL],
  services: () => [new LedPixelServer({
    numPixels: 64,
    variant: exports.LedPixelVariant.Matrix
  })]
}, {
  name: "LED pixel matrix (16x4)",
  serviceClasses: [SRV_LED_PIXEL],
  services: () => [new LedPixelServer({
    numPixels: 64,
    numColumns: 16,
    variant: exports.LedPixelVariant.Matrix
  })]
}, {
  name: "light level (photo-resistor)",
  serviceClasses: [SRV_LIGHT_LEVEL],
  services: () => [new SensorServer(SRV_LIGHT_LEVEL, {
    readingValues: [0.5],
    variant: exports.LightLevelVariant.PhotoResistor
  })]
}, {
  name: "line tracker (digital)",
  serviceClasses: [SRV_REFLECTED_LIGHT],
  services: () => [new ReflectedLightServer()]
}, {
  name: "line tracker (2x digital)",
  serviceClasses: [SRV_REFLECTED_LIGHT],
  services: () => [new ReflectedLightServer(), new ReflectedLightServer()]
}, {
  name: "line tracker (analog)",
  serviceClasses: [SRV_REFLECTED_LIGHT],
  services: () => [new ReflectedLightServer({
    variant: exports.ReflectedLightVariant.InfraredAnalog
  })]
}, {
  name: "matrix keypad (3x4)",
  serviceClasses: [SRV_MATRIX_KEYPAD],
  services: () => [new MatrixKeypadServer(3, 4, ["0", "1", "2", "3", "4", "5", "6", "7", "8", "*", "0", "#"])]
}, {
  name: "matrix keypad (4x4)",
  serviceClasses: [SRV_MATRIX_KEYPAD],
  services: () => [new MatrixKeypadServer(4, 4, ["0", "1", "2", "A", "3", "4", "5", "B", "6", "7", "8", "C", "*", "0", "#", "D"])]
}, {
  name: "matrix keypad (1x4)",
  serviceClasses: [SRV_MATRIX_KEYPAD],
  services: () => [new MatrixKeypadServer(4, 1, ["1", "2", "3", "4"])]
}, {
  name: "motion",
  serviceClasses: [SRV_MOTION],
  services: () => [new SensorServer(SRV_MOTION, {
    readingValues: [false],
    streamingInterval: 1000
  })]
}, {
  name: "motor",
  serviceClasses: [SRV_MOTOR],
  services: () => [new MotorServer()],
  resetIn: true
}, {
  name: "protocol test",
  serviceClasses: [SRV_PROTO_TEST],
  services: () => [new ProtocolTestServer()]
}, {
  name: "pulse oxymeter",
  serviceClasses: [SRV_PULSE_OXIMETER],
  services: () => [new SensorServer(SRV_PULSE_OXIMETER, {
    readingValues: [98],
    streamingInterval: 1000
  })]
}, {
  name: "oxymeter + heart beat",
  serviceClasses: [SRV_PULSE_OXIMETER, SRV_HEART_RATE],
  services: () => [new SensorServer(SRV_PULSE_OXIMETER, {
    readingValues: [98],
    streamingInterval: 1000
  }), new AnalogSensorServer(SRV_HEART_RATE, {
    readingValues: [80],
    streamingInterval: 1000,
    variant: exports.HeartRateVariant.Finger
  })]
}, {
  name: "power",
  serviceClasses: [SRV_POWER],
  services: () => [new PowerServer()]
}, {
  name: "RNG (random number generator)",
  serviceClasses: [SRV_RNG],
  services: () => [new RandomNumberGeneratorServer()]
}, {
  name: "rain gauge",
  serviceClasses: [SRV_RAIN_GAUGE],
  services: () => [new RainGaugeServer()]
}, {
  name: "real time clock",
  serviceClasses: [SRV_REAL_TIME_CLOCK],
  services: () => [new RealTimeClockServer()]
}, {
  name: "relay (EM/10A)",
  serviceClasses: [SRV_RELAY],
  services: () => [new JDServiceServer(SRV_RELAY, {
    intensityValues: [false],
    isActive: values => !!(values === null || values === void 0 ? void 0 : values[0]),
    variant: exports.RelayVariant.Electromechanical,
    registerValues: [{
      code: exports.RelayReg.MaxSwitchingCurrent,
      values: [10]
    }]
  })]
}, {
  name: "relay 4x (SSR/5A)",
  serviceClasses: [SRV_RELAY],
  services: () => Array(4).fill(0).map(() => new JDServiceServer(SRV_RELAY, {
    intensityValues: [false],
    isActive: values => !!(values === null || values === void 0 ? void 0 : values[0]),
    variant: exports.RelayVariant.SolidState,
    registerValues: [{
      code: exports.RelayReg.MaxSwitchingCurrent,
      values: [5]
    }]
  }))
}, {
  name: "rotary encoder",
  serviceClasses: [SRV_ROTARY_ENCODER],
  services: () => [new RotaryEncoderServer()]
}, {
  name: "rotary encoder + button",
  serviceClasses: [SRV_ROTARY_ENCODER, SRV_BUTTON],
  services: () => [new RotaryEncoderServer(), new ButtonServer()]
}, {
  name: "rotary potentiometer",
  serviceClasses: [SRV_POTENTIOMETER],
  services: () => [new AnalogSensorServer(SRV_POTENTIOMETER, {
    variant: exports.PotentiometerVariant.Rotary,
    readingValues: [0.5]
  })]
}, {
  name: "servo",
  serviceClasses: [SRV_SERVO],
  services: () => [new ServoServer(microServoOptions)],
  resetIn: true
}, {
  name: "servo (270°)",
  serviceClasses: [SRV_SERVO],
  services: () => [new ServoServer(microServo270Options)],
  resetIn: true
}, {
  name: "servo (360°)",
  serviceClasses: [SRV_SERVO],
  services: () => [new ServoServer(microServo360Options)],
  resetIn: true
}, {
  name: "servo x 2",
  serviceClasses: [SRV_SERVO],
  resetIn: true,
  services: () => Array(2).fill(0).map((_, i) => new ServoServer(Object.assign(Object.assign({}, microServoOptions), {
    instanceName: `S${i}`
  })))
}, {
  name: "servo x 4",
  serviceClasses: [SRV_SERVO],
  resetIn: true,
  services: () => Array(4).fill(0).map((_, i) => new ServoServer(Object.assign(Object.assign({}, microServoOptions), {
    instanceName: `S${i}`
  })))
}, {
  name: "servo x 6",
  serviceClasses: [SRV_SERVO],
  resetIn: true,
  services: () => Array(6).fill(0).map((_, i) => new ServoServer(Object.assign(Object.assign({}, microServoOptions), {
    instanceName: `S${i}`
  })))
}, {
  name: "servo x 16",
  serviceClasses: [SRV_SERVO],
  resetIn: true,
  services: () => Array(16).fill(0).map((_, i) => new ServoServer(Object.assign(Object.assign({}, microServoOptions), {
    instanceName: `S${i}`
  })))
}, {
  name: "settings",
  serviceClasses: [SRV_SETTINGS],
  services: () => [new SettingsServer()]
}, {
  name: "slider (potentiometer)",
  serviceClasses: [SRV_POTENTIOMETER],
  services: () => [new AnalogSensorServer(SRV_POTENTIOMETER, {
    variant: exports.PotentiometerVariant.Slider
  })]
}, {
  name: "soil moisture",
  serviceClasses: [SRV_SOIL_MOISTURE],
  services: () => [new AnalogSensorServer(SRV_SOIL_MOISTURE, {
    readingValues: [0.5],
    streamingInterval: 1000
  })]
}, {
  name: "speech synthesis",
  serviceClasses: [SRV_SPEECH_SYNTHESIS],
  services: () => [new SpeechSynthesisServer()]
}, {
  name: "solenoid",
  serviceClasses: [SRV_SOLENOID],
  services: () => [new JDServiceServer(SRV_SOLENOID, {
    intensityValues: [0]
  })]
}, {
  name: "sound level",
  serviceClasses: [SRV_SOUND_LEVEL],
  services: () => [new AnalogSensorServer(SRV_SOUND_LEVEL, soundLevel)]
}, {
  name: "sound spectrum",
  serviceClasses: [SRV_SOUND_SPECTRUM],
  services: () => [new SensorServer(SRV_SOUND_SPECTRUM, soundSpectrum)]
}, {
  name: "sound player (micro:bit v2 sounds)",
  serviceClasses: [SRV_SOUND_PLAYER],
  services: () => [new SoundPlayerServer(microbitSounds)]
}, {
  name: "switch (slide)",
  serviceClasses: [SRV_SWITCH],
  services: () => [new SwitchServer({
    variant: exports.SwitchVariant.Slide
  })]
}, {
  name: "switch (push button)",
  serviceClasses: [SRV_SWITCH],
  services: () => [new SwitchServer({
    variant: exports.SwitchVariant.PushButton
  })]
}, {
  name: "switch (toggle)",
  serviceClasses: [SRV_SWITCH],
  services: () => [new SwitchServer({
    variant: exports.SwitchVariant.Toggle
  })]
}, {
  name: "switch (tilt)",
  serviceClasses: [SRV_SWITCH],
  services: () => [new SwitchServer({
    variant: exports.SwitchVariant.Tilt
  })]
}, {
  name: "switch (proximity)",
  serviceClasses: [SRV_SWITCH],
  services: () => [new SwitchServer({
    variant: exports.SwitchVariant.Proximity,
    autoOffDelay: 30
  })]
}, {
  name: "thermometer (outdoor)",
  serviceClasses: [SRV_THERMOMETER],
  services: () => [new AnalogSensorServer(SRV_THERMOMETER, outdoorThermometerOptions)]
}, {
  name: "thermometer (medical)",
  serviceClasses: [SRV_THERMOMETER],
  services: () => [new AnalogSensorServer(SRV_THERMOMETER, medicalThermometerOptions)]
}, {
  name: "traffic light",
  serviceClasses: [SRV_TRAFFIC_LIGHT],
  services: () => [new TrafficLightServer()]
}, {
  name: "traffic crossing (4 x lights)",
  serviceClasses: [SRV_TRAFFIC_LIGHT],
  services: () => Array(4).fill(0).map(_ => new TrafficLightServer())
}, {
  name: "thermocouple",
  serviceClasses: [SRV_THERMOCOUPLE],
  services: () => [new AnalogSensorServer(SRV_THERMOCOUPLE, {
    readingValues: [550],
    streamingInterval: 1000,
    minReading: 0,
    maxReading: 1100,
    readingError: [2.2],
    variant: exports.ThermocoupleVariant.TypeB
  })]
}, {
  name: "TVOC",
  serviceClasses: [SRV_TVOC],
  services: () => [new AnalogSensorServer(SRV_TVOC, tvocOptions)]
}, {
  name: "UV index",
  serviceClasses: [SRV_UV_INDEX],
  services: () => [new AnalogSensorServer(SRV_UV_INDEX, {
    readingValues: [5],
    streamingInterval: 1000
  })]
}, {
  name: "vibration motor",
  serviceClasses: [SRV_VIBRATION_MOTOR],
  services: () => [new VibrationMotorServer()]
}, {
  name: "water level",
  serviceClasses: [SRV_WATER_LEVEL],
  services: () => [new AnalogSensorServer(SRV_WATER_LEVEL, {
    readingValues: [0.5],
    streamingInterval: 1000
  })]
}, {
  name: "weight scale (jewelry)",
  serviceClasses: [SRV_WEIGHT_SCALE],
  services: () => [new AnalogSensorServer(SRV_WEIGHT_SCALE, {
    readingValues: [0.001],
    variant: exports.WeightScaleVariant.Jewelry,
    maxReading: 0.2,
    minReading: 0.0005,
    readingResolution: 0.00001
  })]
}, {
  name: "weight scale (body)",
  serviceClasses: [SRV_WEIGHT_SCALE],
  services: () => [new AnalogSensorServer(SRV_WEIGHT_SCALE, {
    readingValues: [60],
    variant: exports.WeightScaleVariant.Body,
    maxReading: 180,
    readingResolution: 0.1
  })]
}, {
  name: "weight scale (food)",
  serviceClasses: [SRV_WEIGHT_SCALE],
  services: () => [new AnalogSensorServer(SRV_WEIGHT_SCALE, {
    readingValues: [0.5],
    variant: exports.WeightScaleVariant.Food,
    maxReading: 6,
    readingResolution: 0.001
  })]
}, {
  name: "wind direction",
  serviceClasses: [SRV_WIND_DIRECTION],
  services: () => [new AnalogSensorServer(SRV_WIND_DIRECTION, windDirectionOptions)]
}, {
  name: "wind speed",
  serviceClasses: [SRV_WIND_SPEED],
  services: () => [new AnalogSensorServer(SRV_WIND_SPEED, windSpeedOptions)]
}, {
  name: "weather station (wind speed, direction, rain)",
  serviceClasses: [SRV_WIND_SPEED, SRV_WIND_DIRECTION, SRV_RAIN_GAUGE],
  services: () => [new AnalogSensorServer(SRV_WIND_SPEED, windSpeedOptions), new AnalogSensorServer(SRV_WIND_DIRECTION, windDirectionOptions), new RainGaugeServer()]
}, {
  name: "chassis (motor x 2 + sonar + light)",
  serviceClasses: [SRV_DISTANCE, SRV_LED_PIXEL, SRV_MOTOR],
  services: () => [new MotorServer("L"), new MotorServer("R"), new AnalogSensorServer(SRV_DISTANCE, sonarOptions), new LedPixelServer({
    numPixels: 5,
    variant: exports.LedPixelVariant.Stick,
    instanceName: "lights"
  })]
}, {
  name: "railway crossing (2 x lights, 2 x servos, 1 x buffer)",
  serviceClasses: [SRV_TRAFFIC_LIGHT, SRV_SERVO, SRV_BUZZER],
  services: () => [new TrafficLightServer({
    instanceName: "left light"
  }), new ServoServer({
    minAngle: 0,
    maxAngle: 90,
    instanceName: "left arm"
  }), new TrafficLightServer({
    instanceName: "right light"
  }), new ServoServer({
    minAngle: 0,
    maxAngle: 90,
    instanceName: "right arm"
  }), new BuzzerServer({
    instanceName: "bell"
  })]
}, {
  name: "Arcade controller (6 x buttons)",
  serviceClasses: [SRV_BUTTON],
  services: () => [new ButtonServer("Left"), new ButtonServer("Up"), new ButtonServer("Right"), new ButtonServer("Down"), new ButtonServer("A"), new ButtonServer("B")]
}, {
  name: "micro:bit v2",
  serviceClasses: [SRV_DOT_MATRIX, SRV_BUTTON, SRV_ACCELEROMETER, SRV_SOUND_LEVEL, SRV_LIGHT_LEVEL, SRV_BUZZER, SRV_SOUND_PLAYER],
  services: () => [new DotMatrixServer(5, 5), new ButtonServer("A"), new ButtonServer("B"), new SensorServer(SRV_ACCELEROMETER, {
    readingValues: [0.5, 0.5, -(1 - (0.5 * 0.5 + 0.5 * 0.5))]
  }), new AnalogSensorServer(SRV_SOUND_LEVEL, soundLevel), new SensorServer(SRV_LIGHT_LEVEL, {
    readingValues: [0.5],
    variant: exports.LightLevelVariant.LEDMatrix
  }), new BuzzerServer(), new SoundPlayerServer(microbitSounds)]
}, {
  name: "power + humidity",
  serviceClasses: [SRV_POWER, SRV_HUMIDITY],
  services: () => [new PowerServer(), new AnalogSensorServer(SRV_HUMIDITY, outdoorHumidityOptions)],
  factory: services => {
    const dev = new JDServerServiceProvider("power+humidity", [services[0]]);
    const pwr = dev.service(1);
    pwr.enabled.on(CHANGE, () => {
      const enabled = !!pwr.enabled.values()[0];
      console.log(`power: ${enabled ? "on" : "off"}`);
      if (enabled) // power + rest
        dev.updateServices(services); // power only
      else dev.updateServices([services[0]]);
    });
    return dev;
  }
}, {
  name: "HID keyboard",
  serviceClasses: [SRV_HID_KEYBOARD],
  services: () => [new HIDKeyboardServer()]
}, {
  name: "HID mouse",
  serviceClasses: [SRV_HID_MOUSE],
  services: () => [new HIDMouseServer()]
},
/*
{
    name: "Azure IoT Hub",
    serviceClasses: [SRV_AZURE_IOT_HUB],
    services: () => [new AzureIoTHubServer()],
},
*/
{
  name: "WiFi (virtual)",
  serviceClasses: [SRV_WIFI],
  services: () => [new WifiServer()]
}, {
  name: "Azure IoT Hub Health",
  serviceClasses: [SRV_AZURE_IOT_HUB_HEALTH],
  services: () => [new AzureIoTHubHealthServer()]
}];

function stableSimulatorDeviceId(bus, template) {
  const others = bus.serviceProviders().filter(sp => sp.template === template);
  const word0 = hash(stringToUint8Array(template + others.length), 32);
  const word1 = hash(stringToUint8Array(template + others.length + 1), 32);
  const id = toFullHex([word0, word1]);
  return id.slice(2);
}
/**
 * Instantiates a new service provider instance and adds it to the bus
 * @category Servers
 */


function addServiceProvider(bus, definition) {
  var _a;

  const services = definition.services();
  services.forEach(srv => srv.lock());
  const deviceId = stableSimulatorDeviceId(bus, definition.name);
  const options = {
    resetIn: definition.resetIn,
    deviceId
  };
  const d = ((_a = definition.factory) === null || _a === void 0 ? void 0 : _a.call(definition, services)) || new JDServerServiceProvider(definition.name, services, options);
  bus.addServiceProvider(d);
  return d;
}
/**
 * Finds the first service provider that supports the given service class
 * @category Servers
 */


function serviceProviderDefinitionFromServiceClass(serviceClass) {
  return _providerDefinitions.find(provider => provider.serviceClasses.length === 1 && provider.serviceClasses[0] === serviceClass);
}
/**
 * Starts a service provider that hosts the given service class.
 * @category Servers
 */


function startServiceProviderFromServiceClass(bus, serviceClass) {
  const provider = serviceProviderDefinitionFromServiceClass(serviceClass);
  return addServiceProvider(bus, provider);
}
/**
 * Base class for service clients
 * @category Clients
 */


class JDServiceClient extends JDClient {
  constructor(service) {
    super();
    this.service = service;
  }

  get device() {
    return this.service.device;
  }

  get bus() {
    return this.device.bus;
  }

  toString() {
    return `client of ${this.service}`;
  }

}
/**
 * A client for the role manager service
 * @category Clients
 */


class RoleManagerClient extends JDServiceClient {
  constructor(service) {
    super(service);
    this._roles = [];
    this._needRefresh = true;
    this._lastRefreshAttempt = 0;
    const changeEvent = service.event(exports.SystemEvent.Change); // always debounce refresh roles

    this.startRefreshRoles = debounceAsync(this.refreshRoles.bind(this), 200); // role manager emits change events

    this.mount(changeEvent.subscribe(EVENT, this.handleChange.bind(this))); // assign roles when need device enter the bus

    this.mount(this.bus.subscribe(DEVICE_ANNOUNCE, this.assignRoles.bind(this))); // unmount when device is removed

    this.mount(service.device.subscribe(DISCONNECT, () => {
      var _a;

      if (((_a = this.bus.roleManager) === null || _a === void 0 ? void 0 : _a.service) === this.service) this.bus.setRoleManagerService(undefined);
    })); // clear on unmount

    this.mount(this.clearRoles.bind(this)); // retry to get roles on every self-announce

    this.mount(this.bus.subscribe(SELF_ANNOUNCE, this.handleSelfAnnounce.bind(this)));
  }

  handleSelfAnnounce() {
    if (this._needRefresh && this.bus.timestamp - this._lastRefreshAttempt > ROLE_MANAGER_POLL) this.startRefreshRoles();
  }

  get roles() {
    return this._roles;
  }

  async handleChange() {
    this.startRefreshRoles();
  }

  async refreshRoles() {
    if (this.unmounted) return;
    this._needRefresh = false;
    await this.collectRoles();
    if (this.unmounted) return;
    this.assignRoles();
  }

  async collectRoles() {
    this._lastRefreshAttempt = this.bus.timestamp;
    const previousRolesHash = JSON.stringify(this._roles);

    try {
      const inp = new InPipeReader(this.bus);
      await this.service.sendPacketAsync(inp.openCommand(exports.RoleManagerCmd.ListRequiredRoles), true); // collect all roles

      const roles = [];

      for (const buf of await inp.readData(1000)) {
        const [devidbuf, serviceClass, serviceIndex, name] = jdunpack(buf, "b[8] u32 u8 s");
        const deviceId = toHex(devidbuf);
        const role = {
          deviceId,
          serviceClass,
          serviceIndex,
          name
        };
        roles.push(role);
      } // store result if changed


      if (JSON.stringify(roles) !== previousRolesHash) {
        this._roles = roles;
        this.emit(CHANGE);
      }
    } catch (e) {
      this._needRefresh = true;
      this.emit(ERROR, e);
    }
  }

  assignRoles() {
    this.bus.services().filter(srv => RoleManagerClient.unroledSrvs.indexOf(srv.serviceClass) < 0).forEach(srv => this.assignRole(srv));
  }

  assignRole(service) {
    const deviceId = service.device.deviceId;
    const serviceIndex = service.serviceIndex;

    const role = this._roles.find(r => r.deviceId === deviceId && r.serviceIndex === serviceIndex); //console.debug(`role ${service.id} -> ${role?.role}`, { service })


    service.role = role === null || role === void 0 ? void 0 : role.name;
  }

  clearRoles() {
    this.bus.services().forEach(srv => srv.role = undefined);
  }

  hasRoleForService(service) {
    var _a;

    const {
      serviceClass
    } = service;
    return !!((_a = this._roles) === null || _a === void 0 ? void 0 : _a.find(r => r.serviceClass === serviceClass));
  }

  compatibleRoles(service) {
    var _a;

    const {
      serviceClass
    } = service;
    return (_a = this._roles) === null || _a === void 0 ? void 0 : _a.filter(r => r.serviceClass === serviceClass);
  }

  role(name) {
    return this._roles.find(r => r.serviceIndex > 0 && r.name === name);
  }

  async setRole(service, name) {
    const {
      device,
      serviceIndex
    } = service;
    const {
      deviceId
    } = device; //console.debug(`set role ${deviceId}:${serviceIndex} to ${role}`)

    const previous = name && this._roles.find(r => r.name === name);

    if (previous && previous.deviceId === deviceId && previous.serviceIndex === serviceIndex) {
      // nothing todo
      console.debug(`role unmodified, skipping`);
      return;
    } // set new role assignment


    {
      const data = jdpack("b[8] u8 s", [fromHex(deviceId), serviceIndex, name || ""]);
      await this.service.sendPacketAsync(Packet.from(exports.RoleManagerCmd.SetRole, data), true);
    } // clear previous role assignment

    if (previous) {
      console.debug(`clear role ${previous.deviceId}:${previous.serviceIndex}`);
      const data = jdpack("b[8] u8 s", [fromHex(previous.deviceId), previous.serviceIndex, ""]);
      await this.service.sendPacketAsync(Packet.from(exports.RoleManagerCmd.SetRole, data), true);
    }
  }

  startSimulators() {
    var _a;

    if (!((_a = this._roles) === null || _a === void 0 ? void 0 : _a.length)) return; // collect roles that need to be bound

    const todos = groupBy(this._roles.filter(role => !this.bus.device(role.deviceId, true)).map(role => ({
      role,
      hostDefinition: serviceProviderDefinitionFromServiceClass(role.serviceClass)
    })).filter(todo => !!todo.hostDefinition), todo => parentName(todo.role.name) || ""); // spawn devices with group of devices

    Object.keys(todos).forEach(parent => {
      const todo = todos[parent]; // no parent, spawn individual services

      if (!parent) {
        todo.forEach(t => addServiceProvider(this.bus, t.hostDefinition));
      } else {
        // spawn all services into 1
        addServiceProvider(this.bus, {
          name: "",
          serviceClasses: [],
          services: () => arrayConcatMany(todo.map(t => t.hostDefinition.services()))
        });
      }
    });

    function parentName(role) {
      return role.split("/", 1)[0];
    }
  }

}

RoleManagerClient.unroledSrvs = [SRV_CONTROL, SRV_ROLE_MANAGER, SRV_LOGGER];
/**
 * A Jacdac bus manager. This instance maintains the list of devices on the bus.
 * @category JDOM
 */

class JDBus extends JDNode {
  /**
   * Creates the bus with the given transport
   * @param sendPacket
   * @category Lifecycle
   */
  constructor(transports, options) {
    super();
    this._transports = [];
    this._bridges = [];
    this._devices = [];
    this._lastPingLoggerTime = 0;
    this._lastResetInTime = 0;
    this._restartCounter = 0;
    this._minLoggerPriority = exports.LoggerPriority.Debug;
    this._gcDevicesFrozen = 0;
    this._serviceProviders = [];
    this._streaming = false;
    this._passive = false;
    this.selfDeviceId = (options === null || options === void 0 ? void 0 : options.deviceId) || randomDeviceId();
    this.scheduler = (options === null || options === void 0 ? void 0 : options.scheduler) || new WallClockScheduler();
    this.parentOrigin = (options === null || options === void 0 ? void 0 : options.parentOrigin) || "*";
    this.stats = new BusStatsMonitor(this); // some transport may be undefined

    transports === null || transports === void 0 ? void 0 : transports.filter(tr => !!tr).map(tr => this.addTransport(tr)); // tell loggers to send data, every now and then
    // send resetin packets

    this.on(SELF_ANNOUNCE, this.handleSelfAnnounce.bind(this)); // tell RTC clock the computer time

    this.on(DEVICE_ANNOUNCE, this.handleRealTimeClockSync.bind(this)); // grab the default role manager

    this.on(DEVICE_CHANGE, this.handleRoleManager.bind(this)); // start all timers

    this.start();
  }

  configureBroadcastChannel() {
    if (typeof BroadcastChannel === "undefined") return; // the purpose of this code is to orchestrate
    // interactions with multiple tabs and windows

    const channel = new BroadcastChannel("jacdac");

    const postConnectionState = () => {
      channel.postMessage({
        id: this.selfDevice.shortId,
        event: CONNECTION_STATE,
        transports: this._transports.map(tr => ({
          type: tr.type,
          connectionState: tr.connectionState
        }))
      });
    }; // update other windows with connection status


    const unsubConnectionState = this.subscribe(CONNECTION_STATE, postConnectionState);

    const handleVisibilityChange = () => {
      // tell other windows, we are visible or not
      channel.postMessage({
        id: this.selfDevice.shortId,
        event: "visibilitychange",
        visibilityState: document.visibilityState
      });
    };

    const handleBroadcastMessage = async msg => {
      const {
        data
      } = msg;
      const {
        event,
        transports,
        visibilityState
      } = data;

      switch (event) {
        case "visibilitychange":
          {
            // automatically disconnect if another pane becomes live
            //console.debug(
            //   `broadcast ${id}: ${event} ${visibilityState}`
            //)
            if (visibilityState === "visible") await this.disconnect();else {
              // let other window disconnect
              await this.delay(2000);
              await this.connect(true);
            }
            break;
          }

        case CONNECTION_STATE:
          {
            //console.debug(`broadcast ${id}: ${event}`, transports)
            // if any other window is trying to connect, disconnect
            transports.filter(tr => tr.connectionState === exports.ConnectionState.Connecting).forEach(ctr => {
              this.transports.filter(tr => tr.type === ctr.type).forEach(tr => tr.disconnect());
            });
          }
      }
    };

    channel.addEventListener("message", handleBroadcastMessage, false);
    document.addEventListener("visibilitychange", handleVisibilityChange);

    this._unsubscribeBroadcastChannel = () => {
      unsubConnectionState();
      document.removeEventListener("visibilitychange", handleVisibilityChange);
      channel.removeEventListener("message", handleBroadcastMessage);
      channel.close();
    }; // notify other pages


    handleVisibilityChange();
  }
  /**
   * Gets the list of transports registers with the bus
   * @category Transports and Bridges
   */


  get transports() {
    return this._transports.slice(0);
  }
  /**
   * Adds a transport to the bus
   * @category Transports and Bridges
   */


  addTransport(transport) {
    if (this._transports.indexOf(transport) > -1) return; // already added

    this._transports.push(transport);

    transport.bus = this;
    transport.bus.on(CONNECTING, () => this.preConnect(transport));
  }
  /**
   * Gets the list of bridges registered with the bus
   * @category Transports and Bridges
   */


  get bridges() {
    return this._bridges.slice(0);
  }
  /**
   * Add a bridge to the bus and returns a callback to remove it.
   * @param bridge
   * @returns callback to remove bridge
   * @category Transports and Bridges
   * @internal
   */


  addBridge(bridge) {
    if (this._bridges.indexOf(bridge) < 0) {
      console.debug(`add bridge`, {
        bridge
      });

      this._bridges.push(bridge);

      this.emit(CHANGE);
    }

    return () => this.removeBridge(bridge);
  }

  removeBridge(bridge) {
    const i = this._bridges.indexOf(bridge);

    if (i > -1) {
      console.debug(`remove bridge`, {
        bridge
      });

      this._bridges.splice(i, 1);

      this.emit(CHANGE);
    }
  }
  /**
   * Do not send any packet on the bus
   */


  get passive() {
    return this._passive;
  }

  set passive(value) {
    if (value !== this._passive) {
      this._passive = value;
      this.emit(CHANGE);
    }
  }

  preConnect(transport) {
    //console.debug(`preconnect ${transport.type}`, { transport })
    return Promise.all(this._transports.filter(t => t !== transport).map(t => t.disconnect()));
  }
  /**
   * Connects the bus going through the transports chronologically. Does nothing if already connected.
   * @param background connection was triggered automatically
   * @category Lifecycle
   */


  async connect(background) {
    if (this.connected) return;

    for (const transport of this._transports) {
      // start connection
      await transport.connect(background); // keep going if not connected

      if (transport.connected) break;
    }

    this.emit(CHANGE);
  }
  /**
   * Disconnects the bus and any connected transport.
   * @category Lifecycle
   */


  async disconnect() {
    for (const transport of this._transports) {
      await transport.disconnect();
    }

    this.emit(CHANGE);
  }
  /**
   * Starts to process packets and updates the JDOM nodes
   * @category Lifecycle
   */


  start() {
    this.configureBroadcastChannel();
    if (!this._announceInterval) this._announceInterval = this.scheduler.setInterval(() => {
      if (!this.passive) this.emit(SELF_ANNOUNCE);
    }, 499);
    this.backgroundRefreshRegisters = true;
    if (!this._gcInterval) this._gcInterval = this.scheduler.setInterval(() => this.gcDevices(), JD_DEVICE_DISCONNECTED_DELAY);
  }
  /**
   * Stops processing packets
   * @category Lifecycle
   */


  async stop() {
    await this.disconnect();

    if (this._unsubscribeBroadcastChannel) {
      this._unsubscribeBroadcastChannel();

      this._unsubscribeBroadcastChannel = undefined;
    }

    if (this._announceInterval) {
      this.scheduler.clearInterval(this._announceInterval);
      this._announceInterval = undefined;
    }

    this.safeBoot = false;
    this.backgroundRefreshRegisters = false;

    if (this._gcInterval) {
      this.scheduler.clearInterval(this._gcInterval);
      this._gcInterval = undefined;
    }
  }
  /**
   * Stops the bus and all transport connections.
   * @category Lifecycle
   */


  async dispose() {
    console.debug(`${this.id}: disposing.`);
    await this.stop();

    this._transports.forEach(transport => transport.dispose());
  }
  /**
   * Indicates that the bus is sending commands keep devices in bootloader mode.
   * This property is signaled by CHANGE.
   * @category Lifecycle
   */


  get safeBoot() {
    return !!this._safeBootInterval;
  }
  /**
   * Turn on or off the safe boot mode where the bus keeps devices in bootloader mode.
   * Triggers a CHANGE event.
   * @category Lifecycle
   */


  set safeBoot(enabled) {
    if (enabled && !this._safeBootInterval) {
      this._safeBootInterval = this.scheduler.setInterval(() => {
        // don't send message if any device is flashing
        if (this._devices.some(d => d.flashing)) return;
        sendStayInBootloaderCommand(this);
      }, 50);
      this.emit(CHANGE);
    } else if (!enabled && this._safeBootInterval) {
      this.scheduler.clearInterval(this._safeBootInterval);
      this._safeBootInterval = undefined;
      this.emit(CHANGE);
    }
  }
  /**
   * Indicates if any of the transports is connected.
   * Some transports might be in the process of connecting or disconnecting.
   * @category Lifecycle
   */


  get connected() {
    return this._transports.some(t => t.connected);
  }
  /**
   * Indicates if any of the transports is disconnected.
   * Some transports might be in the process of connecting or disconnecting.
   * @category Lifecycle
   */


  get disconnected() {
    return this._transports.every(t => t.disconnected);
  }
  /**
   * Clears known devices and service providers (simulators). Optionally reset bus timestamp.
   * @param timestamp
   * @category Services
   */


  clear(timestamp = 0) {
    var _a; // clear hosts


    if ((_a = this._serviceProviders) === null || _a === void 0 ? void 0 : _a.length) {
      this._serviceProviders.forEach(host => host.bus = undefined);

      this._serviceProviders = [];
    } // clear devices


    const devs = this._devices;

    if (devs === null || devs === void 0 ? void 0 : devs.length) {
      this._devices = [];
      devs.forEach(dev => {
        dev.disconnect();
        this.emit(DEVICE_DISCONNECT, dev);
        this.emit(DEVICE_CHANGE, dev);
      });
    }

    this.resetTime(timestamp);
  }
  /**
   * Gets a unique identifier for this node in the Jacdac DOM.
   * @category JDOM
   */


  get id() {
    return this.nodeKind;
  }
  /**
   * Gets the bus name
   * @category JDOM
   */


  get name() {
    return "bus";
  }
  /**
   * Gets the bus name
   * @category JDOM
   */


  get friendlyName() {
    return this.name;
  }
  /**
   * Gets the bus name
   * @category JDOM
   */


  get qualifiedName() {
    return this.name;
  }
  /**
   * Returns the ``BUS_NODE_NAME``
   * @category JDOM
   */


  get nodeKind() {
    return BUS_NODE_NAME;
  }
  /**
   * Gets the default role manager service client, if any
   * @category Services
   */


  get roleManager() {
    return this._roleManagerClient;
  }
  /**
   * Sets the default role manager service client
   * @category Services
   */


  setRoleManagerService(service) {
    var _a; //console.log(`set role manager`, { service })
    // clean if needed


    if (this._roleManagerClient && this._roleManagerClient.service !== service) {
      //console.debug("unmount role manager")
      this._roleManagerClient.unmount();

      this._roleManagerClient = undefined;
    } // allocate new manager


    if (service && service !== ((_a = this._roleManagerClient) === null || _a === void 0 ? void 0 : _a.service)) {
      //console.debug("mount role manager")
      this._roleManagerClient = new RoleManagerClient(service);
      this.emit(ROLE_MANAGER_CHANGE);
      this.emit(CHANGE);

      this._roleManagerClient.startRefreshRoles();
    }
  }
  /**
   * @internal
   */


  toString() {
    var _a, _b;

    return `bus: ${((_a = this._devices) === null || _a === void 0 ? void 0 : _a.length) || 0} devices, ${((_b = this._transports) === null || _b === void 0 ? void 0 : _b.filter(tr => tr.connected).map(tr => tr.type).join(", ")) || ""}`;
  }
  /**
   * Gets a detailled description of the devices and services connected to the bus
   * @returns
   */


  describe() {
    return `
transport:
${this._transports.map(tr => `  ${tr.type}: ${tr.connectionState}`).join("\n")}

${this.devices({
      ignoreInfrastructure: true
    }).map(dev => {
      var _a, _b;

      return `device: 
  id: ${dev.shortId} (0x${dev.deviceId})
  product: ${dev.productIdentifier ? `${((_a = deviceSpecificationFromProductIdentifier(dev.productIdentifier)) === null || _a === void 0 ? void 0 : _a.id) || "?"} (0x${(_b = dev.productIdentifier) === null || _b === void 0 ? void 0 : _b.toString(16)})` : ""}
  firmware_version: ${dev.firmwareVersion || ""}
  services:
${dev.services().slice(1).map(srv => {
        var _a;

        return [`    ${((_a = srv.specification) === null || _a === void 0 ? void 0 : _a.shortName) || srv.name} (0x${srv.serviceClass.toString(16)})`, ...srv.registers().filter(reg => !!reg.data).map(reg => {
          var _a;

          return `        ${((_a = reg.specification) === null || _a === void 0 ? void 0 : _a.kind) || "reg"} ${reg.name}: ${reg.humanValue} (${toHex(reg.data)})`;
        }), ...srv.events.map(ev => `        event ${ev.name}: ${ev.count}`)].join("\n");
      }).join("\n")}
`;
    }).join("\n")}`;
  }
  /**
   * Resolves a JDOM node from an identifier
   * @param id node identifier
   * @returns node if found, undefined otherwise
   * @category JDOM
   */


  node(id) {
    const resolve = () => {
      var _a, _b, _c, _d, _e, _f, _g, _h;

      const m = /^(?<type>bus|device|service|register|event|field)(:(?<dev>\w+)(:(?<srv>\w+)(:(?<reg>\w+(:(?<idx>\w+))?))?)?)?$/.exec(id);
      if (!m) return undefined;
      const type = m.groups["type"];
      const dev = m.groups["dev"];
      const srv = parseInt(m.groups["srv"], 16);
      const reg = parseInt(m.groups["reg"], 16);
      const idx = parseInt(m.groups["idx"], 16); //console.log(type, this.device(dev), this.device(dev)?.service(srv), this.device(dev)?.service(srv)?.register(reg), idx)

      switch (type) {
        case BUS_NODE_NAME:
          return this;

        case DEVICE_NODE_NAME:
          return this.device(dev, true);

        case SERVICE_NODE_NAME:
          return (_a = this.device(dev, true)) === null || _a === void 0 ? void 0 : _a.service(srv);

        case REGISTER_NODE_NAME:
          return (_c = (_b = this.device(dev, true)) === null || _b === void 0 ? void 0 : _b.service(srv)) === null || _c === void 0 ? void 0 : _c.register(reg);

        case EVENT_NODE_NAME:
          return (_e = (_d = this.device(dev, true)) === null || _d === void 0 ? void 0 : _d.service(srv)) === null || _e === void 0 ? void 0 : _e.event(reg);

        case FIELD_NODE_NAME:
          return (_h = (_g = (_f = this.device(dev, true)) === null || _f === void 0 ? void 0 : _f.service(srv)) === null || _g === void 0 ? void 0 : _g.register(reg)) === null || _h === void 0 ? void 0 : _h.fields[idx];
      }

      console.info(`node ${id} not found`);
      return undefined;
    };

    const node = resolve();
    return node;
  }

  resetTime(delta = 0) {
    this.scheduler.resetTime(delta);
    this.emit(CHANGE);
  }
  /**
   * Gets the current bus-relavite time in milliseconds
   * @category Scheduling
   */


  get timestamp() {
    return this.scheduler.timestamp;
  }
  /**
   * Indicates if the bus should force all sensors to stream
   */


  get streaming() {
    return this._streaming;
  }
  /**
   * Sets automatic streaming on and off
   */


  set streaming(value) {
    this._streaming = value;
  }
  /**
   * Creates a promise that awaits for the given duration using the bus scheduler
   * @category Scheduling
   */


  delay(millis, value) {
    return new Promise(resolve => this.scheduler.setTimeout(() => resolve(value), millis));
  }
  /**
   * Gets the current desired minimum logger verbosity on the bus
   * @category Diagnostics
   */


  get minLoggerPriority() {
    return this._minLoggerPriority;
  }
  /**
   * Sets the current desired minimum logger verbosity on the bus
   * @category Diagnostics
   */


  set minLoggerPriority(priority) {
    if (priority !== this._minLoggerPriority) {
      this._minLoggerPriority = priority;
      this.emit(CHANGE);
    }
  }
  /**
   * Returns undefined
   * @category JDOM
   */


  get parent() {
    return undefined;
  }

  async handleRealTimeClockSync(device) {
    // tell time to the RTC clocks
    if (device.hasService(SRV_REAL_TIME_CLOCK)) await RealTimeClockServer.syncTime(this);
  }

  handleRoleManager() {
    if (this.roleManager) return;
    const service = this.services({
      serviceClass: SRV_ROLE_MANAGER
    })[0];
    this.setRoleManagerService(service);
  }
  /**
   * Sends a packet to the bus
   * @param packet packet to send
   * @internal
   */


  async sendPacketAsync(packet) {
    packet.timestamp = this.timestamp;
    if (Flags.trace) packet.meta[META_TRACE] = stack(); // special debug mode to avoid dashboard interfere with packets
    // will generate fails for acks

    if (this.passive) return;
    this.emit(PACKET_SEND, packet);
    await Promise.all(this._transports.map(transport => transport.sendPacketAsync(packet)));
  }
  /**
   * Gets the list of known firmware blobs
   * @category Firmware
   */


  get firmwareBlobs() {
    return this._firmwareBlobs;
  }
  /**
   * Sets the list of known firmware blobs
   * @category Firmware
   */


  set firmwareBlobs(blobs) {
    this._firmwareBlobs = blobs;
    this.emit(FIRMWARE_BLOBS_CHANGE);
    this.emit(CHANGE);
  }
  /**
   * Gets the current list of known devices on the bus
   * @category Services
   */


  devices(options) {
    if ((options === null || options === void 0 ? void 0 : options.serviceName) && (options === null || options === void 0 ? void 0 : options.serviceClass) > -1) throw Error("serviceClass and serviceName cannot be used together");
    const sc = (options === null || options === void 0 ? void 0 : options.serviceClass) > -1 ? options === null || options === void 0 ? void 0 : options.serviceClass : serviceClass(options === null || options === void 0 ? void 0 : options.serviceName);

    let r = this._devices.slice(0);

    if (sc > -1) r = r.filter(s => s.hasService(sc));
    if (options === null || options === void 0 ? void 0 : options.ignoreInfrastructure) r = r.filter(s => s.deviceId !== this.selfDeviceId && s.serviceClasses.indexOf(SRV_INFRASTRUCTURE) < 0);
    if (options === null || options === void 0 ? void 0 : options.announced) r = r.filter(s => s.announced);
    if (options === null || options === void 0 ? void 0 : options.ignoreSimulators) r = r.filter(r => !this.findServiceProvider(r.deviceId));
    if (options === null || options === void 0 ? void 0 : options.productIdentifier) r = r.filter(r => !!r.productIdentifier);
    if (options === null || options === void 0 ? void 0 : options.physical) r = r.filter(r => !!r.isPhysical);
    return r;
  }
  /**
   * Gets the current list of service providers on the bus
   * @category Services
   */


  serviceProviders() {
    return this._serviceProviders.slice(0);
  }
  /**
   * Get a service providers for a given device
   * @param deviceId
   * @category Services
   */


  findServiceProvider(deviceId) {
    return this._serviceProviders.find(d => d.deviceId === deviceId);
  }
  /**
   * Adds the service provider to the bus and returns the associated devoce
   * @param provider instance to add
   * @category Services
   */


  addServiceProvider(provider) {
    if (provider && this._serviceProviders.indexOf(provider) < 0) {
      this._serviceProviders.push(provider);

      provider.bus = this;
      this.emit(SERVICE_PROVIDER_ADDED, provider);
      this.emit(CHANGE);
    }

    return this.device(provider.deviceId);
  }
  /**
   * Removes the service provider from the bus
   * @param provider instance to remove
   * @category Services
   */


  removeServiceProvider(provider) {
    if (!provider) return;

    const i = this._serviceProviders.indexOf(provider);

    if (i > -1) {
      this.removeDevice(provider.deviceId); // remove host

      this._serviceProviders.splice(i, 1);

      provider.bus = undefined;
      this.emit(SERVICE_PROVIDER_REMOVED, provider); // removed host

      this.emit(CHANGE);
    }
  }
  /**
   * Remove a device client by identifier
   * @param deviceId
   * @category Devices
   */


  removeDevice(deviceId) {
    // remove device as well
    const devi = this._devices.findIndex(d => d.deviceId === deviceId);

    if (devi > -1) {
      const dev = this._devices[devi];

      this._devices.splice(devi, 1);

      dev.disconnect();
      this.emit(DEVICE_DISCONNECT, dev);
      this.emit(DEVICE_CHANGE, dev);
    }
  }
  /**
   * Gets the list of devices
   * @category JDOM
   */


  get children() {
    return this.devices();
  }
  /**
   * Gets the current list of services from all the known devices on the bus
   * @category Services
   */


  services(options) {
    return arrayConcatMany(this.devices(options).map(d => d.services(options)));
  }
  /**
   * Gets a device on the bus
   * @param id device identifier to query
   * @param skipCreate do not create new device if missing
   * @param pkt packet that generated this device query
   * @category Services
   */


  device(id, skipCreate, pkt) {
    if (id === "0000000000000000" && !skipCreate) {
      console.warn("jadac: trying to access device 0000000000000000");
      return undefined;
    }

    let d = this._devices.find(d => d.deviceId == id);

    if (!d && !skipCreate) {
      if (this.devicesFrozen) {
        console.debug(`info`, `devices frozen, dropping ${id}`);
        return undefined;
      }

      d = new JDDevice(this, id, pkt);

      this._devices.push(d);

      console.debug(`${id === this.selfDeviceId ? "self" : "new"} device ${d.shortId} (${id})`); // stable sort

      this._devices.sort((l, r) => strcmp(l.deviceId, r.deviceId));

      this.emit(DEVICE_CONNECT, d);
      this.emit(DEVICE_CHANGE, d);
      this.emit(CHANGE);
    }

    return d;
  }
  /**
   * Push a context to disable cleaning device that haven't issued packets recently.
   * @category Lifecycle
   */


  pushDeviceFrozen() {
    this._gcDevicesFrozen++;
  }
  /**
   * Pop a context to disable cleaning device that haven't issued packets recently.
   * @category Lifecycle
   */


  popDeviceFrozen() {
    this._gcDevicesFrozen = Math.max(0, this._gcDevicesFrozen - 1);
  }
  /**
   * Indicates if the device list if currently frozen.
   * @category Lifecycle
   */


  get devicesFrozen() {
    return this._gcDevicesFrozen > 0;
  }

  gcDevices() {
    this.emit(DEVICE_CLEAN);

    if (this.devicesFrozen) {
      console.debug("devices frozen");
      return;
    }

    const LOST_DELAY = JD_DEVICE_LOST_DELAY;
    const DISCONNECTED_DELAY = JD_DEVICE_DISCONNECTED_DELAY;
    const lostCutoff = this.timestamp - LOST_DELAY;
    const disconnectedCutoff = this.timestamp - DISCONNECTED_DELAY; // cycle through events and disconnect devices that are long gone

    for (let i = 0; i < this._devices.length; ++i) {
      const dev = this._devices[i];

      if (dev.lastSeen < disconnectedCutoff) {
        this._devices.splice(i, 1);

        i--;
        this.disconnectDevice(dev);
      } else if (dev.lastSeen < lostCutoff) {
        dev.lost = true;
      }
    }
  }

  disconnectDevice(dev) {
    dev.disconnect();
    this.emit(DEVICE_DISCONNECT, dev);
    this.emit(DEVICE_CHANGE, dev);
    this.emit(CHANGE);
  }
  /**
   * Ingests and process a packet received from the bus.
   * @param pkt a jacdac packet
   * @internal
   */


  processPacket(pkt) {
    if (!pkt.isMultiCommand && !pkt.device) {
      pkt.device = this.device(pkt.deviceIdentifier, false, pkt); // the device id is unknown dropping

      if (!pkt.device) {
        if (Flags.diagnostics) console.debug(`unknown pkt device ${pkt.deviceIdentifier}`, {
          pkt
        });
        return;
      }
    }

    this.emit(PACKET_PRE_PROCESS, pkt);
    let isAnnounce = false;
    if (!pkt.device) ;else if (pkt.isCommand) {
      if (pkt.deviceIdentifier == this.selfDeviceId) {
        if (pkt.requiresAck) {
          const ack = Packet.onlyHeader(pkt.crc);
          ack.serviceIndex = JD_SERVICE_INDEX_CRC_ACK;
          ack.deviceIdentifier = this.selfDeviceId;
          ack.sendReportAsync(this.selfDevice);
        }
      }

      pkt.device.processPacket(pkt);
    } else {
      pkt.device.lastSeen = pkt.timestamp;

      if (pkt.serviceIndex == JD_SERVICE_INDEX_CTRL) {
        if (pkt.serviceCommand == CMD_ADVERTISEMENT_DATA) {
          isAnnounce = true;
          pkt.device.processAnnouncement(pkt);
        } else if (pkt.isMultiCommand && pkt.serviceCommand == (CMD_SET_REG | exports.ControlReg.ResetIn)) {
          // someone else is doing reset in
          this._lastResetInTime = this.timestamp;
        }
      }

      pkt.device.processPacket(pkt);
    }
    this.emit(PACKET_PROCESS, pkt); // don't spam with duplicate advertisement events

    if (isAnnounce) {
      this.emit(PACKET_RECEIVE_ANNOUNCE, pkt);
    } else {
      this.emit(PACKET_RECEIVE, pkt);
      if (pkt.isEvent) this.emit(PACKET_EVENT, pkt);else if (pkt.isReport) this.emit(PACKET_REPORT, pkt);
    }
  }
  /**
   * Gets the virtual device created by this bus to handle pipes.
   * @category Services
   */


  get selfDevice() {
    return this.device(this.selfDeviceId);
  }

  handleSelfAnnounce() {
    return Promise.all([this.sendAnnounce(), this.sendResetIn(), this.sendPingLoggers()]).then(() => {});
  }

  async sendAnnounce() {
    // we do not support any services (at least yet)
    if (this._restartCounter < 0xf) this._restartCounter++;
    const pkt = Packet.jdpacked(CMD_ADVERTISEMENT_DATA, "u32 r: u32", [this._restartCounter | 0x100, [[SRV_INFRASTRUCTURE]]]);
    pkt.serviceIndex = JD_SERVICE_INDEX_CTRL;
    pkt.deviceIdentifier = this.selfDeviceId;
    await pkt.sendReportAsync(this.selfDevice);
  }

  get lastResetInTime() {
    return this._lastResetInTime;
  }

  async sendResetIn() {
    // don't send reset if already received
    // or no devices
    if (!this.devices({
      ignoreInfrastructure: true
    }).length) return;
    this._lastResetInTime = this.timestamp;
    const rst = Packet.jdpacked(CMD_SET_REG | exports.ControlReg.ResetIn, "u32", [RESET_IN_TIME_US]);
    await rst.sendAsMultiCommandAsync(this, SRV_CONTROL);
  }

  async sendStopStreaming() {
    console.debug(`bus: stop streaming`);
    const readingRegisters = this.services({
      announced: true,
      ignoreInfrastructure: true
    }).map(srv => srv.readingRegister && srv.register(exports.SensorReg.StreamingSamples)).filter(reg => !!reg);
    await Promise.all(readingRegisters.map(reg => reg.sendSetPackedAsync([0])));
  }

  async sendPingLoggers() {
    if (this._minLoggerPriority < exports.LoggerPriority.Silent && this.timestamp - this._lastPingLoggerTime > PING_LOGGERS_POLL && this.devices({
      ignoreInfrastructure: true,
      serviceClass: SRV_LOGGER
    }).length > 0) {
      this._lastPingLoggerTime = this.timestamp;
      const pkt = Packet.jdpacked(CMD_SET_REG | exports.LoggerReg.MinPriority, "u8", [this._minLoggerPriority]);
      await pkt.sendAsMultiCommandAsync(this, SRV_LOGGER);
    }
  }
  /**
   * Indicates if registers are automatically refreshed in the background.
   * @category Services
   */


  get backgroundRefreshRegisters() {
    return !!this._refreshRegistersInterval;
  }
  /**
   * Enables or disables automatically refreshing registers in the background.
   * @param enabled true to automatically refresh registers
   * @category Services
   */


  set backgroundRefreshRegisters(enabled) {
    if (!!enabled !== this.backgroundRefreshRegisters) {
      if (!enabled) {
        if (this._refreshRegistersInterval) this.scheduler.clearInterval(this._refreshRegistersInterval);
        this._refreshRegistersInterval = undefined;
      } else {
        this._refreshRegistersInterval = this.scheduler.setInterval(this.handleRefreshRegisters.bind(this), REFRESH_REGISTER_POLL);
      }
    }
  }
  /**
   * Cycles through all known registers and refreshes the once that have REPORT_UPDATE registered
   */


  handleRefreshRegisters() {
    const devices = this._devices.filter(device => device.announced && !device.lost); // don't try lost devices or devices flashing
    // skip if no devices or any device is currently flashing


    if (!devices.length || devices.some(dev => dev.flashing)) return; // no devices, we're done
    // collect registers

    const registers = arrayConcatMany(devices.map(device => arrayConcatMany(device.services({
      specification: true
    }).map(service => service.registers() // someone is listening for reports
    .filter(reg => // automatic streaming
    this._streaming && reg.code === exports.SystemReg.Reading || // listening for updates
    reg.listenerCount(REPORT_RECEIVE) > 0 || reg.listenerCount(REPORT_UPDATE) > 0) // ask if data is missing or non-const/status code
    .filter(reg => !reg.data || !(isConstRegister(reg.specification) || reg.code === exports.SystemReg.StatusCode || reg.code === exports.SystemReg.ReadingError)) // stop asking optional registers
    .filter(reg => {
      var _a;

      return !((_a = reg.specification) === null || _a === void 0 ? void 0 : _a.optional) || reg.lastGetAttempts < REGISTER_OPTIONAL_POLL_COUNT;
    }))))); // refresh values

    for (const register of registers) {
      const {
        service,
        specification
      } = register;
      const noDataYet = !register.data;
      const age = this.timestamp - register.lastGetTimestamp;
      const backoff = register.lastGetAttempts; // streaming register? use streaming sample

      if (isReading(specification) && isSensor(service.specification)) {
        // compute refresh interval
        const intervalRegister = service.register(exports.SensorReg.StreamingInterval);
        let interval = intervalRegister === null || intervalRegister === void 0 ? void 0 : intervalRegister.uintValue; // no interval data

        if (interval === undefined) {
          // use preferred interval data or default to 50
          const preferredIntervalRegister = service.register(exports.SensorReg.StreamingPreferredInterval);
          const preferredInterval = preferredIntervalRegister === null || preferredIntervalRegister === void 0 ? void 0 : preferredIntervalRegister.uintValue;
          interval = preferredInterval; // if no interval, poll interval value

          if (interval === undefined) {
            // all async
            if (intervalRegister && !intervalRegister.data && this.timestamp - intervalRegister.lastGetTimestamp > REGISTER_POLL_STREAMING_INTERVAL) intervalRegister.sendGetAsync();
            if (preferredIntervalRegister && !preferredIntervalRegister.data && this.timestamp - preferredIntervalRegister.lastGetTimestamp > REGISTER_POLL_STREAMING_INTERVAL) preferredIntervalRegister.sendGetAsync();
          }
        } // still no interval data use from spec or default


        if (interval === undefined) interval = specification.preferredInterval || STREAMING_DEFAULT_INTERVAL;
        const streamingSamplesRegister = service.register(exports.SensorReg.StreamingSamples);
        const streamingSamplesAge = this.timestamp - streamingSamplesRegister.lastSetTimestamp; // need to figure out when we asked for streaming

        const midSamplesAge = interval * 0xff >> 1; // compute if half aged

        if (streamingSamplesAge > midSamplesAge) {
          //console.debug({ samplesAge, midSamplesAge, interval })
          streamingSamplesRegister.sendSetPackedAsync([0xff]);
        } // first query, get data asap once per second


        if (noDataYet && age > 1000) register.sendGetAsync();
      } // regular register, ping if data is old
      else {
        const volatile = !!(specification === null || specification === void 0 ? void 0 : specification.volatile);
        const expiration = volatile ? Math.min(REGISTER_POLL_REPORT_VOLATILE_MAX_INTERVAL, REGISTER_POLL_REPORT_VOLATILE_INTERVAL * (1 << backoff)) : Math.min(REGISTER_POLL_REPORT_MAX_INTERVAL, (noDataYet ? REGISTER_POLL_FIRST_REPORT_INTERVAL : REGISTER_POLL_REPORT_INTERVAL) * (1 << backoff));

        if (age > expiration) {
          //console.log(`bus: poll ${register.id}`, register, age, backoff, expiration)
          register.sendGetAsync();
        }
      }
    } // apply streaming samples to service provider


    this._serviceProviders.map(host => host.emit(REFRESH));
  }
  /**
   * Runs a promise with a timeout. Returns undefined if timeout happens before of disconnection.
   * @param timeout duration to wait before declaring timeout
   * @param promise promise to wrap
   * @category Lifecycle
   */


  withTimeout(timeout, promise) {
    return new Promise((resolve, reject) => {
      let done = false;
      const tid = setTimeout(() => {
        if (!done) {
          done = true;

          if (!this._transports.some(tr => tr.connected)) {
            // the bus got disconnected so all operation will
            // time out going further
            this.emit(TIMEOUT_DISCONNECT);
            resolve(undefined);
          } else {
            // the command timed out
            this.emit(TIMEOUT);
            this.emit(ERROR, "Timeout (" + timeout + "ms)");
            resolve(undefined);
          }
        }
      }, timeout);
      promise.then(v => {
        if (!done) {
          done = true;
          clearTimeout(tid);
          resolve(v);
        } else {
          // we already gave up
          this.emit(LATE);
        }
      }, e => {
        if (!done) {
          done = true;
          clearTimeout(tid);
          reject(e);
        }
      });
    });
  }

}
/**
 * A player for packet traces.
 * @category Trace
 */


class TracePlayer extends JDClient {
  constructor(bus, speed = 1) {
    super();
    this.bus = bus;
    this.speed = speed;
    this._busStartTimestamp = 0;
    this._index = 0;
    this._lastProgressEmit = 0;
    this.tick = this.tick.bind(this); // always stop when unmounting

    this.mount(() => this.stop());
  }

  get running() {
    return !!this._interval;
  }

  get trace() {
    return this._trace;
  }

  set trace(t) {
    if (t !== this._trace) {
      this.stop();
      this._trace = t;
      this.emit(CHANGE);
    }
  }
  /**
   * Gets the adjusted timestamp
   */


  get elapsed() {
    return (this.bus.timestamp - this._busStartTimestamp) * this.speed;
  }

  get progress() {
    if (!this.trace) return 0;
    return Math.max(0, Math.min(1, this.elapsed / this.trace.duration));
  }

  get length() {
    var _a;

    return ((_a = this.trace) === null || _a === void 0 ? void 0 : _a.length) || 0;
  }

  start() {
    if (this._interval || !this._trace) return; // already running
    // this is the reference start time of this run

    this._busStartTimestamp = this.bus.timestamp;
    this._index = 0;
    this._interval = this.bus.scheduler.setInterval(this.tick, 50);
    this.emit(CHANGE);
    this.emitProgress(true);
  }

  stop() {
    if (this._interval) {
      this.bus.scheduler.clearInterval(this._interval);
      this._interval = undefined;
      this.emitProgress(true);
      this.emit(CHANGE);
    }
  }

  tick() {
    var _a;

    if (!this._trace) return;
    const busElapsed = this.elapsed;
    const packets = this.trace.packets;
    const packetStart = ((_a = packets[0]) === null || _a === void 0 ? void 0 : _a.timestamp) || 0;

    while (this._index < packets.length) {
      const packet = packets[this._index];
      const packetElapsed = packet.timestamp - packetStart;
      if (packetElapsed > busElapsed) break; // wait to catch up
      // clone packet and send

      const pkt = packet.clone();
      pkt.replay = true;
      pkt.timestamp = this._busStartTimestamp + packetElapsed;
      this.bus.processPacket(pkt);
      this._index++;
    } //console.log(`replay ${this._index} ${nframes} frames, ${npackets} packets`)


    this.emitProgress();
    if (this._index >= packets.length) this.stop();
  }

  emitProgress(force) {
    if (force || this.bus.timestamp - this._lastProgressEmit > 250) {
      this.emit(PROGRESS, this.progress);
      this._lastProgressEmit = this.bus.timestamp;
    }
  }

}
/**
 * Parse a trace text file
 * @param contents
 * @returns
 * @category Trace
 */


function parseTrace(contents) {
  const description = [];
  const packets = [];
  contents === null || contents === void 0 ? void 0 : contents.split(/\r?\n/).forEach(ln => {
    // parse data
    const m = /^(\d+.?\d*)\s+([a-f0-9]{12,})/i.exec(ln);

    if (!m) {
      // might be a stack trace
      if (/^\s+at\s/.test(ln)) {
        const lastPacket = packets[packets.length - 1];

        if (lastPacket) {
          let trace = lastPacket.meta[META_TRACE] || "";
          trace += ln + "\n";
          lastPacket.meta[META_TRACE] = trace;
        }
      } else {
        // probably junk data
        if (packets.length == 0) description.push(ln);
      }

      return;
    }

    const timestamp = parseInt(m[1]);
    const data = fromHex(m[2]); // add to array

    packets.push(Packet.fromBinary(data, timestamp));
  });
  if (packets.length) return new Trace(packets, {
    description: description.join("\n").trim()
  });else return undefined;
}
/**
 * Parses a logic analyzer log into a trace
 * @param logcontents
 * @returns
 * @category Trace
 */


function parseLogicLog(logcontents) {
  if (!logcontents) return undefined;
  const res = [];
  let frameBytes = [];
  let lastTime = 0;

  for (const ln of logcontents.split(/\r?\n/)) {
    let m = /^JD (\d+) ([0-9a-f]+)/i.exec(ln);

    if (m) {
      res.push({
        timestamp: parseInt(m[1]),
        data: fromHex(m[2])
      });
      continue;
    }
    /** Windows, logic 1.*
    Time [s],Value,Parity Error,Framing Error
    0.042909760000000,0x00,,Error
    0.042980320000000,0xD4,,
    0.042990240000000,0x81,,
    0.043000160000000,0x10,,
    0.043010240000000,0x00,,
    0.043020160000000,0xE8,,
    0.043030240000000,0xDF,,
    0.043040160000000,0xCB,,
    0.043050240000000,0xD1,,
    0.043060160000000,0x97,,
    0.043070240000000,0x34,,
    0.043080160000000,0x37,,
    0.043090240000000,0x48,,
    0.043100160000000,0x0C,,
    0.043110080000000,0x00,,
    0.043120160000000,0x00,,
    0.043130080000000,0x00,,
    0.043140160000000,0x00,,
    0.043150080000000,0x00,,
    0.043160160000000,0x00,,
    0.043170080000000,0x00,,
    0.043180160000000,0xCA,,
    0.043190080000000,0x1F,,
    0.043200160000000,0xDC,,
    0.043210080000000,0x12,,
    0.043220160000000,0x46,,
    0.043230080000000,0x47,,
    0.043240160000000,0x27,,
    0.043250080000000,0x1F,,
    0.043264800000000,0x00,,Error
    0.063968960000000,0x00,,Error
     */


    m = /^([\d.]+),(?:Async Serial,)?.*(0x[A-F0-9][A-F0-9])/.exec(ln);
    if (!m) continue;
    const tm = parseFloat(m[1]);

    if (lastTime && tm - lastTime > 0.1) {
      res.push({
        timestamp: lastTime * 1000,
        data: new Uint8Array(frameBytes),
        info: "timeout"
      });
      frameBytes = [];
      lastTime = 0;
    }

    lastTime = tm;

    if (/(framing error|Error)/.test(ln)) {
      if (frameBytes.length > 0) res.push({
        timestamp: lastTime * 1000,
        data: new Uint8Array(frameBytes)
      });
      frameBytes = [];
      lastTime = 0;
    } else {
      frameBytes.push(parseInt(m[2]));
    }
  }

  return res;
}
/**
 * Replays a parsed logic log
 * @param bus
 * @param frames
 * @param speed
 * @category Trace
 */


function replayLogicLog(bus, frames, speed) {
  const packets = arrayConcatMany(frames.map(frame => Packet.fromFrame(frame.data, frame.timestamp)));
  const player = new TracePlayer(bus, speed);
  player.trace = new Trace(packets);
  bus.clear(packets[0].timestamp);
  player.start();
}
/**
 * @internal
 */


async function packetSpeedTest(dev) {
  const pingCmd = CMD_GET_REG | exports.ControlReg.ProductIdentifier;
  dev.on(PACKET_REPORT, onPacket);
  const t0 = Date.now();
  let lastSend = Date.now();
  let numpkt = 0;
  let numrecv = 0;
  let done = false;
  await ask();

  while (numpkt < 100) {
    await delay(50);
    const now = Date.now();
    if (now - t0 > 3000) break;

    if (now - lastSend > 100) {
      await ask();
    }
  }

  done = true;
  await delay(250);
  dev.off(PACKET_REPORT, onPacket);
  const ms = Date.now() - t0;
  const pktsPerSecond = numpkt / (ms / 1000);
  const dropRate = 100 * (numpkt - numrecv) / numpkt;
  return {
    msg: `${pktsPerSecond.toFixed(1)} pkts/s; ${dropRate.toFixed(2)}% dropped`,
    pktsPerSecond,
    dropRate
  };

  async function ask() {
    lastSend = Date.now();
    numpkt++;
    await dev.sendCtrlCommand(pingCmd);
  }

  async function onPacket(p) {
    if (p.serviceIndex == JD_SERVICE_INDEX_CTRL && p.serviceCommand == pingCmd) {
      numrecv++;
      if (!done) await ask();
    }
  }
}
/**
 * @internal
 */


function packArguments(info, args) {
  let repeatIdx = -1;
  let numReps = 0;
  let argIdx = 0;
  let dst = 0;
  const buf = new Uint8Array(256);

  for (let i = 0; i < info.fields.length; ++argIdx, ++i) {
    if (argIdx >= args.length && numReps > 0) break;
    const arg0 = argIdx < args.length ? args[argIdx] : 0;
    const fld = info.fields[i];
    if (repeatIdx == -1 && fld.startRepeats) repeatIdx = i;
    const arg1 = fld.type == "string0" && typeof arg0 == "string" ? arg0 + "\u0000" : arg0;
    const arg = typeof arg1 == "boolean" ? arg1 ? 1 : 0 : typeof arg1 == "string" ? stringToUint8Array(toUTF8(arg1)) : arg1;

    if (typeof arg == "number") {
      const intVal = scaleFloatToInt(arg, fld);
      if (fld.storage == 0) throw new Error(`expecting ${fld.type} got number`);
      const fmt = numberFormatFromStorageType(fld.storage);
      setNumber(buf, fmt, dst, clampToStorage(intVal, fld.storage));
      dst += sizeOfNumberFormat(fmt);
    } else {
      let size = Math.abs(fld.storage);

      if (typeof arg1 == "string") {
        if (size == 0) size = arg.length;
        const argCut = arg.slice(0, size);
        buf.set(argCut, dst);
        dst += size;
      } else if (size == 0 || size == arg.length) {
        buf.set(arg, dst);
        dst += arg.length;
      } else {
        throw new Error(`expecting ${Math.abs(fld.storage)} bytes; got ${arg.length}`);
      }
    }

    if (dst >= JD_SERIAL_MAX_PAYLOAD_SIZE) throw new Error(`jacdac packet length too large, ${dst} > ${JD_SERIAL_MAX_PAYLOAD_SIZE} bytes`);

    if (repeatIdx != -1 && i + 1 >= info.fields.length) {
      i = repeatIdx - 1;
      numReps++;
    }
  }

  const cmd = isRegister(info) ? info.identifier | CMD_SET_REG : info.identifier;
  const pkt = Packet.from(cmd, buf.slice(0, dst));
  if (info.kind != "report") pkt.isCommand = true;
  return pkt;
}
/**
 * Given a filter text, compiles packet filter
 * @param bus
 * @param text
 * @returns
 * @category Trace
 */


function parsePacketFilter(bus, text) {
  if (!text) {
    return {
      source: text,
      props: {
        grouping: true
      },
      filter: () => true
    };
  }

  const flags = new Set();
  const serviceClasses = new Set();
  const pkts = new Set();
  const productIdentifiers = new Set();
  let repeatedAnnounce = undefined;
  let announce = undefined;
  let resetIn = undefined;
  let minPriority = undefined;
  let regGet = undefined;
  let regSet = undefined;
  let requiresAck = undefined;
  let log = undefined;
  let before = undefined;
  let after = undefined;
  const devices = {};
  let grouping = true;
  let pipes = undefined;
  let port = undefined;
  let collapseAck = true;
  let collapsePipes = true;
  let collapseGets = true;
  let errors = undefined;
  let selfDevice = undefined;
  text.split(/\s+/g).forEach(part => {
    var _a;

    const [, prefix,, value] = /([a-z\-_]+)([:=]([^\s]+))?/.exec(part) || [];

    switch (prefix || "") {
      case "kind":
      case "k":
        if (!value) break;
        flags.add(value.toLowerCase());
        break;

      case "service":
      case "srv":
        {
          if (!value) break;
          const service = serviceSpecificationFromName(value);
          const serviceClass = (service === null || service === void 0 ? void 0 : service.classIdentifier) || parseInt(value, 16);
          if (serviceClass !== undefined && !isNaN(serviceClass)) serviceClasses.add(serviceClass);
          break;
        }

      case "announce":
      case "a":
        announce = parseBoolean(value);
        break;

      case "repeated-announce":
      case "ra":
        repeatedAnnounce = parseBoolean(value);
        break;

      case "self":
        selfDevice = parseBoolean(value);
        break;

      case "reset-in":
      case "ri":
      case "resetin":
        resetIn = parseBoolean(value);
        break;

      case "errors":
        errors = parseBoolean(value);
        break;

      case "min-priority":
      case "minpri":
      case "minpriority":
      case "mi":
        minPriority = parseBoolean(value);
        break;

      case "requires-ack":
      case "ack":
        requiresAck = parseBoolean(value);
        break;

      case "collapse-ack":
        collapseAck = parseBoolean(value);
        break;

      case "device":
      case "dev":
      case "to":
      case "from":
        {
          if (!value) break; // resolve device by name

          const deviceId = (_a = bus.devices().find(d => d.shortId === value || d.name === value)) === null || _a === void 0 ? void 0 : _a.deviceId;

          if (deviceId) {
            const data = devices[deviceId] || (devices[deviceId] = {
              from: false,
              to: false
            });
            if (prefix === "from") data.from = true;else if (prefix === "to") data.to = true;
          }

          break;
        }

      case "pid":
      case "product-identifier":
        {
          if (!value) return; // find register

          const pid = parseInt(value.replace(/^0?x/, ""), 16);
          if (!isNaN(pid)) productIdentifiers.add(pid);
          break;
        }

      case "pkt":
      case "reg":
      case "register":
      case "cmd":
      case "command":
      case "ev":
      case "event":
        {
          if (!value) return; // find register

          const id = parseInt(value.replace(/^0?x/, ""), 16);
          if (!isNaN(id)) pkts.add(id.toString(16)); // support name

          pkts.add(value);
          break;
        }

      case "reg-get":
      case "get":
        regGet = parseBoolean(value);
        break;

      case "reg-set":
      case "set":
        regSet = parseBoolean(value);
        break;

      case "log":
        log = parseBoolean(value);
        break;

      case "before":
        before = parseTimestamp(value);
        break;

      case "after":
        after = parseTimestamp(value);
        break;

      case "grouping":
        grouping = parseBoolean(value);
        break;

      case "pipes":
        pipes = parseBoolean(value);
        break;

      case "collapse-pipe":
      case "collapse-pipes":
        collapsePipes = parseBoolean(value);
        break;

      case "collapse-get":
      case "collapse-gets":
        collapseGets = parseBoolean(value);
        break;

      case "port":
        port = parseInt(value);
        break;
    }
  });
  const props = {
    announce,
    repeatedAnnounce,
    resetIn,
    minPriority,
    requiresAck,
    collapseAck,
    log,
    productIdentifiers: !!productIdentifiers.size && Array.from(productIdentifiers.keys()),
    flags: !!flags.size && Array.from(flags.keys()),
    regGet,
    regSet,
    devices,
    selfDevice,
    serviceClasses: !!serviceClasses.size && Array.from(serviceClasses.keys()),
    pkts: !!pkts.size && Array.from(pkts.keys()),
    before,
    after,
    grouping,
    pipes,
    collapsePipes,
    collapseGets,
    port,
    errors
  };
  const filter = compileFilter(props);
  return {
    source: text,
    props,
    filter
  };

  function parseBoolean(value) {
    if (value === "false" || value === "no") return false;else if (value === "true" || value === "yes" || !value) return true;else return undefined;
  }

  function parseTimestamp(value) {
    const t = parseInt(value);
    return isNaN(t) ? undefined : t;
  }
}

function compileFilter(props) {
  const {
    announce,
    repeatedAnnounce,
    resetIn,
    minPriority,
    requiresAck,
    log,
    productIdentifiers,
    flags,
    regGet,
    regSet,
    devices,
    selfDevice,
    serviceClasses,
    pkts,
    before,
    after,
    pipes,
    port,
    errors
  } = props;
  const filters = [];
  if (before !== undefined) filters.push(pkt => pkt.timestamp <= before);
  if (after !== undefined) filters.push(pkt => pkt.timestamp >= after);
  if (announce !== undefined) filters.push(pkt => pkt.isAnnounce === announce);
  if (repeatedAnnounce !== undefined) filters.push(pkt => (!pkt.isAnnounce || pkt.isRepeatedAnnounce) === repeatedAnnounce);
  if (resetIn !== undefined) filters.push(pkt => !!(pkt.isRegisterSet && pkt.serviceClass === SRV_CONTROL && pkt.registerIdentifier === exports.ControlReg.ResetIn) === resetIn);
  if (minPriority !== undefined) filters.push(pkt => (pkt.isRegisterSet && pkt.serviceClass == SRV_LOGGER && pkt.registerIdentifier === exports.LoggerReg.MinPriority) === minPriority);
  if (requiresAck !== undefined) filters.push(pkt => pkt.requiresAck === requiresAck);
  if (flags) filters.push(pkt => hasAnyFlag(pkt));
  if (pipes !== undefined) filters.push(pkt => pkt.isPipe);
  if (port !== undefined) filters.push(pkt => pkt.pipePort === port);
  if (regGet !== undefined && regSet !== undefined) filters.push(pkt => pkt.isRegisterGet === regGet && pkt.isRegisterSet === regSet);else if (regGet !== undefined) filters.push(pkt => pkt.isRegisterGet === regGet);else if (regSet !== undefined) filters.push(pkt => pkt.isRegisterSet === regSet);
  if (log !== undefined) filters.push(pkt => (pkt.serviceClass === SRV_LOGGER && pkt.isReport) === log);

  if (selfDevice !== undefined) {
    filters.push(pkt => {
      const {
        device
      } = pkt;
      if (!device) return true;
      return device === device.bus.selfDevice === selfDevice;
    });
  }

  if (Object.keys(devices).length) filters.push(pkt => {
    if (!pkt.device) return false;
    const f = devices[pkt.device.deviceId];
    return !!f && (!f.from || !pkt.isCommand) && (!f.to || pkt.isCommand);
  });

  if (serviceClasses) {
    filters.push(pkt => serviceClasses.some(serviceClass => isInstanceOf(pkt.serviceClass, serviceClass)));
  }

  if (pkts) {
    filters.push(pkt => {
      var _a, _b;

      return pkts.indexOf((_a = pkt.decoded) === null || _a === void 0 ? void 0 : _a.info.identifier.toString(16)) > -1 || pkts.indexOf((_b = pkt.decoded) === null || _b === void 0 ? void 0 : _b.info.name) > -1;
    });
  }

  if (productIdentifiers) filters.push(pkt => {
    var _a;

    const fwid = (_a = pkt.device) === null || _a === void 0 ? void 0 : _a.productIdentifier;
    return fwid === undefined || productIdentifiers.indexOf(fwid) > -1;
  });
  if (errors !== undefined) filters.push(pkt => {
    var _a;

    return !!((_a = pkt.decoded) === null || _a === void 0 ? void 0 : _a.error) === errors;
  });

  const filter = pkt => filters.every(filter => filter(pkt));

  return filter;

  function hasAnyFlag(pkt) {
    var _a;

    const k = (_a = pkt.decoded) === null || _a === void 0 ? void 0 : _a.info.kind;
    return !!k && flags.indexOf(k) > -1;
  }
}

const RECORDING_TRACE_MAX_ITEMS = 100000;
/**
 * A recorder of packets to create traces.
 * @category Trace
 */

class TraceRecorder extends JDClient {
  constructor(bus) {
    super();
    this.bus = bus;
    this.maxRecordingLength = RECORDING_TRACE_MAX_ITEMS;
    this.handlePacket = this.handlePacket.bind(this);
    this.mount(() => {
      var _a;

      return (_a = this._subscription) === null || _a === void 0 ? void 0 : _a.call(this);
    });
  }

  start() {
    if (this.recording) return;
    this._subscription = this.bus.subscribe([PACKET_PROCESS, PACKET_SEND], this.handlePacket);
    this._trace = new Trace([], {
      maxLength: this.maxRecordingLength
    });
    this.emit(START);
    this.emit(CHANGE);
  }

  stop() {
    var _a;

    if (!this.recording) return;
    (_a = this._subscription) === null || _a === void 0 ? void 0 : _a.call(this);
    this._subscription = undefined;
    const t = this._trace;
    this._trace = undefined;
    this.emit(STOP);
    this.emit(CHANGE);
    return t;
  }

  get recording() {
    return !!this._trace;
  }

  get trace() {
    return this._trace;
  }

  handlePacket(pkt) {
    // record packets in traces
    this._trace.addPacket(pkt); // notify that this packet has been processed


    this.emit(PACKET_PROCESS, pkt);
  }

}

const TRACE_MAX_ITEMS = 1000;
const FILTERED_TRACE_MAX_ITEMS = 100;
const DUPLICATE_PACKET_MERGE_HORIZON_MAX_DISTANCE = 10;
const DUPLICATE_PACKET_MERGE_HORIZON_MAX_TIME = 5000;
/**
 * A filtered view over a packet trace
 * @category Trace
 */

class TraceView extends JDClient {
  constructor(bus, filter, throttleDelay = 200) {
    super();
    this.bus = bus;
    this.id = "v" + Math.random();
    this._maxFilteredLength = FILTERED_TRACE_MAX_ITEMS;
    this._paused = false;
    this._packetFilter = undefined;
    this._filteredPackets = [];
    this.silent = false;
    this._trace = new Trace([], {
      maxLength: TRACE_MAX_ITEMS
    });
    this.handlePacket = this.handlePacket.bind(this);
    this.handleFilterUpdate = this.handleFilterUpdate.bind(this);
    this.notifyPacketsChanged = throttle(() => {
      if (!this.silent) this.setFilteredPackets();
    }, throttleDelay);
    this.mount(this.bus.subscribe([PACKET_PROCESS, PACKET_SEND], this.handlePacket));
    this.mount(this.bus.subscribe(DEVICE_ANNOUNCE, this.handleFilterUpdate));
    this.filter = filter;
  }
  /**
   * No new packet is added to the filtered view
   */


  get paused() {
    return this._paused;
  }

  set paused(v) {
    if (v !== this._paused) {
      this._paused = v;

      if (!this._paused) {
        this.refreshFilter();
        this.emit(CHANGE);
      }
    }
  }

  get trace() {
    return this._trace;
  }

  set trace(t) {
    if (t !== this._trace) {
      this._trace = t;
      this.refreshFilter();
      this.emit(CHANGE);
    }
  }

  get filteredPackets() {
    return this._filteredPackets;
  }

  get filter() {
    return this._filter;
  }

  set filter(f) {
    if (f !== this._filter) {
      this._filter = f;
      this.refreshFilter();
      this.emit(CHANGE);
    }
  }

  get maxFilteredLength() {
    return this._maxFilteredLength;
  }

  set maxFilteredLength(v) {
    if (this._maxFilteredLength !== v) {
      this._maxFilteredLength = v;
      this.refreshFilter();
      this.emit(CHANGE);
    }
  }

  setFilteredPackets() {
    // always clone for React
    this._filteredPackets = this._filteredPackets.slice(0, this._filteredPackets.length > this.maxFilteredLength * 1.1 ? this.maxFilteredLength : this._filteredPackets.length);
    this.emit(CHANGE);
  }

  clear() {
    this.trace = new Trace([], {
      maxLength: TRACE_MAX_ITEMS
    });
    this._filteredPackets = [];
    this.setFilteredPackets();
    this.emit(CHANGE);
  }

  handleFilterUpdate() {
    this.refreshFilter();
  }

  refreshFilter() {
    var _a, _b;

    this.id = "view" + Math.random();
    this._packetFilter = parsePacketFilter(this.bus, this._filter);
    this._filteredPackets = [];
    const packets = this.trace.packets; // reapply filter to existing trace

    for (let i = packets.length - 1; i >= 0 && this._filteredPackets.length < this.maxFilteredLength; --i) {
      const pkt = packets[i];

      if ((_a = this._packetFilter) === null || _a === void 0 ? void 0 : _a.filter(pkt)) {
        this.addFilteredPacket(pkt);
      }
    }

    this._filteredPackets = this._filteredPackets.reverse();
    (_b = this.notifyPacketsChanged) === null || _b === void 0 ? void 0 : _b.call(this);
  }

  handlePacket(pkt) {
    var _a, _b;

    if (this._paused) return; // remember packet

    this.trace.addPacket(pkt); // add packet to live list

    if ((_a = this._packetFilter) === null || _a === void 0 ? void 0 : _a.filter(pkt)) {
      this.addFilteredPacket(pkt); // debounced notification of changes

      (_b = this.notifyPacketsChanged) === null || _b === void 0 ? void 0 : _b.call(this);
    }
  }

  addFilteredPacket(packet) {
    var _a, _b, _c, _d;

    if (packet.meta[this.id]) return;
    packet.meta[this.id] = true; // resolve packet device for pretty name

    if (!packet.isMultiCommand && !packet.device) packet.device = this.bus.device(packet.deviceIdentifier, false, packet); // keep in filtered view

    let filtered = true;
    const hash = toHex(packet.toBuffer());

    if ((_a = this._packetFilter) === null || _a === void 0 ? void 0 : _a.props.grouping) {
      const old = this._filteredPackets.slice(0, DUPLICATE_PACKET_MERGE_HORIZON_MAX_DISTANCE).find(p => packet.timestamp - p.packet.timestamp < DUPLICATE_PACKET_MERGE_HORIZON_MAX_TIME && p.hash === hash);

      if (old) {
        old.count++;
        filtered = false;
      }
    } // collapse acks


    if (packet.isCRCAck) {
      const pkts = this.trace.packets;
      const crc = packet.serviceCommand;
      const did = packet.deviceIdentifier;
      const m = Math.max(0, pkts.length - TRACE_FILTER_HORIZON); // max scan 100 packets back

      for (let i = pkts.length - 1; i >= m; i--) {
        const old = pkts[i];

        if (old.requiresAck && old.deviceIdentifier === did && old.crc === crc) {
          old.meta[META_ACK] = packet;
          if ((_b = this._packetFilter) === null || _b === void 0 ? void 0 : _b.props.collapseAck) filtered = false;
          break;
        }
      }
    } // report coming back


    if (packet.isRegisterGet && packet.isReport && !packet.meta[META_GET]) {
      const pkts = this.trace.packets;
      const did = packet.deviceIdentifier;
      const si = packet.serviceIndex;
      const rid = packet.registerIdentifier;
      const m = Math.max(0, pkts.length - TRACE_FILTER_HORIZON); // max scan 100 packets back

      for (let i = pkts.length - 1; i >= m; i--) {
        const old = pkts[i];

        if (old.isRegisterGet && old.isCommand && old.deviceIdentifier === did && old.serviceIndex === si && old.registerIdentifier === rid) {
          // response from a get command
          packet.meta[META_GET] = old;

          if ((_c = this._packetFilter) === null || _c === void 0 ? void 0 : _c.props.collapseGets) {
            // remove old
            this._filteredPackets.splice(i, 1); // keep new

          }

          break;
        }
      }
    } // collapse pipes


    if (((_d = this._packetFilter) === null || _d === void 0 ? void 0 : _d.props.collapsePipes) && packet.isPipe && packet.isCommand) {
      const pkts = this._filteredPackets;
      const m = Math.min(pkts.length, TRACE_FILTER_HORIZON); // max scan 100 packets back

      const port = packet.pipePort;
      const did = packet.deviceIdentifier;

      for (let i = 0; i < m; ++i) {
        const old = pkts[i].packet;

        if (old.deviceIdentifier === did && old.pipePort === port) {
          let pipePackets = old.meta[META_PIPE];
          if (!pipePackets) pipePackets = old.meta[META_PIPE] = [];
          pipePackets[packet.pipeCount] = packet;
          filtered = false;
          break;
        }
      }
    }

    if (filtered) {
      const key = packet.timestamp + hash;

      this._filteredPackets.unshift({
        key,
        hash,
        packet,
        count: 1
      });
    }
  }

}

function cmdCode(cmd) {
  switch (cmd) {
    case "setall":
      return LIGHT_PROG_SET_ALL;

    case "fade":
      return LIGHT_PROG_FADE;

    case "fadehsv":
      return LIGHT_PROG_FADE_HSV;

    case "rotfwd":
      return LIGHT_PROG_ROTATE_FWD;

    case "rotback":
      return LIGHT_PROG_ROTATE_BACK;

    case "show":
    case "wait":
      return LIGHT_PROG_SHOW;

    case "range":
      return LIGHT_PROG_RANGE;

    case "mode":
      return LIGHT_PROG_MODE;

    case "tmpmode":
      return LIGHT_PROG_MODE1;

    case "setone":
      return LIGHT_PROG_COL1_SET;

    case "mult":
      return 0x100;

    default:
      return undefined;
  }
}

function isWhiteSpace(code) {
  return code == 32 || code == 13 || code == 10 || code == 9;
}
/**
 * Encodes a light command into a buffer
 * @param format
 * @param args
 * @returns
 * @category Data Packing
 */


function lightEncode(format, args) {
  // tokens are white-space separated
  // % - number from args[]
  // # - color from args[]
  // #0123ff - color
  // 123 - number
  // commands: set, fade, fadehsv, rotfwd, rotback, pause
  // fadehsv 0 12 #00ffff #ffffff
  const outarr = [];
  let colors = [];
  let pos = 0;
  let currcmd = 0;

  function pushNumber(n) {
    if (n == null || (n | 0) != n || n < 0 || n >= 16383) throw new Error("number out of range: " + n);
    if (n < 128) outarr.push(n);else {
      outarr.push(0x80 | n >> 8);
      outarr.push(n & 0xff);
    }
  }

  function flush() {
    if (currcmd == 0xcf) {
      if (colors.length != 1) throw new Error("setone requires 1 color");
    } else {
      if (colors.length == 0) return;
      if (colors.length <= 3) outarr.push(0xc0 | colors.length);else {
        outarr.push(0xc0);
        outarr.push(colors.length);
      }
    }

    for (const c of colors) {
      outarr.push(c >> 16 & 0xff);
      outarr.push(c >> 8 & 0xff);
      outarr.push(c >> 0 & 0xff);
    }

    colors = [];
  }

  function nextToken() {
    while (isWhiteSpace(format.charCodeAt(pos))) pos++;

    const beg = pos;

    while (pos < format.length && !isWhiteSpace(format.charCodeAt(pos))) pos++;

    return format.slice(beg, pos);
  }

  while (pos < format.length) {
    const token = nextToken();
    const t0 = token.charCodeAt(0);

    if (97 <= t0 && t0 <= 122) {
      // a-z
      flush();
      currcmd = cmdCode(token);
      if (currcmd == undefined) throw new Error("unknown light command: " + token);

      if (currcmd == 0x100) {
        const f = parseFloat(nextToken());
        if (isNaN(f) || f < 0 || f > 2) throw new Error("expecting scale");
        outarr.push(0xd8); // tmpmode

        outarr.push(3); // mult

        outarr.push(0xd0); // setall

        const mm = Math.round(128 * f) & 0xff;
        outarr.push(0xc1);
        outarr.push(mm);
        outarr.push(mm);
        outarr.push(mm);
      } else {
        outarr.push(currcmd);
      }
    } else if (48 <= t0 && t0 <= 57) {
      // 0-9
      pushNumber(parseInt(token));
    } else if (t0 == 37) {
      // %
      if (args.length == 0) throw new Error("out of args, %");
      const v = args.shift();
      if (typeof v != "number") throw new Error("expecting number");
      pushNumber(v);
    } else if (t0 == 35) {
      // #
      if (token.length == 1) {
        if (args.length == 0) throw new Error("out of args, #");
        const v = args.shift();
        if (typeof v === "number") colors.push(v);else if (Array.isArray(v)) for (const vv of v) colors.push(vv);else throw Error("invalid number " + v);
      } else {
        if (token.length == 7) {
          const b = fromHex(token.slice(1));
          const c = b[0] << 16 | b[1] << 8 | b[2];
          colors.push(c);
        } else {
          throw new Error("invalid color: " + token);
        }
      }
    }
  }

  flush();
  return new Uint8Array(outarr);
}
/**
 * @internal
 */


function hsvToCss(hue, saturation, value, brightness, monochrome) {
  const csshue = hue * 360 / 0xff;
  const csssat = (monochrome ? 0xff : saturation) / 0xff;
  const cssval = value / 0xff;
  const [h, s, l] = hsv_to_hsl(csshue, csssat, cssval);
  const mixl = 0.3;
  const alpha = (mixl + (1 - mixl) * l) * brightness;
  return `hsla(${h}, ${s * 100}%, ${l * 100}%, ${alpha}`;
}

function hsv_to_hsl(h, s, v) {
  // both hsv and hsl values are in [0, 1]
  const l = (2 - s) * v / 2;

  if (l != 0) {
    if (l == 1) {
      s = 0;
    } else if (l < 0.5) {
      s = s * v / (l * 2);
    } else {
      s = s * v / (2 - l * 2);
    }
  }

  return [h, s, l];
}
/**
 * A client that bridges received and sent packets to a parent iframe.
 * @category JDOM
 */


class JDBridge extends JDClient {
  constructor() {
    super();
    this.bridgeId = `bridge-` + randomDeviceId();
    this.packetSent = 0;
    this.packetProcessed = 0;
    this.handleSendPacket = this.handleSendPacket.bind(this);
  }

  get bus() {
    return this._bus;
  }

  set bus(newBus) {
    if (newBus !== this._bus) {
      if (this._bus) this.unmount();
      this._bus = newBus;

      if (this._bus) {
        this.mount(this._bus.subscribe(PACKET_PROCESS, this.handleSendPacket));
        this.mount(this._bus.subscribe(PACKET_SEND, this.handleSendPacket));
        this.mount(this._bus.addBridge(this));
      }

      this.emit(CHANGE);
    }
  }
  /**
   * Receives frame data payload and injects it into the bus
   * @param data
   * @returns
   */


  receiveFrame(data) {
    if (!this._bus) return; // disconnected
    // try frame format (sent by hardware, hosts)

    const pkts = Packet.fromFrame(data, this.bus.timestamp);
    this.dispatchPackets(pkts);
  }
  /**
   * Receives packet data payload and injects it into the bus
   * @param data
   * @returns
   */


  receivePacket(data) {
    if (!this._bus) return; // disconnected
    // try as a single packet (send by the MakeCode simulator)

    const pkt = Packet.fromBinary(data, this.bus.timestamp);
    if (pkt) this.dispatchPackets([pkt]);
  }

  dispatchPackets(pkts) {
    // bail out if no packets
    if (!(pkts === null || pkts === void 0 ? void 0 : pkts.length)) return;
    this.packetProcessed += pkts.length;

    for (const pkt of pkts) {
      // tracing the source of packets to avoid self-resending
      pkt.sender = this.bridgeId; // send to native bus

      this.bus.sendPacketAsync(pkt); // send to javascript bus

      this.bus.processPacket(pkt);
    }
  }

  handleSendPacket(pkt) {
    if (!this._bus || pkt.sender === this.bridgeId) return;
    this.packetSent++;
    this.sendPacket(pkt.toBuffer());
  }

}
/**
 * A settings service client implementation.
 * @category Clients
 */


class SettingsClient extends JDServiceClient {
  constructor(service) {
    super(service);
    service.registersUseAcks = true;
  }

  async clear() {
    await this.service.sendCmdAsync(exports.SettingsCmd.Clear);
  }

  async listKeys() {
    const inp = new InPipeReader(this.bus);
    await this.service.sendPacketAsync(inp.openCommand(exports.SettingsCmd.ListKeys), true);
    const {
      output
    } = await inp.readAll();
    const keys = output.map(pkt => pkt.stringData);
    return keys.filter(k => !!k);
  }

  async list() {
    const inp = new InPipeReader(this.bus);
    await this.service.sendPacketAsync(inp.openCommand(exports.SettingsCmd.List), true);
    const {
      output
    } = await inp.readAll();
    return output.map(pkt => {
      const [key, value] = pkt.jdunpack("z b");
      return key && {
        key,
        value
      };
    }).filter(kv => !!kv);
  }

  async setValue(key, value) {
    key = key.trim();

    if (value === undefined) {
      await this.deleteValue(key);
    } else {
      const pkt = Packet.from(exports.SettingsCmd.Set, jdpack("z b", [key, value]));
      await this.service.sendPacketAsync(pkt);
      this.emit(CHANGE);
    }
  }

  async setStringValue(key, value) {
    await this.setValue(key, value ? stringToBuffer(value) : undefined);
  }

  async getValue(key) {
    if (!key) return undefined;
    key = key.trim();
    const pkt = Packet.from(exports.SettingsCmd.Get, jdpack("s", [key]));
    const resp = await this.service.sendCmdAwaitResponseAsync(pkt);
    const [rkey, value] = jdunpack(resp.data, "z b");

    if (key !== rkey) {
      console.error(`device returned different key, got "${rkey}", expected "${key}"`);
      return undefined;
    }

    return value;
  }

  async getStringValue(key) {
    const value = await this.getValue(key);
    return value && bufferToString(value);
  }

  async deleteValue(key) {
    if (!key) return;
    key = key.trim();
    const pkt = Packet.from(exports.SettingsCmd.Delete, jdpack("s", [key]));
    await this.service.sendPacketAsync(pkt);
    this.emit(CHANGE);
  }

}

const JD_BLE_FIRST_CHUNK_FLAG = 0x80;
/**
 * Indicates with Web Bluetooth transport are enabled
 * @category Transport
 */

function isWebBluetoothEnabled() {
  return !!Flags.webBluetooth;
}
/**
 * Indicates with Web Bluetooth is supported in this environment
 * @category Transport
 */


function isWebBluetoothSupported() {
  try {
    return typeof navigator !== "undefined" && !!navigator.bluetooth && !!navigator.bluetooth.requestDevice;
  } catch (e) {
    return false;
  }
}

function bleRequestDevice(options) {
  var _a, _b; // disabled


  if (!Flags.webBluetooth) return Promise.resolve(undefined);

  try {
    console.debug(`bluetooth request`, {
      options
    });
    return (_b = (_a = navigator === null || navigator === void 0 ? void 0 : navigator.bluetooth) === null || _a === void 0 ? void 0 : _a.requestDevice) === null || _b === void 0 ? void 0 : _b.call(_a, options);
  } catch (e) {
    if (Flags.diagnostics) console.warn(e);
    return undefined;
  }
}

function bleGetDevices() {
  var _a; // disabled


  if (!Flags.webBluetooth) return Promise.resolve([]);

  try {
    return ((_a = navigator === null || navigator === void 0 ? void 0 : navigator.bluetooth) === null || _a === void 0 ? void 0 : _a.getDevices()) || Promise.resolve([]);
  } catch (e) {
    if (Flags.diagnostics) console.warn(e);
    return Promise.resolve([]);
  }
}

class BluetoothTransport extends Transport {
  constructor() {
    super(BLUETOOTH_TRANSPORT, {
      checkPulse: true
    });
    this.handleDisconnected = this.handleDisconnected.bind(this);
    this.handleCharacteristicChanged = this.handleCharacteristicChanged.bind(this);
  }

  async transportConnectAsync(background) {
    var _a; // get a device


    if (background) {
      const devices = await bleGetDevices();
      this._device = devices === null || devices === void 0 ? void 0 : devices[0];
    } else {
      const device = await bleRequestDevice({
        filters: [{
          namePrefix: "BBC micro:bit"
        }],
        optionalServices: [BLUETOOTH_JACDAC_SERVICE]
      });
      this._device = device;
    }

    if (!((_a = this._device) === null || _a === void 0 ? void 0 : _a.gatt)) throw new Error("Device not found"); // listen for disconnection

    this._device.addEventListener("gattserverdisconnected", this.handleDisconnected, false); // connect to gatt


    this._server = await this._device.gatt.connect(); // connect to service

    this._service = await this._server.getPrimaryService(BLUETOOTH_JACDAC_SERVICE); // connect to characteristic

    this._rxCharacteristic = await this._service.getCharacteristic(BLUETOOTH_JACDAC_RX_CHARACTERISTIC);
    this._txCharacteristic = await this._service.getCharacteristic(BLUETOOTH_JACDAC_TX_CHARACTERISTIC); // listen for incoming packet

    this._rxCharacteristic.addEventListener("characteristicvaluechanged", this.handleCharacteristicChanged, false); // start listening


    await this._rxCharacteristic.startNotifications();
  }

  async transportSendPacketAsync(p) {
    if (!this._txCharacteristic) {
      console.debug(`trying to send Bluetooth packet while disconnected`);
      return;
    }

    const data = p.toBuffer();
    const length = data.length;
    const totalChunks = Math.ceil(data.length / 18);
    let remainingChunks = totalChunks == 0 ? 0 : totalChunks - 1;
    let sent = 0;

    while (sent < length) {
      const n = Math.min(18, length - sent);
      const chunk = data.slice(sent, sent + n);
      const header = new Uint8Array(2);
      header[0] = totalChunks & 0x7f;
      if (sent == 0) header[0] |= JD_BLE_FIRST_CHUNK_FLAG;
      header[1] = remainingChunks;

      this._txCharacteristic.writeValueWithoutResponse(bufferConcat(header, chunk));

      sent += n;
      remainingChunks = remainingChunks == 0 ? 0 : remainingChunks - 1;
      console.log(`chunk: ${chunk.toString()} [${remainingChunks} chunks remaining]`);
    }
  }

  async transportDisconnectAsync() {
    var _a, _b;

    if (!this._device) return;
    console.debug(`ble: disconnecting`);

    try {
      (_a = this._rxCharacteristic) === null || _a === void 0 ? void 0 : _a.removeEventListener("characteristicvaluechanged", this.handleCharacteristicChanged);
      (_b = this._device) === null || _b === void 0 ? void 0 : _b.removeEventListener("gattserverdisconnected", this.handleDisconnected);

      this._server.disconnect();
    } finally {
      this._rxCharacteristic = undefined;
      this._txCharacteristic = undefined;
      this._service = undefined;
      this._server = undefined;
      this._device = undefined;
      this._rxBuffer = undefined;
    }
  }

  handleDisconnected() {
    // start disconnecting
    this.disconnect();
  }

  handleCharacteristicChanged() {
    const data = new Uint8Array(this._rxCharacteristic.value.buffer);
    const packetData = data.slice(2);
    console.log(`received length ${data.length}`);

    if (data[0] & JD_BLE_FIRST_CHUNK_FLAG) {
      if (this._rxBuffer) console.error(`Dropped buffer. Chunks remaining: ${this._rxChunkCounter}`);
      this._rxBuffer = new Uint8Array();
      this._rxChunkCounter = data[0] & 0x7f;
      console.log(`Initial chunk counter: ${this._rxChunkCounter}`);
    }

    this._rxChunkCounter = this._rxChunkCounter == 0 ? 0 : this._rxChunkCounter - 1;
    console.log(`after modification chunk counter: ${this._rxChunkCounter}`);
    if (data[1] !== this._rxChunkCounter) console.error(`Data out of order. Expected chunk: ${this._rxChunkCounter} Got chunk: ${data[1]}`);else this._rxBuffer = bufferConcat(this._rxBuffer, packetData);

    if (this._rxChunkCounter == 0) {
      const pkt = Packet.fromBinary(this._rxBuffer, this.bus.timestamp);
      console.log(`processed packet ${pkt}`);
      pkt.sender = BLUETOOTH_TRANSPORT;
      this.bus.processPacket(pkt);
      this._rxBuffer = undefined;
      this._rxChunkCounter = 0;
    }
  }

}
/**
 * Creates a transport that uses Web Bluetooth
 * @category Transport
 */


function createBluetoothTransport() {
  return isWebBluetoothSupported() && new BluetoothTransport();
} // see https://github.com/microsoft/uf2/blob/main/hf2.md for full spec


const HF2_DEVICE_MAJOR = 42;
const HF2_CMD_BININFO = 0x0001; // no arguments

const HF2_MODE_BOOTLOADER = 0x01;
const HF2_MODE_USERSPACE = 0x02;
/*
struct HF2_BININFO_Result {
    uint32_t mode;
    uint32_t flash_page_size;
    uint32_t flash_num_pages;
    uint32_t max_message_size;
};
*/

const HF2_CMD_INFO = 0x0002; // no arguments
// results is utf8 character array

const HF2_CMD_RESET_INTO_APP = 0x0003; // no arguments, no result

const HF2_CMD_RESET_INTO_BOOTLOADER = 0x0004; // no arguments, no result

const HF2_CMD_START_FLASH = 0x0005; // no arguments, no result

const HF2_CMD_WRITE_FLASH_PAGE = 0x0006;
/*
struct HF2_WRITE_FLASH_PAGE_Command {
    uint32_t target_addr;
    uint32_t data[flash_page_size];
};
*/
// no result

const HF2_CMD_CHKSUM_PAGES = 0x0007;
/*
struct HF2_CHKSUM_PAGES_Command {
    uint32_t target_addr;
    uint32_t num_pages;
};
struct HF2_CHKSUM_PAGES_Result {
    uint16_t chksums[num_pages];
};
*/

const HF2_CMD_READ_WORDS = 0x0008;
/*
struct HF2_READ_WORDS_Command {
    uint32_t target_addr;
    uint32_t num_words;
};
struct HF2_READ_WORDS_Result {
    uint32_t words[num_words];
};
*/

const HF2_CMD_WRITE_WORDS = 0x0009;
/*
struct HF2_WRITE_WORDS_Command {
    uint32_t target_addr;
    uint32_t num_words;
    uint32_t words[num_words];
};
*/
// no result

const HF2_CMD_DMESG = 0x0010; // no arguments
// results is utf8 character array

const HF2_FLAG_SERIAL_OUT = 0x80;
const HF2_FLAG_SERIAL_ERR = 0xc0;
const HF2_FLAG_CMDPKT_LAST = 0x40;
const HF2_FLAG_CMDPKT_BODY = 0x00;
const HF2_FLAG_MASK = 0xc0;
const HF2_SIZE_MASK = 63;
const HF2_STATUS_OK = 0x00;
const HF2_STATUS_INVALID_CMD = 0x01;
const HF2_STATUS_EXEC_ERR = 0x02;
const HF2_STATUS_EVENT = 0x80; // the eventId is overlayed on the tag+status; the mask corresponds
// to the HF2_STATUS_EVENT above

const HF2_EV_MASK = 0x800000;
const HF2_CMD_JDS_CONFIG = 0x0020;
const HF2_CMD_JDS_SEND = 0x0021;
const HF2_EV_JDS_PACKET = 0x800020;

class HF2Proto {
  constructor(io) {
    this.io = io;
    this.eventHandlers = {};
    this.msgs = new PromiseBuffer();
    this.cmdSeq = Math.random() * 0xffff | 0;
    this.lock = new PromiseQueue();
    let frames = [];

    io.onData = buf => {
      const tp = buf[0] & HF2_FLAG_MASK;
      const len = buf[0] & 63; //console.log(`msg tp=${tp} len=${len}`)

      const frame = new Uint8Array(len);
      memcpy(frame, 0, buf, 1, len);

      if (tp & HF2_FLAG_SERIAL_OUT) {
        this.onSerial(frame, tp == HF2_FLAG_SERIAL_ERR);
        return;
      }

      frames.push(frame);

      if (tp == HF2_FLAG_CMDPKT_BODY) {
        return;
      } else {
        assert(tp == HF2_FLAG_CMDPKT_LAST);
        let total = 0;

        for (const f of frames) total += f.length;

        const r = new Uint8Array(total);
        let ptr = 0;

        for (const f of frames) {
          memcpy(r, ptr, f);
          ptr += f.length;
        }

        frames = [];

        if (r[2] & HF2_STATUS_EVENT) {
          // asynchronous event
          this.handleEvent(r);
        } else {
          this.msgs.push(r);
        }
      }
    };
  }

  error(m) {
    var _a;

    return (_a = this.io) === null || _a === void 0 ? void 0 : _a.error(m);
  }

  talkAsync(cmd, data) {
    if (!this.io) console.error("rogue hf2 instance");
    let len = 8;
    if (data) len += data.length;
    const pkt = new Uint8Array(len);
    const seq = ++this.cmdSeq & 0xffff;
    write32(pkt, 0, cmd);
    write16(pkt, 4, seq);
    write16(pkt, 6, 0);
    if (data) memcpy(pkt, 8, data, 0, data.length);
    let numSkipped = 0;

    const handleReturnAsync = () => this.msgs.shiftAsync(1000) // we wait up to a second
    .then(res => {
      if (read16(res, 0) != seq) {
        if (numSkipped < 3) {
          numSkipped++;
          this.io.log(`message out of sync, (${seq} vs ${read16(res, 0)}); will re-try`);
          return handleReturnAsync();
        }

        this.error("out of sync");
      }

      let info = "";
      if (res[3]) info = "; info=" + res[3];

      switch (res[2]) {
        case HF2_STATUS_OK:
          return res.slice(4);

        case HF2_STATUS_INVALID_CMD:
          this.error("invalid command" + info);
          break;

        case HF2_STATUS_EXEC_ERR:
          this.error("execution error" + info);
          break;

        default:
          this.error("error " + res[2] + info);
          break;
      }

      return null;
    }).catch(e => {
      console.debug(`HF2: ${e.message}; cmd=${cmd}`);
      this.error(e);
      return null;
    });

    return this.lock.enqueue("talk", () => this.sendMsgAsync(pkt).then(handleReturnAsync));
  }

  sendMsgAsync(buf, serial = 0) {
    // Util.assert(buf.length <= this.maxMsgSize)
    const frame = new Uint8Array(64);

    const loop = pos => {
      let len = buf.length - pos;
      if (len <= 0) return Promise.resolve();

      if (len > 63) {
        len = 63;
        frame[0] = HF2_FLAG_CMDPKT_BODY;
      } else {
        frame[0] = HF2_FLAG_CMDPKT_LAST;
      }

      if (serial) frame[0] = serial == 1 ? HF2_FLAG_SERIAL_OUT : HF2_FLAG_SERIAL_ERR;
      frame[0] |= len;

      for (let i = 0; i < len; ++i) frame[i + 1] = buf[pos + i];

      if (!this.io) return Promise.resolve();
      return this.io.sendPacketAsync(frame).then(() => loop(pos + len));
    };

    return loop(0);
  }

  onEvent(id, f) {
    assert(!!(id & HF2_EV_MASK));
    this.eventHandlers[id + ""] = f;
  }

  onJDMessage(f) {
    this.talkAsync(HF2_CMD_JDS_CONFIG, encodeU32LE([1]));
    this.onEvent(HF2_EV_JDS_PACKET, f);
  }

  sendJDMessageAsync(buf) {
    return this.talkAsync(HF2_CMD_JDS_SEND, buf).then(() => {});
  }

  handleEvent(buf) {
    const evid = read32(buf, 0);
    const f = this.eventHandlers[evid + ""];

    if (f) {
      f(buf.slice(4));
    } else {
      this.io.log("unhandled event: " + evid.toString(16)); // We can get these before we're ready to recv; this is fine.
      //if (evid === 0x800020) {
      //    this.io.onError(new Error("hf2 corrupted"))
      //}
    }
  }

  onSerial(data, iserr) {
    const msg = `hf2 serial: ${bufferToString(data)}`;
    if (iserr) console.warn(msg);else console.log(msg);
  }

  async postConnectAsync() {
    await this.checkMode();
    const buf = await this.talkAsync(HF2_CMD_INFO);
    this.io.log("Connected to: " + bufferToString(buf));
  }

  async checkMode() {
    // first check that we are not talking to a bootloader
    const info = await this.talkAsync(HF2_CMD_BININFO);
    const mode = read32(info, 0);
    this.io.log(`hf2 mode ${mode}`);

    if (mode == HF2_MODE_USERSPACE) {
      // all good
      this.io.log(`device in user-space mode`);
    } else if (mode == HF2_MODE_BOOTLOADER) {
      this.io.log(`device in bootloader mode, reseting into user-space mode`);
      await this.talkAsync(HF2_CMD_RESET_INTO_APP); // and fail

      throwError("Device in bootloader mode");
    } else {
      // unknown mdoe
      throwError("Unknown device operation mode");
    }
  }

  async disconnectAsync() {
    if (this.io) {
      const io = this.io;
      this.io = undefined;
      await io.disconnectAsync();
    }
  }

}

const MICROBIT_V2_VENDOR_ID = 3368;
const MICROBIT_V2_PRODUCT_ID = 516;

class CMSISProto {
  constructor(io) {
    this.io = io;
    this.q = new PromiseQueue();
    this.sendQ = [];
  }

  startRecvToLoop() {
    console.assert(!this._lastInterval);
    let last = this.recvTo; // do not use bus schedulere here

    this._lastInterval = setInterval(() => {
      if (!this.io) this.stopRecvToLoop();

      if (last && last == this.recvTo) {
        last();
      }

      last = this.recvTo;
    }, 200);
  }

  stopRecvToLoop() {
    if (this._lastInterval) {
      clearInterval(this._lastInterval);
      this._lastInterval = undefined;
    }
  }

  error(msg, code) {
    var _a;

    this.stopRecvToLoop();
    (_a = this.io) === null || _a === void 0 ? void 0 : _a.error(msg, code); // clear state

    this.xchgAddr = null;
  }

  onJDMessage(f) {
    this._onJDMsg = f;
  }

  sendJDMessageAsync(buf) {
    if (buf.length & 3) {
      const tmp = new Uint8Array(buf.length + 3 & ~3);
      tmp.set(buf);
      buf = tmp;
    }

    return new Promise(resolve => {
      this.sendQ.push({
        buf,
        cb: resolve
      });
    });
  }

  async disconnectAsync() {
    if (this.io) {
      console.debug(`micro:bit: disconnect proto`);
      this.stopRecvToLoop();

      this._onJDMsg = () => console.warn("rogue jd callback");

      const io = this.io;
      this.io = undefined;
      if (io) await io.disconnectAsync();
    }
  }

  recvAsync() {
    return new Promise((resolve, reject) => {
      // io may have been cleared
      if (!this.io) {
        reject(new Error("USB disconnected"));
        return;
      }

      this.io.recvPacketAsync().then(v => {
        const f = resolve;
        resolve = null;

        if (f) {
          this.recvTo = null;
          f(v);
        }
      }, err => {
        if (resolve) {
          resolve = null;
          this.recvTo = null;
          reject(err);
        }
      });

      this.recvTo = () => {
        if (resolve) {
          resolve = null;
          reject(new Error("CMSIS recv timeout"));
        }
      };
    });
  }

  talkAsync(cmds) {
    return this.q.enqueue("talk", async () => {
      if (!this.io) {
        this.error("micro:bit disconnected");
        return; // disconnected
      } //console.log("TALK", cmds)


      await this.io.sendPacketAsync(new Uint8Array(cmds));

      if (!this.io) {
        this.error("micro:bit disconnected");
        return; // disconnected
      }

      let response = await this.recvAsync();

      if (response[0] !== cmds[0]) {
        const msg = `Bad response for ${cmds[0]} -> ${response[0]}, try again`;
        console.debug(msg, {
          cmds,
          response
        });

        try {
          response = await this.recvAsync();
        } catch (e) {
          // throw the original error in case of timeout
          this.error(msg);
        }

        if (response[0] !== cmds[0]) this.error(msg);
      }

      return response;
    });
  }

  talkHexAsync(str) {
    return this.talkAsync(fromHex(str.replace(/ /g, "")));
  }

  decodeString(buf) {
    const len = buf[1];
    const ss = buf.slice(2, 2 + len);
    return uint8ArrayToString(ss);
  }

  dapDelay(micros) {
    const cmd = [0x09, 0, 0];
    if (micros > 0xffff) this.error("too large delay");
    write16(cmd, 1, micros);
    return this.talkAsync(cmd);
  }

  async setBaudRate() {
    const setBaud = [0x82, 0, 0, 0, 0];
    write32(setBaud, 1, 115200);
    await this.talkAsync(setBaud); // this reset the board on 0255
  }

  async xchgLoop() {
    let currSend;

    while (this.io) {
      const now = Date.now();

      if (Flags.diagnostics && this.lastXchg && now - this.lastXchg > 50) {
        console.warn("slow xchg: " + (now - this.lastXchg) + "ms");
      }

      this.lastXchg = now;
      let numev = 0;
      let inp = await this.readBytes(this.xchgAddr + 12, 256, true);

      if (inp[2]) {
        await this.writeWord(this.xchgAddr + 12, 0);
        await this.triggerIRQ();
        inp = inp.slice(0, inp[2] + 12);

        this._onJDMsg(inp);

        numev++;
      }

      let sendFree = false;

      if (currSend) {
        const send = await this.readBytes(this.xchgAddr + 12 + 256, 4);

        if (!send[2]) {
          currSend.cb();
          currSend = null;
          sendFree = true;
          numev++;
        }
      }

      if (!currSend && this.sendQ.length) {
        if (!sendFree) {
          const send = await this.readBytes(this.xchgAddr + 12 + 256, 4);
          if (!send[2]) sendFree = true;
        }

        if (sendFree) {
          currSend = this.sendQ.shift();
          const bbody = currSend.buf.slice(4);
          await this.writeWords(this.xchgAddr + 12 + 256 + 4, new Uint32Array(bbody.buffer));
          const bhead = currSend.buf.slice(0, 4);
          await this.writeWords(this.xchgAddr + 12 + 256, new Uint32Array(bhead.buffer));
          await this.triggerIRQ();
          this.lastSend = Date.now();
          numev++;
        } else {
          if (this.lastSend) {
            const d = Date.now() - this.lastSend;

            if (d > 50) {
              this.lastSend = 0;
              console.warn("failed to send packet fast enough");
            }
          }
        }
      }

      if (await this.readSerial()) numev++;
      if (numev == 0) await this.dapDelay(1000);
    }
  }

  async readSerial() {
    let buf = await this.talkAsync([0x83]);
    const len = buf[1];

    if (len) {
      buf = buf.slice(2, 2 + len);
      if (this.pendingSerial) buf = bufferConcat(this.pendingSerial, buf);
      let ptr = 0;
      let beg = 0;

      while (ptr < buf.length) {
        if (buf[ptr] == 10 || buf[ptr] == 13) {
          const line = buf.slice(beg, ptr);
          if (line.length) console.debug("microbit: " + fromUTF8(uint8ArrayToString(line)));
          beg = ptr + 1;
        }

        ptr++;
      }

      buf = buf.slice(beg);
      this.pendingSerial = buf.length ? buf : null;
      if (this.pendingSerial) this.lastPendingSerial = Date.now();
    } else if (this.pendingSerial) {
      const d = Date.now() - this.lastPendingSerial;

      if (d > 500) {
        const s = fromUTF8(uint8ArrayToString(this.pendingSerial));
        this.pendingSerial = null;
        console.log("SERIAL[TO]: " + s);
      }
    }

    return len;
  }

  async talkStringAsync(...cmds) {
    return this.talkAsync(cmds).then(buf => this.decodeString(buf));
  }

  async readDP(reg) {
    const nums = [0x05, 0, 1, 2 | reg, 0, 0, 0, 0];
    const buf = await this.talkAsync(nums);
    return read32(buf, 3);
  }

  async setupTAR(addr) {
    const nums = [5, 0, 2, 1, 0x52, 0, 0, 0x23, 5, 0, 0, 0, 0];
    write32(nums, 9, addr);
    await this.talkAsync(nums);
  }

  async writeWords(addr, data) {
    await this.setupTAR(addr);
    const MAX = 0xe;
    let ptr = 0;
    const reqHd = [6, 0, MAX, 0, 0xd];

    for (let i = 0; i < MAX * 4; ++i) reqHd.push(0);

    const req = new Uint8Array(reqHd);
    let overhang = 1;
    let ptrTX = 0;
    const count = data.length;
    const dataBytes = new Uint8Array(data.buffer);
    let lastCh = MAX; //console.log("WRITE", addr.toString(16), data)

    await this.q.enqueue("talk", async () => {
      while (ptr < count) {
        const ch = Math.min(count - ptrTX, MAX);

        if (ch) {
          req[2] = ch;
          req.set(dataBytes.slice(ptrTX * 4, (ptrTX + ch) * 4), 5);

          if (!this.io) {
            this.error("disconnected");
            return;
          }

          await this.io.sendPacketAsync(ch == MAX ? req : req.slice(0, 5 + 4 * ch));
          ptrTX += ch;
          lastCh = ch;
        }

        if (overhang-- > 0) continue;
        const buf = await this.recvAsync();
        if (buf[0] != req[0]) this.error(`bad response, ${buf[0]} != ${req[0]}`);
        if (buf[1] != MAX && buf[1] != lastCh) this.error(`bad response, ${buf[1]} != ${MAX} && ${buf[1]} != ${lastCh}`);
        ptr += buf[1];
      }
    });
  }

  async readBytes(addr, count, jdmode = false) {
    if (addr & 3 || count & 3) this.error("unaligned");
    const b = await this.readWords(addr, count >> 2, jdmode);
    return new Uint8Array(b.buffer);
  }

  async readWords(addr, count, jdmode = false) {
    await this.setupTAR(addr);
    const MAX = 0xe;
    const res = new Uint32Array(count);
    let ptr = 0;
    const req = new Uint8Array([6, 0, MAX, 0, 0xf]);
    let overhang = 1;
    let ptrTX = 0; // console.log("READ", addr.toString(16), count)

    let numPending = 0;
    await this.q.enqueue("talk", async () => {
      while (ptr < count || numPending) {
        const ch = Math.min(count - ptrTX, MAX);

        if (ch > 0) {
          req[2] = ch;
          numPending++;

          if (!this.io) {
            this.error("disconnected");
            return;
          }

          await this.io.sendPacketAsync(req);
          ptrTX += ch;
        }

        if (overhang-- > 0) continue;
        const buf = await this.recvAsync();
        numPending--;

        if (buf[0] != req[0]) {
          this.error("bad response");
          return;
        }

        const len = buf[1];
        const words = new Uint32Array(buf.slice(4, (1 + len) * 4).buffer);

        if (words.length != len) {
          this.error("bad response2");
          return;
        }

        res.set(words, ptr); // limit transfer, according to JD frame size

        if (jdmode && ptr == 0) {
          const frmsz = new Uint8Array(res.buffer)[2];
          const words = frmsz + 12 + 3 >> 2;
          if (count > words) count = words;
        }

        ptr += words.length;
      }
    });
    return res;
  }

  async findExchange() {
    const memStart = 536870912;
    const memStop = memStart + 128 * 1024;
    const checkSize = 1024;
    let p0 = 0x20006000;
    let p1 = 0x20006000 + checkSize;

    const check = async addr => {
      if (addr < memStart) return null;
      if (addr + checkSize > memStop) return null;
      const buf = await this.readWords(addr, checkSize >> 2);

      for (let i = 0; i < buf.length; ++i) {
        if (buf[i] == 0x786d444a && buf[i + 1] == 0xb0a6c0e9) return addr + (i << 2);
      }

      return 0;
    }; // eslint-disable-next-line no-constant-condition


    while (true) {
      const a0 = await check(p0);
      if (a0) return a0;
      const a1 = await check(p1);
      if (a1) return a1;
      if (a0 === null && a1 === null) return null;
      p0 -= checkSize;
      p1 += checkSize;
    }
  }

  async triggerIRQ() {
    const addr = 0xe000e200 + (this.irqn >> 5) * 4;
    const data = new Uint32Array([1 << (this.irqn & 31)]);
    await this.writeWords(addr, data);
  }

  writeWord(addr, val) {
    return this.writeWords(addr, new Uint32Array([val]));
  }

  async reset() {
    await this.writeWord(0xe000edfc, 0); // DEMCR

    await this.writeWord(0xe000ed0c, 0x05fa0000 | 1 << 2); // AIRCR
  }

  async postConnectAsync() {
    this.startRecvToLoop();
    const devid = await this.talkStringAsync(0x80);

    if (/^9902/.test(devid)) {
      this.error(`micro:bit v1 is not supported. sorry.`, ERROR_MICROBIT_V1);
      return;
    }

    if (!/^990[3456789]/.test(devid)) {
      this.error(`Invalid Vendor0 response: ` + devid, ERROR_MICROBIT_UNKNOWN);
      return;
    }

    this.io.log("DAPLink v" + (await this.talkStringAsync(0x00, 0x04)));
    await this.setBaudRate(); // this may reset the board

    const freq = [0x11, 0, 0, 0, 0];
    write32(freq, 1, 10000000);
    await this.talkAsync(freq);
    const inits = ["02 00", "04 00 64 00 00 00", // SWD switch
    "12 38 FF FF FF FF FF FF FF", "12 10 9E E7", "12 38 FF FF FF FF FF FF FF", "12 08 00", // read DPIDR
    "05 00 01 02 00 00 00 00", // clear errors
    "05 00 03 00 04 00 00 00 08 00 00 00 00 04 00 00 00 50"];

    for (const ini of inits) await this.talkHexAsync(ini);

    for (let i = 0; i < 100; ++i) {
      const st = await this.readDP(4);
      const mask = 1 << 29 | 1 << 31;
      if ((st & mask) == mask) break;
      await delay(20);
    }

    await this.reset();
    await delay(1000); // the actual minimum until mbbridge starts seems to be 700ms; give it some more time just in case

    const xchg = await this.findExchange();

    if (xchg === null) {
      this.error(`exchange address not found; add jacdac to your project`, ERROR_MICROBIT_JACDAC_MISSING);
      return;
    }

    this.xchgAddr = xchg;
    const info = await this.readBytes(xchg, 16);
    this.irqn = info[8];

    if (info[12 + 2] != 0xff) {
      this.error("invalid memory; try power-cycling the micro:bit", ERROR_MICROBIT_INVALID_MEMORY);
      return;
    } // clear initial lock


    await this.writeWord(xchg + 12, 0);
    this.io.log(`exchange address: 0x${xchg.toString(16)}; irqn=${this.irqn}`);
    /* async */

    this.xchgLoop().catch(e => {
      console.debug(e);
      this.error((e === null || e === void 0 ? void 0 : e.message) || "an error occured");
    });
  }

}
/**
 * Common Jacdac error type
 * @category Runtime
 */


class JDError extends Error {
  constructor(message, jacdacName) {
    super(message);
    this.jacdacName = jacdacName;
    this.name = JACDAC_ERROR;
  }

}
/**
 * Extract the Jacdac error code if any
 * @param e
 * @returns
 * @category Runtime
 */


function errorCode(e) {
  var _a;

  return e.name === JACDAC_ERROR ? (_a = e) === null || _a === void 0 ? void 0 : _a.jacdacName : undefined;
}

const USB_FILTERS = {
  filters: [{
    // hf2 devices (incl. arcade)
    classCode: 255,
    subclassCode: HF2_DEVICE_MAJOR
  }, {
    // micro:bit v2
    vendorId: MICROBIT_V2_VENDOR_ID,
    productId: MICROBIT_V2_PRODUCT_ID
  }]
};
const controlTransferGetReport = 0x01;
const controlTransferSetReport = 0x09;
const controlTransferOutReport = 0x200;
const controlTransferInReport = 0x100;

class USBIO {
  constructor(options) {
    this.options = options;
    this.readLoopStarted = false;
    this.ready = false;
    this.rawMode = false; // eslint-disable-next-line @typescript-eslint/no-unused-vars

    this.onData = v => {};

    this.onError = e => {
      console.warn(`usb error: ${errorCode(e) || ""} ${e ? e.stack : e}`);
    };
  } // eslint-disable-next-line @typescript-eslint/no-explicit-any


  log(msg, v) {
    if (Flags.diagnostics) {
      if (v != undefined) console.debug("usb: " + msg, v);else console.debug("usb: " + msg);
    }
  }

  mkProto() {
    return this.isMicrobit() ? new CMSISProto(this) : new HF2Proto(this);
  }

  clearDev() {
    if (this.dev) {
      this.dev = null;
      this.epIn = null;
      this.epOut = null;

      this.onData = () => console.warn("rogue hf2 onData");
    }
  }

  disconnectAsync() {
    this.ready = false;
    if (!this.dev) return Promise.resolve();
    console.debug("close device");
    return this.dev.close().catch(e => {
      // just ignore errors closing, most likely device just disconnected
      console.debug(e);
    }).then(() => {
      this.clearDev();
      return delay(500);
    });
  }

  recvPacketAsync() {
    if (!this.rawMode) this.error("rawMode required");
    return this.recvPacketCoreAsync();
  }

  recvPacketCoreAsync() {
    const final = res => {
      if (res.status != "ok") this.error("USB IN transfer failed");
      const arr = new Uint8Array(res.data.buffer);
      if (arr.length == 0) return this.recvPacketCoreAsync();
      return arr;
    };

    if (!this.dev) return Promise.reject(new Error("Disconnected"));

    if (!this.epIn) {
      return this.dev.controlTransferIn({
        requestType: "class",
        recipient: "interface",
        request: controlTransferGetReport,
        value: controlTransferInReport,
        index: this.iface.interfaceNumber
      }, 64).then(final);
    }

    return this.dev.transferIn(this.epIn.endpointNumber, 64).then(final);
  }

  error(msg, code) {
    const e = new JDError(`device ${this.dev ? this.dev.productName : "n/a"} (${msg})`, code);
    this.onError(e);
  }

  async readLoop() {
    if (this.rawMode || this.readLoopStarted) return;
    this.readLoopStarted = true;
    console.debug("start read loop"); // eslint-disable-next-line no-constant-condition

    while (true) {
      if (!this.ready) {
        break; //await delay(300)
        //continue
      }

      try {
        const buf = await this.recvPacketCoreAsync();

        if (buf[0]) {
          // we've got data; retry reading immedietly after processing it
          this.onData(buf);
        } else {
          // throttle down if no data coming
          await delay(5);
        }
      } catch (err) {
        if (this.dev) {
          this.onError(err);
          await this.disconnectAsync();
        }

        await delay(300);
      }
    }
  }

  sendPacketAsync(pkt) {
    if (!this.dev) return Promise.reject(new Error("Disconnected"));
    assert(pkt.length <= 64);

    if (!this.epOut) {
      return this.dev.controlTransferOut({
        requestType: "class",
        recipient: "interface",
        request: controlTransferSetReport,
        value: controlTransferOutReport,
        index: this.iface.interfaceNumber
      }, pkt).then(res => {
        if (res.status != "ok") this.error("USB CTRL OUT transfer failed");
      });
    }

    return this.dev.transferOut(this.epOut.endpointNumber, pkt).then(res => {
      if (res.status != "ok") this.error("USB OUT transfer failed");
    });
  }

  isMicrobit() {
    return this.dev && this.dev.productId == 516 && this.dev.vendorId == 3368;
  }

  checkDevice() {
    this.iface = undefined;
    this.altIface = undefined;
    if (!this.dev) return false;
    console.debug("connect device: " + this.dev.manufacturerName + " " + this.dev.productName); // resolve interfaces

    const subcl = this.isMicrobit() ? 0 : HF2_DEVICE_MAJOR;

    for (const iface of this.dev.configuration.interfaces) {
      const alt = iface.alternates[0];

      if (alt.interfaceClass == 0xff && alt.interfaceSubclass == subcl) {
        this.iface = iface;
        this.altIface = alt;
        break;
      }
    }

    if (this.isMicrobit()) this.rawMode = true;
    return !!this.iface;
  }

  async tryReconnectAsync(deviceId) {
    try {
      const devices = await this.options.getDevices(USB_FILTERS);
      this.dev = deviceId ? devices.find(dev => dev.serialNumber === deviceId) : devices[0];
    } catch (e) {
      console.log(e);
      this.dev = undefined;
    }
  }

  async requestDeviceAsync() {
    try {
      this.dev = await this.options.requestDevice(USB_FILTERS);
    } catch (e) {
      console.log(e);
      this.dev = undefined;
    }
  }

  async connectAsync(background, deviceId) {
    await this.tryReconnectAsync(deviceId);
    if (!this.dev && !background) await this.requestDeviceAsync(); // background call and no device, just give up for now

    if (!this.dev && background) throwError("device not paired", true); // let's connect

    await this.openDeviceAsync();
    const proto = this.mkProto();

    try {
      await proto.postConnectAsync();
    } catch (e) {
      console.debug(e);
      await proto.disconnectAsync();
      throw e;
    }

    return proto;
  }

  async openDeviceAsync() {
    if (!this.dev) throwError("device not found");
    if (!this.checkDevice()) throwError("device does not support HF2");
    await this.dev.open();
    await this.dev.selectConfiguration(1);

    if (this.altIface.endpoints.length) {
      this.epIn = this.altIface.endpoints.filter(e => e.direction == "in")[0];
      this.epOut = this.altIface.endpoints.filter(e => e.direction == "out")[0];
      assert(this.epIn.packetSize == 64);
      assert(this.epOut.packetSize == 64);
    }

    console.debug("claim interface");
    await this.dev.claimInterface(this.iface.interfaceNumber);
    console.debug("all connected");
    this.ready = true;
    /* no await */

    this.readLoop();
  }

}

const WEB_SERIAL_FILTERS = {
  filters: [{
    usbVendorId: 0x303a // espressif

  }]
};

class WebSerialIO {
  constructor() {
    this.readLoopStarted = false;
    this.ready = false; // eslint-disable-next-line @typescript-eslint/no-unused-vars

    this.onData = v => {};

    this.onError = e => {
      console.warn(`usb error: ${errorCode(e) || ""} ${e ? e.stack : e}`);
    };
  } // eslint-disable-next-line @typescript-eslint/no-explicit-any


  log(msg, v) {
    if (Flags.diagnostics) {
      if (v != undefined) console.debug("usb: " + msg, v);else console.debug("usb: " + msg);
    }
  }

  mkProto() {
    return new HF2Proto(this);
  }

  clearDev() {
    if (this.dev) {
      this.dev = null;

      this.onData = () => console.warn("rogue webserial hf2 onData");
    }
  }

  disconnectAsync() {
    this.ready = false;
    if (!this.dev) return Promise.resolve();
    console.debug("close device");
    return this.cancelStreams().catch(e => {
      // just ignore errors closing, most likely device just disconnected
      console.debug(e);
    }).then(() => {
      this.clearDev();
      return delay(500);
    });
  }

  devInfo() {
    if (!this.dev) return "n/a";

    const h = n => ("000" + n.toString(16)).slice(-4);

    const info = this.dev.getInfo();
    return h(info.usbVendorId) + ":" + h(info.usbProductId);
  }

  error(msg, code) {
    const e = new JDError(`serial device ${this.devInfo()} (${msg})`, code);
    this.onError(e);
  }

  async cancelStreams() {
    if (this.reader) try {
      await this.reader.cancel();
      this.reader.releaseLock(); // eslint-disable-next-line no-empty
    } catch (_a) {}

    try {
      this.writer.releaseLock(); // eslint-disable-next-line no-empty
    } catch (_b) {}

    await this.dev.close();
  }

  async readLoop() {
    var _a, _b;

    if (this.readLoopStarted) return;
    this.readLoopStarted = true;
    console.debug("start read loop");

    const readpkt = async reader => {
      let value = null;

      for (;;) {
        const tmp = await reader.read();
        if (tmp.done || !this.dev) return null; // reader cancelled

        if (!value) value = tmp.value;else value = bufferConcat(value, tmp.value); // Despite the fact that the device always sends full 64 bytes USB packets
        // the Windows serial driver will sometimes give only one character, and then the remaining
        // 63 in the second read - this must be going through some UART abstraction layers I guess... ¯\_(ツ)_/¯

        if (value && (value.length & 63) == 0) return value;
      }
    };

    for (;;) {
      const reader = (_b = (_a = this.dev) === null || _a === void 0 ? void 0 : _a.readable) === null || _b === void 0 ? void 0 : _b.getReader();

      if (!reader) {
        await delay(100);
        continue;
      }

      this.reader = reader;
      console.debug("start new read loop round");

      try {
        // eslint-disable-next-line no-constant-condition
        for (;;) {
          const value = await readpkt(reader);
          if (!value) break; // console.log("Recv", toHex(value))

          if (value.length > 64) for (let i = 0; i < value.length; i += 64) {
            this.onData(value.slice(i, i + 64));
          } else this.onData(value);
        }
      } catch (e) {
        if (this.dev) this.onError(e);
        await delay(100);
      } finally {
        try {
          reader.releaseLock();
        } catch (_c) {}

        await delay(100);
      }
    }
  }

  sendPacketAsync(pkt) {
    if (!this.dev || !this.writer) return Promise.reject(new Error("Disconnected"));
    assert(pkt.length <= 64); // console.log("Send", toHex(pkt))

    if (pkt.length < 64) {
      const p = pkt;
      pkt = new Uint8Array(64);
      pkt.set(p);
    }

    return this.writer.write(pkt);
  }

  async tryReconnectAsync() {
    try {
      const ports = await navigator.serial.getPorts();
      this.dev = ports[0];
    } catch (e) {
      console.log(e);
      this.dev = undefined;
    }
  }

  async requestDeviceAsync() {
    try {
      this.dev = await navigator.serial.requestPort(WEB_SERIAL_FILTERS);
    } catch (e) {
      console.log(e);
      this.dev = undefined;
    }
  }

  async connectAsync(background, deviceId) {
    await this.tryReconnectAsync();
    if (!this.dev && !background) await this.requestDeviceAsync(); // background call and no device, just give up for now

    if (!this.dev && background) throwError("device not paired", true); // let's connect

    await this.openDeviceAsync();
    const proto = this.mkProto();

    try {
      await proto.postConnectAsync();
    } catch (e) {
      console.debug(e);
      await proto.disconnectAsync();
      throw e;
    }

    return proto;
  }

  async openDeviceAsync() {
    var _a;

    if (!this.dev) throwError("device not found");
    await this.dev.open({
      baudRate: 115200,
      bufferSize: 32 * 1024
    });
    this.writer = (_a = this.dev.writable) === null || _a === void 0 ? void 0 : _a.getWriter();
    if (!this.writer) throwError("no writer");
    this.ready = true;
    /* no await */

    this.readLoop();
  }

}
/**
 * @internal
 */


class EventTargetObservable {
  constructor(element, eventName) {
    this.element = element;
    this.eventName = eventName;
  }

  subscribe(observer) {
    const handler = ev => !!observer.next && observer.next(ev);

    this.element.addEventListener(this.eventName, handler, false);
    return {
      unsubscribe: () => this.element.removeEventListener(this.eventName, handler)
    };
  }

}

function isWebUSBEnabled() {
  return !!Flags.webUSB;
}

function isWebUSBSupported() {
  try {
    return typeof navigator !== "undefined" && !!navigator.usb && !!navigator.usb.getDevices;
  } catch (e) {
    return false;
  }
}

function usbRequestDevice(options) {
  var _a, _b; // disabled


  if (!Flags.webUSB) return Promise.resolve(undefined);

  try {
    return (_b = (_a = navigator === null || navigator === void 0 ? void 0 : navigator.usb) === null || _a === void 0 ? void 0 : _a.requestDevice) === null || _b === void 0 ? void 0 : _b.call(_a, options);
  } catch (e) {
    if (Flags.diagnostics) console.warn(e);
    return undefined;
  }
}

function usbGetDevices() {
  var _a; // disabled


  if (!Flags.webUSB) return Promise.resolve([]);

  try {
    return ((_a = navigator === null || navigator === void 0 ? void 0 : navigator.usb) === null || _a === void 0 ? void 0 : _a.getDevices()) || Promise.resolve([]);
  } catch (e) {
    if (Flags.diagnostics) console.warn(e);
    return Promise.resolve([]);
  }
}

class WebUSBTransport extends Transport {
  constructor(options) {
    super(USB_TRANSPORT, Object.assign(Object.assign({}, options), {
      checkPulse: true
    }));
    this.options = options;
  }

  async transportConnectAsync(background) {
    const transport = new USBIO(this.options);

    transport.onError = e => this.errorHandler(USB_TRANSPORT, e);

    this.hf2 = await transport.connectAsync(background);
    this.hf2.onJDMessage(this.handleFrame.bind(this));
  }

  async transportSendPacketAsync(p) {
    if (!this.hf2) throw new Error("hf2 transport disconnected");
    const buf = p.toBuffer();
    await this.hf2.sendJDMessageAsync(buf);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  async transportDisconnectAsync(background) {
    const h = this.hf2;
    this.hf2 = undefined;
    if (h) await h.disconnectAsync();
  }

}

function defaultOptions() {
  return isWebUSBSupported() && {
    getDevices: usbGetDevices,
    requestDevice: usbRequestDevice,
    connectObservable: new EventTargetObservable(navigator.usb, "connect"),
    disconnectObservable: new EventTargetObservable(navigator.usb, "disconnect")
  };
}

function createUSBTransport(options) {
  if (!options) options = defaultOptions();
  return options && new WebUSBTransport(options);
}

function createUSBBus(options) {
  return new JDBus([createUSBTransport(options)]);
}

class WorkerTransport extends Transport {
  constructor(type, worker, options) {
    super(type, options);
    this.type = type;
    this.worker = worker;
    this.options = options; // eslint-disable-next-line @typescript-eslint/no-explicit-any

    this.pending = {};
    this.worker.addEventListener("message", this.handleMessage.bind(this));
  } // eslint-disable-next-line @typescript-eslint/no-explicit-any


  postMessageAsync(msg) {
    const id = msg.id = "" + Math.random();
    const p = new Promise((resolve, reject) => {
      this.worker.postMessage(msg);
      this.pending[id] = {
        resolve,
        reject
      };
    });
    return p;
  }

  handleMessage(ev) {
    const data = ev.data;
    const {
      jacdac,
      type
    } = data || {};
    if (!jacdac) return; // not our message

    switch (type) {
      case "packet":
        {
          const {
            payload
          } = data; //debug(`wt: packet`, payload)

          this.handlePacket(payload);
          break;
        }

      case "frame":
        {
          const {
            payload
          } = data; //debug(`wt: frame`, payload)

          this.handleFrame(payload);
          break;
        }

      case "connect":
      case "disconnect":
        {
          const {
            id,
            error
          } = data;
          const {
            resolve,
            reject
          } = this.pending[id] || {};

          if (resolve) {
            if (error) reject(error);else resolve(undefined);
          }

          break;
        }

      case "error":
        {
          const {
            error,
            background,
            type
          } = data;
          if (Flags.diagnostics) console.debug(data);
          if (!background) this.errorHandler(type, error);
          break;
        }
    }
  }

  async transportSendPacketAsync(p) {
    // don't wait
    const buf = p.toBuffer();
    this.worker.postMessage({
      jacdac: true,
      type: "packet",
      payload: buf
    });
  }

  async transportConnectAsync(background) {
    let deviceId;

    if (!background) {
      // request permission first
      deviceId = await this.options.requestDevice();
    } // try connect


    await this.postMessageAsync({
      jacdac: true,
      type: "connect",
      deviceId,
      background
    });
  }

  transportDisconnectAsync(background) {
    return this.postMessageAsync({
      jacdac: true,
      type: "disconnect",
      background
    });
  }

}

function createUSBWorkerTransport(worker) {
  return isWebUSBEnabled() && new WorkerTransport(USB_TRANSPORT, worker, {
    checkPulse: true,
    requestDevice: () => usbRequestDevice(USB_FILTERS).then(dev => dev === null || dev === void 0 ? void 0 : dev.serialNumber),
    connectObservable: new EventTargetObservable(navigator.usb, "connect"),
    disconnectObservable: new EventTargetObservable(navigator.usb, "disconnect")
  });
}

function isWebSerialEnabled() {
  return !!Flags.webSerial;
}

function isWebSerialSupported() {
  try {
    return typeof navigator !== "undefined" && !!navigator.serial && !!navigator.serial.getPorts;
  } catch (e) {
    return false;
  }
}

class WebSerialTransport extends Transport {
  constructor(mkTransport) {
    super(SERIAL_TRANSPORT);
    this.mkTransport = mkTransport;
  }

  async transportConnectAsync(background) {
    const transport = this.mkTransport();

    transport.onError = e => this.errorHandler(USB_TRANSPORT, e);

    this.hf2 = await transport.connectAsync(background);
    this.hf2.onJDMessage(this.handleFrame.bind(this));
  }

  async transportSendPacketAsync(p) {
    if (!this.hf2) throw new Error("hf2 transport disconnected");
    const buf = p.toBuffer();
    await this.hf2.sendJDMessageAsync(buf);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  async transportDisconnectAsync(background) {
    const h = this.hf2;
    this.hf2 = undefined;
    if (h) await h.disconnectAsync();
  }

}
/**
 * Creates a transport over a Web Serial connection
 * @category
 */


function createWebSerialTransport(mkTransport = () => new WebSerialIO()) {
  return isWebSerialSupported() && new WebSerialTransport(mkTransport);
}
/**
 * Creates a bus with a Web Serial connection
 * @category
 */


function createWebSerialBus() {
  return new JDBus([createWebSerialTransport()]);
}

function createNodeUSBOptions() {
  console.debug(`jacdac: creating usb transport`);

  async function devicesFound(devices) {
    for (const device of devices) {
      // microbit v2
      if (device.vendorId === MICROBIT_V2_VENDOR_ID && device.productId === MICROBIT_V2_PRODUCT_ID) {
        return device;
      } // jacdac device
      else if (device.deviceVersionMajor == HF2_DEVICE_MAJOR) {
        for (const iface of device.configuration.interfaces) {
          const alt = iface.alternates[0];

          if (alt.interfaceClass == 0xff && alt.interfaceSubclass == HF2_DEVICE_MAJOR) {
            return device;
          }
        }
      }
    }

    return undefined;
  } // eslint-disable-next-line @typescript-eslint/no-var-requires


  const USB = require("webusb").USB;

  const usb = new USB({
    devicesFound
  });

  async function requestDevice(options) {
    console.debug(`requesting device...`);

    try {
      const device = await usb.requestDevice(options);
      return device;
    } catch (e) {
      console.debug(e);
      return undefined;
    }
  }

  async function getDevices(options) {
    //const devices = await usb.getDevices()
    //return devices
    const dev = await requestDevice(options);
    return dev ? [dev] : [];
  }

  const connectObservable = new EventTargetObservable(usb, "connect");
  const disconnectObservable = new EventTargetObservable(usb, "disconnect");
  return {
    getDevices,
    requestDevice,
    connectObservable,
    disconnectObservable
  };
}

function toPromise(f) {
  return new Promise((resolve, reject) => f((err, result) => {
    if (err) reject(err);else resolve(result);
  }));
}
/**
 * @internal
 */


class NodeWebSerialIO {
  /**
   *
   * @param SerialPort ``require("serialport")``
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(SerialPort) {
    this.SerialPort = SerialPort;
    this.ready = false; // eslint-disable-next-line @typescript-eslint/no-unused-vars

    this.onData = v => {};

    this.onError = e => {
      console.warn(`usb error: ${errorCode(e) || ""} ${e ? e.stack : e}`);
    };
  } // eslint-disable-next-line @typescript-eslint/no-explicit-any


  log(msg, v) {
    if (Flags.diagnostics) {
      if (v != undefined) console.debug("usb: " + msg, v);else console.debug("usb: " + msg);
    }
  }

  mkProto() {
    return new HF2Proto(this);
  }

  clearDev() {
    if (this.dev) {
      this.dev = null;

      this.onData = () => console.warn("rogue webserial hf2 onData");
    }
  }

  disconnectAsync() {
    this.ready = false;
    if (!this.dev) return Promise.resolve();
    console.debug("close device");
    return this.cancelStreams().catch(e => {
      // just ignore errors closing, most likely device just disconnected
      console.debug(e);
    }).then(() => {
      this.clearDev();
      return delay(500);
    });
  }

  devInfo() {
    if (!this.port) return "n/a";
    return this.port.vendorId + ":" + this.port.productId;
  }

  error(msg, code) {
    const e = new JDError(`serial device ${this.devInfo()} (${msg})`, code);
    this.onError(e);
  }

  async cancelStreams() {
    await toPromise(cb => this.dev.close(cb));
  }

  sendPacketAsync(pkt) {
    if (!this.dev) return Promise.reject(new Error("Disconnected"));
    assert(pkt.length <= 64); // console.log("Send", toHex(pkt))

    if (pkt.length < 64) {
      const p = pkt;
      pkt = new Uint8Array(64);
      pkt.set(p);
    }

    return toPromise(cb => this.dev.write(pkt, undefined, cb));
  }

  async tryReconnectAsync() {
    try {
      this.dev = undefined;
      this.port = undefined;
      const ports = await this.SerialPort.list();
      this.port = ports.filter(p => /^PX/.test(p.serialNumber) || WEB_SERIAL_FILTERS.filters.some(f => f.usbVendorId == parseInt(p.vendorId, 16)))[0];

      if (this.port) {
        await toPromise(cb => {
          this.dev = new this.SerialPort(this.port.path, {
            baudRate: 115200
          }, cb);
        });
        let tmpdata;
        this.dev.on("data", buf => {
          if (tmpdata) buf = bufferConcat(tmpdata, buf);
          tmpdata = null; // This was only observed with WebSerial, but better safe than sorry

          if (buf.length & 63) {
            tmpdata = buf;
            return;
          }

          if (buf.length > 64) for (let i = 0; i < buf.length; i += 64) {
            this.onData(buf.slice(i, i + 64));
          } else this.onData(buf);
        });
        this.dev.on("error", err => {
          this.error(err.messsage || err + "");
        });
      }
    } catch (e) {
      console.log(e);
      this.dev = undefined;
      this.port = undefined;
    }
  }

  async connectAsync(background, deviceId) {
    await this.tryReconnectAsync();
    if (!this.dev && background) throwError("can't find suitable device", true);
    const proto = this.mkProto();

    try {
      await proto.postConnectAsync();
    } catch (e) {
      console.debug(e);
      await proto.disconnectAsync();
      throw e;
    }

    return proto;
  }

}

class IFrameBridge extends JDBridge {
  constructor(targetOrigin) {
    super();
    this.targetOrigin = targetOrigin;
    this.handleMessage = this.handleMessage.bind(this);
    window.addEventListener("message", this.handleMessage, false);
    this.mount(() => window.removeEventListener("message", this.handleMessage));
    console.debug(`jacdac: iframe bridge created`);
  }

  handleMessage(msg) {
    const {
      data
    } = msg;

    if (data.channel === "jacdac" && data.type === "messagepacket") {
      const payload = data.data;
      this.receivePacket(payload);
    }
  }

  sendPacket(data) {
    const msg = {
      type: "messagepacket",
      channel: "jacdac",
      data,
      sender: this.bridgeId,
      broadcast: true
    };
    window.parent.postMessage(msg, this.targetOrigin);
  }

}

function createIFrameBridge(parentOrigin = "*") {
  return inIFrame() && new IFrameBridge(parentOrigin);
}

function startDevTools() {
  if (typeof window !== "undefined" && !/^https:\/\/microsoft.github.io\/jacdac-docs\//.test(window.location.href)) window.location.href = `https://microsoft.github.io/jacdac-docs/clients/javascript/devtools.html#${window.location.href}`;
}
/**
 * Creates a Jacdac bus using WebUSB, WebSerial or WebBluetooth
 * @param options
 * @returns
 * @category Transport
 */


function createWebBus(options) {
  const {
    usbOptions,
    iframeTargetOrigin
  } = options || {};
  const bus = new JDBus([usbOptions !== null && createUSBTransport(usbOptions), createWebSerialTransport(), createBluetoothTransport()]);
  const iframeBridge = iframeTargetOrigin !== null && createIFrameBridge(iframeTargetOrigin);
  if (iframeBridge) iframeBridge.bus = bus;
  return bus;
}
/**
 * Indicates if any of the USB/Serial/Bluetooth transports is supported
 * @returns
 * @category Transport
 */


function isWebTransportSupported() {
  return isWebUSBSupported() || isWebSerialSupported() || isWebBluetoothSupported();
}
/**
 * A role manager
 * @category Roles
 */


class RoleManager extends JDClient {
  constructor(bus) {
    super();
    this._roles = [];
    this.bus = bus;
    this.mount(this.bus.subscribe(DEVICE_ANNOUNCE, this.addServices.bind(this)));
    this.mount(this.bus.subscribe(DEVICE_DISCONNECT, this.removeServices.bind(this)));
    this.bindServices();
  }
  /**
   * Indicates if all roles are bound.
   */


  get isBound() {
    return this._roles.every(({
      service
    }) => !!service);
  }
  /**
   * Gets the list of roles tracked by the manager
   */


  roles(bound = undefined) {
    if (bound !== undefined) return this._roles.filter(({
      service
    }) => !!service === bound);else return this._roles.slice(0);
  }
  /**
   * Updates the list of roles
   * @param newRoles
   */


  updateRoles(newRoles) {
    const oldBound = this.isBound;
    let changed = false; // remove unknown roles

    const supportedNewRoles = newRoles.filter(({
      serviceClass
    }) => serviceSpecificationFromClassIdentifier(serviceClass)); // unbind removed roles

    let i = 0;

    while (i < this._roles.length) {
      const role = this._roles[i];

      if (!supportedNewRoles.find(r => r.role === role.role)) {
        changed = true;

        this._roles.splice(i, 1);

        this.emit(ROLE_UNBOUND, role.role);
      } else {
        i++;
      }
    } // update or add roles


    for (const newRole of supportedNewRoles) {
      const existingRole = this._roles.find(r => r.role === newRole.role);

      if (!existingRole) {
        // added role
        changed = true;

        this._roles.push(Object.assign({}, newRole));
      } else if (existingRole.serviceClass !== newRole.serviceClass) {
        // modified type, force rebinding
        changed = true;
        existingRole.serviceClass = newRole.serviceClass;

        if (existingRole.service) {
          existingRole.service = undefined;
          this.emit(ROLE_UNBOUND, existingRole.role);
        }
      } // else unmodifed role

    } // bound services


    this.bindServices(changed);
    this.emitBoundEvents(oldBound);
  }
  /**
   * Resolves the service bound to a given role.
   * @param role
   * @returns
   */


  service(role) {
    var _a;

    return (_a = this._roles.find(r => r.role === role)) === null || _a === void 0 ? void 0 : _a.service;
  }
  /**
   * Updates or creates a new role
   * @param role name of the role
   * @param serviceClass desired service class
   * @param preferredDeviceId optional preferred device id
   * @returns
   */


  updateRole(role, serviceClass, preferredDeviceId) {
    if (!serviceSpecificationFromClassIdentifier(serviceClass)) return; // unknown role type

    let binding = this._roles.find(r => r.role === role); // check if we already have this role


    if (binding && serviceClass === binding.serviceClass) {
      if (!binding.service && preferredDeviceId) {
        binding.preferredDeviceId = preferredDeviceId;
      }

      return;
    }

    const oldBound = this.isBound; // new role

    binding = {
      role,
      serviceClass,
      preferredDeviceId
    };

    this._roles.push(binding);

    if (!this.bindRole(binding)) {
      this.emit(ROLE_UNBOUND, role);
    }

    this.emit(CHANGE);
    this.emitBoundEvents(oldBound);
  }

  emitBoundEvents(oldBound) {
    const bound = this.isBound;
    if (oldBound !== bound) this.emit(bound ? BOUND : UNBOUND);
  } // TODO: need to respect other (unbound) role's preferredDeviceId


  bindRole(role) {
    const ret = this.bus.services({
      ignoreInfrastructure: true,
      serviceClass: role.serviceClass
    }).filter(s => !this.roles(true).find(r => r.service === s));

    if (ret.length) {
      let theOne = ret[0];

      if (role.preferredDeviceId) {
        const newOne = ret.find(s => s.device.deviceId === role.preferredDeviceId);
        if (newOne) theOne = newOne;
      }

      role.service = theOne;
      this.emit(ROLE_BOUND, role.role);
      return true;
    }

    return false;
  }

  bindServices(changed) {
    this.roles(false).forEach(binding => {
      if (this.bindRole(binding)) changed = true;
    });
    if (changed) this.emit(CHANGE);
  }

  addServices(dev) {
    if (dev === this.bus.selfDevice) return;
    this.bindServices();
  }

  removeServices(dev) {
    let changed = false;

    this._roles.filter(r => {
      var _a;

      return ((_a = r.service) === null || _a === void 0 ? void 0 : _a.device) === dev;
    }).forEach(r => {
      r.service = undefined;
      this.emit(ROLE_UNBOUND, r.role);
      changed = true;
    });

    this.bindServices(changed);
  }

  toString() {
    return this._roles.map(({
      role,
      service
    }) => `${role}->${service || "?"}`).join(",");
  }

}
/**
 * Tracks a set of roles
 * @param bus bus hosting the devices
 * @param bindings map of role names to device service pairs
 * @param onUpdate callback to run whenver role assignments change
 * @param options Additional options
 * @returns A unsubscribe callback to cleanup handlers
 * @category Roles
 */


function startRoles(bus, bindings, onUpdate, options) {
  const {
    incomplete
  } = options || {};
  const roleManager = new RoleManager(bus);
  roleManager.updateRoles(Object.keys(bindings).map(role => ({
    role,
    serviceClass: bindings[role].serviceClass,
    preferredDeviceId: bindings[role].preferredDeviceId
  })));

  const roles = () => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const r = {};

    for (const key in bindings) {
      const srv = roleManager.service(key);
      if (srv) r[key] = srv;
    }

    return r;
  };

  const update = () => {
    if (!incomplete && !roleManager.isBound) return;
    onUpdate(roles());
  };

  const unsubscribe = roleManager.subscribe(CHANGE, update);
  update();
  return unsubscribe;
}
/*
function test(bus: JDBus) {
    const bindings = {
        thermo1: { serviceClass: SRV_BUTTON },
        thermo2: { serviceClass: SRV_BUTTON },
    }
    trackRoles(
        bus,
        bindings,
        ({ thermo1, thermo2 }) => {
            console.log({ thermo1, thermo2 })
        },
        { incomplete: true }
    )
}
*/


let _sensorSpecs;
/**
 * Gets the list of sensor specifications available
 * @returns
 */


function sensorSpecifications() {
  if (!_sensorSpecs) {
    _sensorSpecs = serviceSpecifications().filter(srv => !srv.shortName.startsWith("_") && isSensor(srv));
  }

  return _sensorSpecs;
}
/**
 * Collects and flattens all sensor data into a serializable object
 * @param bus
 * @returns
 */


function snapshotSensors(bus) {
  return toMap(sensorSpecifications(), srv => srv.camelName, srv => bus.services({
    serviceClass: srv.classIdentifier,
    ignoreInfrastructure: true,
    announced: true
  }).map(srv => {
    var _a;

    const reg = srv.readingRegister;
    const spec = reg.specification;
    return spec.fields.length === 1 ? ((_a = reg.unpackedValue) === null || _a === void 0 ? void 0 : _a[0]) || 0 : reg.objectValue || {};
  }));
}

exports.ServiceTwinRegisterFlag = void 0;

(function (ServiceTwinRegisterFlag) {
  ServiceTwinRegisterFlag[ServiceTwinRegisterFlag["Const"] = 1] = "Const";
  ServiceTwinRegisterFlag[ServiceTwinRegisterFlag["Volatile"] = 2] = "Volatile";
})(exports.ServiceTwinRegisterFlag || (exports.ServiceTwinRegisterFlag = {}));

function serviceSpecificationToServiceTwinSpecification(specification) {
  if (!specification) return undefined;
  const {
    classIdentifier: serviceClass,
    camelName: name,
    packets
  } = specification;
  const registers = packets.filter(isHighLevelRegister) // TODO formalize
  .map(reg => {
    let flags = 0;
    if (reg.kind == "const") flags |= exports.ServiceTwinRegisterFlag.Const;
    if (reg.volatile) flags |= exports.ServiceTwinRegisterFlag.Volatile;
    const r = {
      code: reg.identifier,
      name: reg.name,
      flags,
      packf: reg.packFormat,
      fields: reg.fields.length > 1 ? reg.fields.map(f => f.name) : undefined
    };
    return r;
  });
  const dspec = {
    serviceClass,
    name,
    registers
  };
  return dspec;
}

function serviceSpecificationsWithServiceTwinSpecification() {
  const specs = [serviceSpecificationFromClassIdentifier(SRV_CONTROL), ...serviceSpecifications().filter(srv => !isInfrastructure(srv))];
  return specs;
}

exports.ACK_MAX_DELAY = ACK_MAX_DELAY;
exports.ACK_MIN_DELAY = ACK_MIN_DELAY;
exports.ALIGN = ALIGN;
exports.ANNOUNCE = ANNOUNCE;
exports.ANNOUNCE_INTERVAL = ANNOUNCE_INTERVAL;
exports.BLUETOOTH_JACDAC_DIAG_CHARACTERISTIC = BLUETOOTH_JACDAC_DIAG_CHARACTERISTIC;
exports.BLUETOOTH_JACDAC_RX_CHARACTERISTIC = BLUETOOTH_JACDAC_RX_CHARACTERISTIC;
exports.BLUETOOTH_JACDAC_SERVICE = BLUETOOTH_JACDAC_SERVICE;
exports.BLUETOOTH_JACDAC_TX_CHARACTERISTIC = BLUETOOTH_JACDAC_TX_CHARACTERISTIC;
exports.BLUETOOTH_TRANSPORT = BLUETOOTH_TRANSPORT;
exports.BOUND = BOUND;
exports.BUS_NODE_NAME = BUS_NODE_NAME;
exports.CHANGE = CHANGE;
exports.CLOSE = CLOSE;
exports.CMD_ADVERTISEMENT_DATA = CMD_ADVERTISEMENT_DATA;
exports.CMD_EVENT_CODE_MASK = CMD_EVENT_CODE_MASK;
exports.CMD_EVENT_COUNTER_MASK = CMD_EVENT_COUNTER_MASK;
exports.CMD_EVENT_COUNTER_POS = CMD_EVENT_COUNTER_POS;
exports.CMD_EVENT_MASK = CMD_EVENT_MASK;
exports.CMD_GET_REG = CMD_GET_REG;
exports.CMD_REG_MASK = CMD_REG_MASK;
exports.CMD_SET_REG = CMD_SET_REG;
exports.CMD_TOP_MASK = CMD_TOP_MASK;
exports.CMSISProto = CMSISProto;
exports.COMMAND_NODE_NAME = COMMAND_NODE_NAME;
exports.COMMAND_RECEIVE = COMMAND_RECEIVE;
exports.CONNECT = CONNECT;
exports.CONNECTING = CONNECTING;
exports.CONNECTION_STATE = CONNECTION_STATE;
exports.CONST_NODE_NAME = CONST_NODE_NAME;
exports.CRC_ACK_NODE_NAME = CRC_ACK_NODE_NAME;
exports.ControlServer = ControlServer;
exports.DATA = DATA;
exports.DEVICE_ANNOUNCE = DEVICE_ANNOUNCE;
exports.DEVICE_CHANGE = DEVICE_CHANGE;
exports.DEVICE_CLEAN = DEVICE_CLEAN;
exports.DEVICE_CONNECT = DEVICE_CONNECT;
exports.DEVICE_DISCONNECT = DEVICE_DISCONNECT;
exports.DEVICE_FIRMWARE_INFO = DEVICE_FIRMWARE_INFO;
exports.DEVICE_FOUND = DEVICE_FOUND;
exports.DEVICE_IMAGE_HEIGHT = DEVICE_IMAGE_HEIGHT;
exports.DEVICE_IMAGE_WIDTH = DEVICE_IMAGE_WIDTH;
exports.DEVICE_LOST = DEVICE_LOST;
exports.DEVICE_NODE_NAME = DEVICE_NODE_NAME;
exports.DEVICE_PACKET_ANNOUNCE = DEVICE_PACKET_ANNOUNCE;
exports.DEVICE_RESTART = DEVICE_RESTART;
exports.DISCONNECT = DISCONNECT;
exports.DISCONNECTING = DISCONNECTING;
exports.DeviceStatsMonitor = DeviceStatsMonitor;
exports.EMBED_MIN_ASPECT_RATIO = EMBED_MIN_ASPECT_RATIO;
exports.ERROR = ERROR;
exports.ERROR_MICROBIT_INVALID_MEMORY = ERROR_MICROBIT_INVALID_MEMORY;
exports.ERROR_MICROBIT_JACDAC_MISSING = ERROR_MICROBIT_JACDAC_MISSING;
exports.ERROR_MICROBIT_UNKNOWN = ERROR_MICROBIT_UNKNOWN;
exports.ERROR_MICROBIT_V1 = ERROR_MICROBIT_V1;
exports.EVENT = EVENT;
exports.EVENT_NODE_NAME = EVENT_NODE_NAME;
exports.FIELD_NODE_NAME = FIELD_NODE_NAME;
exports.FIRMWARE_BLOBS_CHANGE = FIRMWARE_BLOBS_CHANGE;
exports.FLASH_MAX_DEVICES = FLASH_MAX_DEVICES;
exports.FOUND = FOUND;
exports.Flags = Flags;
exports.GET_ATTEMPT = GET_ATTEMPT;
exports.HF2Proto = HF2Proto;
exports.HF2_CMD_BININFO = HF2_CMD_BININFO;
exports.HF2_CMD_CHKSUM_PAGES = HF2_CMD_CHKSUM_PAGES;
exports.HF2_CMD_DMESG = HF2_CMD_DMESG;
exports.HF2_CMD_INFO = HF2_CMD_INFO;
exports.HF2_CMD_JDS_CONFIG = HF2_CMD_JDS_CONFIG;
exports.HF2_CMD_JDS_SEND = HF2_CMD_JDS_SEND;
exports.HF2_CMD_READ_WORDS = HF2_CMD_READ_WORDS;
exports.HF2_CMD_RESET_INTO_APP = HF2_CMD_RESET_INTO_APP;
exports.HF2_CMD_RESET_INTO_BOOTLOADER = HF2_CMD_RESET_INTO_BOOTLOADER;
exports.HF2_CMD_START_FLASH = HF2_CMD_START_FLASH;
exports.HF2_CMD_WRITE_FLASH_PAGE = HF2_CMD_WRITE_FLASH_PAGE;
exports.HF2_CMD_WRITE_WORDS = HF2_CMD_WRITE_WORDS;
exports.HF2_DEVICE_MAJOR = HF2_DEVICE_MAJOR;
exports.HF2_EV_JDS_PACKET = HF2_EV_JDS_PACKET;
exports.HF2_EV_MASK = HF2_EV_MASK;
exports.HF2_FLAG_CMDPKT_BODY = HF2_FLAG_CMDPKT_BODY;
exports.HF2_FLAG_CMDPKT_LAST = HF2_FLAG_CMDPKT_LAST;
exports.HF2_FLAG_MASK = HF2_FLAG_MASK;
exports.HF2_FLAG_SERIAL_ERR = HF2_FLAG_SERIAL_ERR;
exports.HF2_FLAG_SERIAL_OUT = HF2_FLAG_SERIAL_OUT;
exports.HF2_MODE_BOOTLOADER = HF2_MODE_BOOTLOADER;
exports.HF2_MODE_USERSPACE = HF2_MODE_USERSPACE;
exports.HF2_SIZE_MASK = HF2_SIZE_MASK;
exports.HF2_STATUS_EVENT = HF2_STATUS_EVENT;
exports.HF2_STATUS_EXEC_ERR = HF2_STATUS_EXEC_ERR;
exports.HF2_STATUS_INVALID_CMD = HF2_STATUS_INVALID_CMD;
exports.HF2_STATUS_OK = HF2_STATUS_OK;
exports.IDENTIFY = IDENTIFY;
exports.IDENTIFY_DURATION = IDENTIFY_DURATION;
exports.JACDAC_ERROR = JACDAC_ERROR;
exports.JDBridge = JDBridge;
exports.JDBus = JDBus;
exports.JDClient = JDClient;
exports.JDDevice = JDDevice;
exports.JDError = JDError;
exports.JDEvent = JDEvent;
exports.JDEventSource = JDEventSource;
exports.JDField = JDField;
exports.JDNode = JDNode;
exports.JDRegister = JDRegister;
exports.JDRegisterServer = JDRegisterServer;
exports.JDServerServiceProvider = JDServerServiceProvider;
exports.JDService = JDService;
exports.JDServiceClient = JDServiceClient;
exports.JDServiceMemberNode = JDServiceMemberNode;
exports.JDServiceProvider = JDServiceProvider;
exports.JDServiceServer = JDServiceServer;
exports.JD_ADVERTISEMENT_0_ACK_SUPPORTED = JD_ADVERTISEMENT_0_ACK_SUPPORTED;
exports.JD_ADVERTISEMENT_0_COUNTER_MASK = JD_ADVERTISEMENT_0_COUNTER_MASK;
exports.JD_DEVICE_DISCONNECTED_DELAY = JD_DEVICE_DISCONNECTED_DELAY;
exports.JD_DEVICE_LOST_DELAY = JD_DEVICE_LOST_DELAY;
exports.JD_FRAME_FLAG_ACK_REQUESTED = JD_FRAME_FLAG_ACK_REQUESTED;
exports.JD_FRAME_FLAG_COMMAND = JD_FRAME_FLAG_COMMAND;
exports.JD_FRAME_FLAG_IDENTIFIER_IS_SERVICE_CLASS = JD_FRAME_FLAG_IDENTIFIER_IS_SERVICE_CLASS;
exports.JD_SERIAL_HEADER_SIZE = JD_SERIAL_HEADER_SIZE;
exports.JD_SERIAL_MAX_PAYLOAD_SIZE = JD_SERIAL_MAX_PAYLOAD_SIZE;
exports.JD_SERVICE_INDEX_CRC_ACK = JD_SERVICE_INDEX_CRC_ACK;
exports.JD_SERVICE_INDEX_CTRL = JD_SERVICE_INDEX_CTRL;
exports.JD_SERVICE_INDEX_INV_MASK = JD_SERVICE_INDEX_INV_MASK;
exports.JD_SERVICE_INDEX_MASK = JD_SERVICE_INDEX_MASK;
exports.JD_SERVICE_INDEX_MAX_NORMAL = JD_SERVICE_INDEX_MAX_NORMAL;
exports.JD_SERVICE_INDEX_PIPE = JD_SERVICE_INDEX_PIPE;
exports.JOYSTICK_ARCADE_BUTTONS = JOYSTICK_ARCADE_BUTTONS;
exports.JOYSTICK_DPAD_AB_BUTTONS = JOYSTICK_DPAD_AB_BUTTONS;
exports.JOYSTICK_DPAD_A_BUTTONS = JOYSTICK_DPAD_A_BUTTONS;
exports.JOYSTICK_DPAD_BUTTONS = JOYSTICK_DPAD_BUTTONS;
exports.JOYSTICK_GAMEPAD_EXTRA_BUTTONS = JOYSTICK_GAMEPAD_EXTRA_BUTTONS;
exports.JSONTryParse = JSONTryParse;
exports.LATE = LATE;
exports.LOST = LOST;
exports.MAX_SERVICES_LENGTH = MAX_SERVICES_LENGTH;
exports.MESSAGE = MESSAGE;
exports.META_ACK = META_ACK;
exports.META_ACK_FAILED = META_ACK_FAILED;
exports.META_GET = META_GET;
exports.META_PIPE = META_PIPE;
exports.META_TRACE = META_TRACE;
exports.MICROBIT_V2_PRODUCT_ID = MICROBIT_V2_PRODUCT_ID;
exports.MICROBIT_V2_VENDOR_ID = MICROBIT_V2_VENDOR_ID;
exports.NEW_LISTENER = NEW_LISTENER;
exports.NodeWebSerialIO = NodeWebSerialIO;
exports.PACKETIO_TRANSPORT = PACKETIO_TRANSPORT;
exports.PACKET_ANNOUNCE = PACKET_ANNOUNCE;
exports.PACKET_DATA_NORMALIZE = PACKET_DATA_NORMALIZE;
exports.PACKET_EVENT = PACKET_EVENT;
exports.PACKET_INVALID_CRC = PACKET_INVALID_CRC;
exports.PACKET_INVALID_DATA = PACKET_INVALID_DATA;
exports.PACKET_KIND_ANNOUNCE = PACKET_KIND_ANNOUNCE;
exports.PACKET_KIND_EVENT = PACKET_KIND_EVENT;
exports.PACKET_KIND_RO = PACKET_KIND_RO;
exports.PACKET_KIND_RW = PACKET_KIND_RW;
exports.PACKET_PRE_PROCESS = PACKET_PRE_PROCESS;
exports.PACKET_PROCESS = PACKET_PROCESS;
exports.PACKET_RECEIVE = PACKET_RECEIVE;
exports.PACKET_RECEIVE_ANNOUNCE = PACKET_RECEIVE_ANNOUNCE;
exports.PACKET_REPORT = PACKET_REPORT;
exports.PACKET_SEND = PACKET_SEND;
exports.PACKET_SEND_DISCONNECT = PACKET_SEND_DISCONNECT;
exports.PING_LOGGERS_POLL = PING_LOGGERS_POLL;
exports.PIPE_CLOSE_MASK = PIPE_CLOSE_MASK;
exports.PIPE_COUNTER_MASK = PIPE_COUNTER_MASK;
exports.PIPE_METADATA_MASK = PIPE_METADATA_MASK;
exports.PIPE_NODE_NAME = PIPE_NODE_NAME;
exports.PIPE_PORT_SHIFT = PIPE_PORT_SHIFT;
exports.PIPE_REPORT_NODE_NAME = PIPE_REPORT_NODE_NAME;
exports.PROGRESS = PROGRESS;
exports.Packet = Packet;
exports.PromiseBuffer = PromiseBuffer;
exports.PromiseQueue = PromiseQueue;
exports.READING_SENT = READING_SENT;
exports.REFRESH = REFRESH;
exports.REFRESH_REGISTER_POLL = REFRESH_REGISTER_POLL;
exports.REGISTER_NODE_NAME = REGISTER_NODE_NAME;
exports.REGISTER_OPTIONAL_POLL_COUNT = REGISTER_OPTIONAL_POLL_COUNT;
exports.REGISTER_POLL_FIRST_REPORT_INTERVAL = REGISTER_POLL_FIRST_REPORT_INTERVAL;
exports.REGISTER_POLL_REPORT_INTERVAL = REGISTER_POLL_REPORT_INTERVAL;
exports.REGISTER_POLL_REPORT_MAX_INTERVAL = REGISTER_POLL_REPORT_MAX_INTERVAL;
exports.REGISTER_POLL_REPORT_VOLATILE_INTERVAL = REGISTER_POLL_REPORT_VOLATILE_INTERVAL;
exports.REGISTER_POLL_REPORT_VOLATILE_MAX_INTERVAL = REGISTER_POLL_REPORT_VOLATILE_MAX_INTERVAL;
exports.REGISTER_POLL_STREAMING_INTERVAL = REGISTER_POLL_STREAMING_INTERVAL;
exports.REGISTER_PRE_GET = REGISTER_PRE_GET;
exports.REGISTER_REFRESH_RETRY_0 = REGISTER_REFRESH_RETRY_0;
exports.REGISTER_REFRESH_RETRY_1 = REGISTER_REFRESH_RETRY_1;
exports.REGISTER_REFRESH_TIMEOUT = REGISTER_REFRESH_TIMEOUT;
exports.REMOVE_LISTENER = REMOVE_LISTENER;
exports.RENDER = RENDER;
exports.REPORT_NODE_NAME = REPORT_NODE_NAME;
exports.REPORT_RECEIVE = REPORT_RECEIVE;
exports.REPORT_UPDATE = REPORT_UPDATE;
exports.RESET = RESET;
exports.RESET_IN_TIME_US = RESET_IN_TIME_US;
exports.RESTART = RESTART;
exports.ROLE_BOUND = ROLE_BOUND;
exports.ROLE_CHANGE = ROLE_CHANGE;
exports.ROLE_HAS_NO_SERVICE = ROLE_HAS_NO_SERVICE;
exports.ROLE_MANAGER_CHANGE = ROLE_MANAGER_CHANGE;
exports.ROLE_MANAGER_POLL = ROLE_MANAGER_POLL;
exports.ROLE_UNBOUND = ROLE_UNBOUND;
exports.RoleManager = RoleManager;
exports.RoleManagerClient = RoleManagerClient;
exports.SELF_ANNOUNCE = SELF_ANNOUNCE;
exports.SERIAL_TRANSPORT = SERIAL_TRANSPORT;
exports.SERVICE_CLIENT_ADDED = SERVICE_CLIENT_ADDED;
exports.SERVICE_CLIENT_REMOVED = SERVICE_CLIENT_REMOVED;
exports.SERVICE_MIXIN_NODE_NAME = SERVICE_MIXIN_NODE_NAME;
exports.SERVICE_NODE_NAME = SERVICE_NODE_NAME;
exports.SERVICE_PROVIDER_ADDED = SERVICE_PROVIDER_ADDED;
exports.SERVICE_PROVIDER_REMOVED = SERVICE_PROVIDER_REMOVED;
exports.SERVICE_TEST_NODE_NAME = SERVICE_TEST_NODE_NAME;
exports.SG90_RESPONSE_SPEED = SG90_RESPONSE_SPEED;
exports.SRV_ACCELEROMETER = SRV_ACCELEROMETER;
exports.SRV_ARCADE_GAMEPAD = SRV_ARCADE_GAMEPAD;
exports.SRV_ARCADE_SOUND = SRV_ARCADE_SOUND;
exports.SRV_AZURE_IOT_HUB_HEALTH = SRV_AZURE_IOT_HUB_HEALTH;
exports.SRV_BARCODE_READER = SRV_BARCODE_READER;
exports.SRV_BAROMETER = SRV_BAROMETER;
exports.SRV_BIT_RADIO = SRV_BIT_RADIO;
exports.SRV_BOOTLOADER = SRV_BOOTLOADER;
exports.SRV_BUTTON = SRV_BUTTON;
exports.SRV_BUZZER = SRV_BUZZER;
exports.SRV_CAPACITIVE_BUTTON = SRV_CAPACITIVE_BUTTON;
exports.SRV_CHARACTER_SCREEN = SRV_CHARACTER_SCREEN;
exports.SRV_COLOR = SRV_COLOR;
exports.SRV_COMPASS = SRV_COMPASS;
exports.SRV_CONTROL = SRV_CONTROL;
exports.SRV_DIMMER = SRV_DIMMER;
exports.SRV_DISTANCE = SRV_DISTANCE;
exports.SRV_DMX = SRV_DMX;
exports.SRV_DOT_MATRIX = SRV_DOT_MATRIX;
exports.SRV_E_CO2 = SRV_E_CO2;
exports.SRV_FLEX = SRV_FLEX;
exports.SRV_GYROSCOPE = SRV_GYROSCOPE;
exports.SRV_HEART_RATE = SRV_HEART_RATE;
exports.SRV_HID_ADAPTER = SRV_HID_ADAPTER;
exports.SRV_HID_KEYBOARD = SRV_HID_KEYBOARD;
exports.SRV_HID_MOUSE = SRV_HID_MOUSE;
exports.SRV_HUMIDITY = SRV_HUMIDITY;
exports.SRV_ILLUMINANCE = SRV_ILLUMINANCE;
exports.SRV_INDEXED_SCREEN = SRV_INDEXED_SCREEN;
exports.SRV_INFRASTRUCTURE = SRV_INFRASTRUCTURE;
exports.SRV_JOYSTICK = SRV_JOYSTICK;
exports.SRV_LED = SRV_LED;
exports.SRV_LED_PIXEL = SRV_LED_PIXEL;
exports.SRV_LIGHT_LEVEL = SRV_LIGHT_LEVEL;
exports.SRV_LOGGER = SRV_LOGGER;
exports.SRV_MAGNETOMETER = SRV_MAGNETOMETER;
exports.SRV_MATRIX_KEYPAD = SRV_MATRIX_KEYPAD;
exports.SRV_MICROPHONE = SRV_MICROPHONE;
exports.SRV_MIDI_OUTPUT = SRV_MIDI_OUTPUT;
exports.SRV_MODEL_RUNNER = SRV_MODEL_RUNNER;
exports.SRV_MOTION = SRV_MOTION;
exports.SRV_MOTOR = SRV_MOTOR;
exports.SRV_MULTITOUCH = SRV_MULTITOUCH;
exports.SRV_POTENTIOMETER = SRV_POTENTIOMETER;
exports.SRV_POWER = SRV_POWER;
exports.SRV_PRESSURE_BUTTON = SRV_PRESSURE_BUTTON;
exports.SRV_PROTO_TEST = SRV_PROTO_TEST;
exports.SRV_PULSE_OXIMETER = SRV_PULSE_OXIMETER;
exports.SRV_RAIN_GAUGE = SRV_RAIN_GAUGE;
exports.SRV_REAL_TIME_CLOCK = SRV_REAL_TIME_CLOCK;
exports.SRV_REFLECTED_LIGHT = SRV_REFLECTED_LIGHT;
exports.SRV_RELAY = SRV_RELAY;
exports.SRV_RNG = SRV_RNG;
exports.SRV_ROLE_MANAGER = SRV_ROLE_MANAGER;
exports.SRV_ROTARY_ENCODER = SRV_ROTARY_ENCODER;
exports.SRV_ROVER = SRV_ROVER;
exports.SRV_SENSOR_AGGREGATOR = SRV_SENSOR_AGGREGATOR;
exports.SRV_SERVO = SRV_SERVO;
exports.SRV_SETTINGS = SRV_SETTINGS;
exports.SRV_SEVEN_SEGMENT_DISPLAY = SRV_SEVEN_SEGMENT_DISPLAY;
exports.SRV_SOIL_MOISTURE = SRV_SOIL_MOISTURE;
exports.SRV_SOLENOID = SRV_SOLENOID;
exports.SRV_SOUND_LEVEL = SRV_SOUND_LEVEL;
exports.SRV_SOUND_PLAYER = SRV_SOUND_PLAYER;
exports.SRV_SOUND_SPECTRUM = SRV_SOUND_SPECTRUM;
exports.SRV_SPEECH_SYNTHESIS = SRV_SPEECH_SYNTHESIS;
exports.SRV_SWITCH = SRV_SWITCH;
exports.SRV_TCP = SRV_TCP;
exports.SRV_THERMOCOUPLE = SRV_THERMOCOUPLE;
exports.SRV_THERMOMETER = SRV_THERMOMETER;
exports.SRV_TRAFFIC_LIGHT = SRV_TRAFFIC_LIGHT;
exports.SRV_TVOC = SRV_TVOC;
exports.SRV_UV_INDEX = SRV_UV_INDEX;
exports.SRV_VERIFIED_TELEMETRY = SRV_VERIFIED_TELEMETRY;
exports.SRV_VIBRATION_MOTOR = SRV_VIBRATION_MOTOR;
exports.SRV_WATER_LEVEL = SRV_WATER_LEVEL;
exports.SRV_WEIGHT_SCALE = SRV_WEIGHT_SCALE;
exports.SRV_WIFI = SRV_WIFI;
exports.SRV_WIND_DIRECTION = SRV_WIND_DIRECTION;
exports.SRV_WIND_SPEED = SRV_WIND_SPEED;
exports.START = START;
exports.STOP = STOP;
exports.STREAMING_DEFAULT_INTERVAL = STREAMING_DEFAULT_INTERVAL;
exports.SettingsClient = SettingsClient;
exports.TIMEOUT = TIMEOUT;
exports.TIMEOUT_DISCONNECT = TIMEOUT_DISCONNECT;
exports.TRACE = TRACE;
exports.TRACE_FILTER_HORIZON = TRACE_FILTER_HORIZON;
exports.TRANSPORT_CONNECT_RETRY_DELAY = TRANSPORT_CONNECT_RETRY_DELAY;
exports.TRANSPORT_PULSE_TIMEOUT = TRANSPORT_PULSE_TIMEOUT;
exports.TYPESCRIPT_STATIC_NAMESPACE = TYPESCRIPT_STATIC_NAMESPACE;
exports.Trace = Trace;
exports.TracePlayer = TracePlayer;
exports.TraceRecorder = TraceRecorder;
exports.TraceView = TraceView;
exports.Transport = Transport;
exports.UNBOUND = UNBOUND;
exports.USB_FILTERS = USB_FILTERS;
exports.USB_TRANSPORT = USB_TRANSPORT;
exports.VIRTUAL_DEVICE_NODE_NAME = VIRTUAL_DEVICE_NODE_NAME;
exports.WEBSOCKET_TRANSPORT = WEBSOCKET_TRANSPORT;
exports.WEB_SERIAL_FILTERS = WEB_SERIAL_FILTERS;
exports.WallClockScheduler = WallClockScheduler;
exports.WifiServer = WifiServer;
exports.addCustomServiceSpecification = addCustomServiceSpecification;
exports.addServiceProvider = addServiceProvider;
exports.arrayConcatMany = arrayConcatMany;
exports.arrayShuffle = arrayShuffle;
exports.assert = assert;
exports.bufferConcat = bufferConcat;
exports.bufferConcatMany = bufferConcatMany;
exports.bufferEq = bufferEq;
exports.bufferToArray = bufferToArray;
exports.bufferToString = bufferToString;
exports.camelize = camelize;
exports.capitalize = capitalize;
exports.clampToStorage = clampToStorage;
exports.cleanStack = cleanStack;
exports.clearCustomServiceSpecifications = clearCustomServiceSpecifications;
exports.clone = clone;
exports.commandName = commandName;
exports.concatBufferArray = concatBufferArray;
exports.converters = converters;
exports.crc = crc;
exports.createBluetoothTransport = createBluetoothTransport;
exports.createNodeUSBOptions = createNodeUSBOptions;
exports.createUSBBus = createUSBBus;
exports.createUSBTransport = createUSBTransport;
exports.createUSBWorkerTransport = createUSBWorkerTransport;
exports.createWebBus = createWebBus;
exports.createWebSerialBus = createWebSerialBus;
exports.createWebSerialTransport = createWebSerialTransport;
exports.dashify = dashify;
exports.dateToClock = dateToClock;
exports.debounce = debounce;
exports.debounceAsync = debounceAsync;
exports.decodeMember = decodeMember;
exports.decodeMembers = decodeMembers;
exports.decodePacketData = decodePacketData;
exports.decodeU32LE = decodeU32LE;
exports.delay = delay;
exports.dependencyId = dependencyId;
exports.deviceServiceName = deviceServiceName;
exports.deviceSpecificationFromIdentifier = deviceSpecificationFromIdentifier;
exports.deviceSpecificationFromProductIdentifier = deviceSpecificationFromProductIdentifier;
exports.deviceSpecifications = deviceSpecifications;
exports.deviceSpecificationsForService = deviceSpecificationsForService;
exports.ellipseJoin = ellipseJoin;
exports.encodeU32LE = encodeU32LE;
exports.encodings = encodings;
exports.errorCode = errorCode;
exports.escapeDeviceIdentifier = escapeDeviceIdentifier;
exports.escapeDeviceNameIdentifier = escapeDeviceNameIdentifier;
exports.flagsToValue = flagsToValue;
exports.flashFirmwareBlob = flashFirmwareBlob;
exports.flatClone = flatClone;
exports.fnv1 = fnv1;
exports.fromHex = fromHex;
exports.fromUTF8 = fromUTF8;
exports.generateDeviceSpecificationId = generateDeviceSpecificationId;
exports.getNumber = getNumber;
exports.groupBy = groupBy;
exports.hash = hash;
exports.hexDump = hexDump;
exports.hexNum = hexNum;
exports.hsvToCss = hsvToCss;
exports.humanify = humanify;
exports.identifierToUrlPath = identifierToUrlPath;
exports.idiv = idiv;
exports.inIFrame = inIFrame;
exports.intOfBuffer = intOfBuffer;
exports.isAckError = isAckError;
exports.isActuator = isActuator;
exports.isBufferEmpty = isBufferEmpty;
exports.isCancelError = isCancelError;
exports.isCommand = isCommand;
exports.isConstRegister = isConstRegister;
exports.isEvent = isEvent;
exports.isHighLevelEvent = isHighLevelEvent;
exports.isHighLevelRegister = isHighLevelRegister;
exports.isInfrastructure = isInfrastructure;
exports.isInstanceOf = isInstanceOf;
exports.isIntegerType = isIntegerType;
exports.isIntensity = isIntensity;
exports.isNumericType = isNumericType;
exports.isOptionalReadingRegisterCode = isOptionalReadingRegisterCode;
exports.isPipeReport = isPipeReport;
exports.isPipeReportOf = isPipeReportOf;
exports.isReading = isReading;
exports.isRegister = isRegister;
exports.isReportOf = isReportOf;
exports.isSensor = isSensor;
exports.isSet = isSet;
exports.isValue = isValue;
exports.isValueOrIntensity = isValueOrIntensity;
exports.isWebBluetoothEnabled = isWebBluetoothEnabled;
exports.isWebBluetoothSupported = isWebBluetoothSupported;
exports.isWebSerialEnabled = isWebSerialEnabled;
exports.isWebSerialSupported = isWebSerialSupported;
exports.isWebTransportSupported = isWebTransportSupported;
exports.isWebUSBEnabled = isWebUSBEnabled;
exports.isWebUSBSupported = isWebUSBSupported;
exports.jdpack = jdpack;
exports.jdpackEqual = jdpackEqual;
exports.jdunpack = jdunpack;
exports.jsonCopyFrom = jsonCopyFrom;
exports.lightEncode = lightEncode;
exports.loadServiceSpecifications = loadServiceSpecifications;
exports.memberValueToString = memberValueToString;
exports.memcpy = memcpy;
exports.modifierCodes = modifierCodes;
exports.normalizeDeviceSpecification = normalizeDeviceSpecification;
exports.numberFormatFromStorageType = numberFormatFromStorageType;
exports.numberFormatToStorageType = numberFormatToStorageType;
exports.objectToUnpacked = objectToUnpacked;
exports.packArguments = packArguments;
exports.packFormat = packFormat;
exports.packInfo = packInfo;
exports.packetSpeedTest = packetSpeedTest;
exports.parseDeviceId = parseDeviceId;
exports.parseFirmwareFile = parseFirmwareFile;
exports.parseLogicLog = parseLogicLog;
exports.parsePacketFilter = parsePacketFilter;
exports.parseServiceSpecificationMarkdownToJSON = parseServiceSpecificationMarkdownToJSON;
exports.parseTrace = parseTrace;
exports.parseUF2Firmware = parseUF2Firmware;
exports.pick = pick;
exports.prettyDuration = prettyDuration;
exports.prettyMemberUnit = prettyMemberUnit;
exports.prettyMicroDuration = prettyMicroDuration;
exports.prettySize = prettySize;
exports.prettyUnit = prettyUnit;
exports.printPacket = printPacket;
exports.randomRange = randomRange;
exports.range = range;
exports.read16 = read16;
exports.read32 = read32;
exports.readBlobToText = readBlobToText;
exports.readBlobToUint8Array = readBlobToUint8Array;
exports.renderHidMouseButtons = renderHidMouseButtons;
exports.renderKeyboardKey = renderKeyboardKey;
exports.replayLogicLog = replayLogicLog;
exports.resolveUnit = resolveUnit;
exports.reverseSelectors = reverseSelectors;
exports.rgbToHtmlColor = rgbToHtmlColor;
exports.roundWithPrecision = roundWithPrecision;
exports.scaleFloatToInt = scaleFloatToInt;
exports.scaleIntToFloat = scaleIntToFloat;
exports.secondaryUnitConverters = secondaryUnitConverters;
exports.selectors = selectors;
exports.sendStayInBootloaderCommand = sendStayInBootloaderCommand;
exports.sensorSpecifications = sensorSpecifications;
exports.serviceClass = serviceClass;
exports.serviceMap = serviceMap;
exports.serviceName = serviceName;
exports.serviceProviderDefinitionFromServiceClass = serviceProviderDefinitionFromServiceClass;
exports.serviceShortIdOrClass = serviceShortIdOrClass;
exports.serviceSpecificationFromClassIdentifier = serviceSpecificationFromClassIdentifier;
exports.serviceSpecificationFromName = serviceSpecificationFromName;
exports.serviceSpecificationToServiceTwinSpecification = serviceSpecificationToServiceTwinSpecification;
exports.serviceSpecifications = serviceSpecifications;
exports.serviceSpecificationsWithServiceTwinSpecification = serviceSpecificationsWithServiceTwinSpecification;
exports.setAckError = setAckError;
exports.setNumber = setNumber;
exports.shortDeviceId = shortDeviceId;
exports.signal = signal;
exports.sizeOfNumberFormat = sizeOfNumberFormat;
exports.snakify = snakify;
exports.snapshotSensors = snapshotSensors;
exports.splitFilter = splitFilter;
exports.stack = stack;
exports.startDevTools = startDevTools;
exports.startRoles = startRoles;
exports.startServiceProviderFromServiceClass = startServiceProviderFromServiceClass;
exports.storageTypeRange = storageTypeRange;
exports.strcmp = strcmp;
exports.stringToBuffer = stringToBuffer;
exports.stringToUint8Array = stringToUint8Array;
exports.throttle = throttle;
exports.throwError = throwError;
exports.toArray = toArray;
exports.toAscii = toAscii;
exports.toFullHex = toFullHex;
exports.toHex = toHex;
exports.toMap = toMap;
exports.toUTF8 = toUTF8;
exports.toggleBit = toggleBit;
exports.tonePayload = tonePayload;
exports.tryParseMemberValue = tryParseMemberValue;
exports.uint8ArrayToString = uint8ArrayToString;
exports.uintOfBuffer = uintOfBuffer;
exports.unique = unique;
exports.uniqueMap = uniqueMap;
exports.uniqueName = uniqueName;
exports.unitDescription = unitDescription;
exports.units = units;
exports.unpackedToObject = unpackedToObject;
exports.updateApplicable = updateApplicable;
exports.usbRequestDevice = usbRequestDevice;
exports.valueToFlags = valueToFlags;
exports.wrapDecodedMembers = wrapDecodedMembers;
exports.write16 = write16;
exports.write32 = write32;
},{"webusb":"../node_modules/webusb/dist/webusb.esm.js"}],"index.ts":[function(require,module,exports) {
"use strict";

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = this && this.__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function () {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];

      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;

        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };

        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;

        case 7:
          op = _.ops.pop();

          _.trys.pop();

          continue;

        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }

          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }

          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }

          if (t && _.label < t[2]) {
            _.label = t[2];

            _.ops.push(op);

            break;
          }

          if (t[2]) _.ops.pop();

          _.trys.pop();

          continue;
      }

      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

require("milligram");

var jacdac_ts_1 = require("jacdac-ts");

var connectEl = document.getElementById("connectbtn");
var logEl = document.getElementById("log");

var log = function (msg) {
  console.log(msg);
  logEl.innerText += msg + "\n";
}; // create WebUSB bus


var bus = (0, jacdac_ts_1.createWebBus)();

connectEl.onclick = function () {
  return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
      return [2
      /*return*/
      , bus.connected ? bus.disconnect() : bus.connect()];
    });
  });
}; // we're ready


log("click connect to start");
},{"milligram":"../node_modules/milligram/dist/milligram.css","jacdac-ts":"../node_modules/jacdac-ts/dist/jacdac.cjs.js"}],"../node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "49748" + '/');

  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);

          if (didAccept) {
            handled = true;
          }
        }
      }); // Enable HMR for CSS by default.

      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });

      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }

    if (data.type === 'reload') {
      ws.close();

      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel] ✨ Error resolved');
      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID; // html encode message and stack trace

  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }

  if (checkedAssets[id]) {
    return;
  }

  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}

function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });

    return true;
  }
}
},{}]},{},["../node_modules/parcel-bundler/src/builtins/hmr-runtime.js","index.ts"], null)
//# sourceMappingURL=/src.77de5100.js.map